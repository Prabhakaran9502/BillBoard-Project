{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mergeStateWithAggregationModel = exports.getAvailableAggregationFunctions = exports.getAggregationRules = exports.getAggregationFunctionLabel = exports.getAggregationFooterRowIdFromGroupId = exports.canColumnHaveAggregationFunction = exports.areAggregationRulesEqual = exports.addFooterRows = exports.GRID_AGGREGATION_ROOT_FOOTER_ROW_ID = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _utils = require(\"@mui/utils\");\n\nvar _internals = require(\"@mui/x-data-grid/internals\");\n\nvar _xDataGridPro = require(\"@mui/x-data-grid-pro\");\n\nvar _internals2 = require(\"@mui/x-data-grid-pro/internals\");\n\nconst GRID_AGGREGATION_ROOT_FOOTER_ROW_ID = exports.GRID_AGGREGATION_ROOT_FOOTER_ROW_ID = 'auto-generated-group-footer-root';\n\nconst getAggregationFooterRowIdFromGroupId = groupId => {\n  if (groupId == null) {\n    return GRID_AGGREGATION_ROOT_FOOTER_ROW_ID;\n  }\n\n  return `auto-generated-group-footer-${groupId}`;\n};\n\nexports.getAggregationFooterRowIdFromGroupId = getAggregationFooterRowIdFromGroupId;\n\nconst canColumnHaveAggregationFunction = _ref => {\n  let {\n    colDef,\n    aggregationFunctionName,\n    aggregationFunction\n  } = _ref;\n\n  if (!colDef) {\n    return false;\n  }\n\n  if (!aggregationFunction) {\n    return false;\n  }\n\n  if (colDef.availableAggregationFunctions != null) {\n    return colDef.availableAggregationFunctions.includes(aggregationFunctionName);\n  }\n\n  if (!aggregationFunction.columnTypes) {\n    return true;\n  }\n\n  return aggregationFunction.columnTypes.includes(colDef.type);\n};\n\nexports.canColumnHaveAggregationFunction = canColumnHaveAggregationFunction;\n\nconst getAvailableAggregationFunctions = _ref2 => {\n  let {\n    aggregationFunctions,\n    colDef\n  } = _ref2;\n  return Object.keys(aggregationFunctions).filter(aggregationFunctionName => canColumnHaveAggregationFunction({\n    colDef,\n    aggregationFunctionName,\n    aggregationFunction: aggregationFunctions[aggregationFunctionName]\n  }));\n};\n\nexports.getAvailableAggregationFunctions = getAvailableAggregationFunctions;\n\nconst mergeStateWithAggregationModel = aggregationModel => state => (0, _extends2.default)({}, state, {\n  aggregation: (0, _extends2.default)({}, state.aggregation, {\n    model: aggregationModel\n  })\n});\n\nexports.mergeStateWithAggregationModel = mergeStateWithAggregationModel;\n\nconst getAggregationRules = _ref3 => {\n  let {\n    columnsLookup,\n    aggregationModel,\n    aggregationFunctions\n  } = _ref3;\n  const aggregationRules = {};\n  Object.entries(aggregationModel).forEach(_ref4 => {\n    let [field, columnItem] = _ref4;\n\n    if (columnsLookup[field] && canColumnHaveAggregationFunction({\n      colDef: columnsLookup[field],\n      aggregationFunctionName: columnItem,\n      aggregationFunction: aggregationFunctions[columnItem]\n    })) {\n      aggregationRules[field] = {\n        aggregationFunctionName: columnItem,\n        aggregationFunction: aggregationFunctions[columnItem]\n      };\n    }\n  });\n  return aggregationRules;\n};\n\nexports.getAggregationRules = getAggregationRules;\n/**\n * Add a footer for each group that has at least one column with an aggregated value.\n */\n\nconst addFooterRows = _ref5 => {\n  let {\n    groupingParams,\n    apiRef,\n    getAggregationPosition,\n    hasAggregationRule\n  } = _ref5;\n  let newGroupingParams = (0, _extends2.default)({}, groupingParams, {\n    tree: (0, _extends2.default)({}, groupingParams.tree),\n    treeDepths: (0, _extends2.default)({}, groupingParams.treeDepths)\n  });\n\n  const updateChildGroupFooter = groupNode => {\n    const shouldHaveFooter = hasAggregationRule && getAggregationPosition(groupNode) === 'footer';\n\n    if (shouldHaveFooter) {\n      const footerId = getAggregationFooterRowIdFromGroupId(groupNode.id);\n\n      if (groupNode.footerId !== footerId) {\n        if (groupNode.footerId != null) {\n          (0, _internals2.removeNodeFromTree)({\n            node: newGroupingParams.tree[groupNode.footerId],\n            tree: newGroupingParams.tree,\n            treeDepths: newGroupingParams.treeDepths\n          });\n        }\n\n        const footerNode = {\n          id: footerId,\n          parent: groupNode.id,\n          depth: groupNode ? groupNode.depth + 1 : 0,\n          type: 'footer'\n        };\n        (0, _internals2.insertNodeInTree)(footerNode, newGroupingParams.tree, newGroupingParams.treeDepths, null);\n      }\n    } else if (groupNode.footerId != null) {\n      (0, _internals2.removeNodeFromTree)({\n        node: newGroupingParams.tree[groupNode.footerId],\n        tree: newGroupingParams.tree,\n        treeDepths: newGroupingParams.treeDepths\n      });\n      newGroupingParams.tree[groupNode.id] = (0, _extends2.default)({}, newGroupingParams.tree[groupNode.id], {\n        footerId: null\n      });\n    }\n  };\n\n  const updateRootGroupFooter = groupNode => {\n    const shouldHaveFooter = hasAggregationRule && getAggregationPosition(groupNode) === 'footer';\n\n    if (shouldHaveFooter) {\n      const rowId = getAggregationFooterRowIdFromGroupId(null);\n      newGroupingParams = (0, _internals2.addPinnedRow)({\n        groupingParams: newGroupingParams,\n        rowModel: {\n          [_internals.GRID_ID_AUTOGENERATED]: rowId\n        },\n        rowId,\n        position: 'bottom',\n        apiRef,\n        isAutoGenerated: true\n      });\n    }\n  };\n\n  const updateGroupFooter = groupNode => {\n    if (groupNode.id === _xDataGridPro.GRID_ROOT_GROUP_ID) {\n      updateRootGroupFooter(groupNode);\n    } else {\n      updateChildGroupFooter(groupNode);\n    }\n\n    groupNode.children.forEach(childId => {\n      const childNode = newGroupingParams.tree[childId];\n\n      if (childNode.type === 'group') {\n        updateGroupFooter(childNode);\n      }\n    });\n  };\n\n  updateGroupFooter(newGroupingParams.tree[_xDataGridPro.GRID_ROOT_GROUP_ID]);\n  return newGroupingParams;\n};\n/**\n * Compares two sets of aggregation rules to determine if they are equal or not.\n */\n\n\nexports.addFooterRows = addFooterRows;\n\nconst areAggregationRulesEqual = (previousValue, newValue) => {\n  const previousFields = Object.keys(previousValue ?? {});\n  const newFields = Object.keys(newValue);\n\n  if (!(0, _internals2.isDeepEqual)(previousFields, newFields)) {\n    return false;\n  }\n\n  return newFields.every(field => {\n    const previousRule = previousValue?.[field];\n    const newRule = newValue[field];\n\n    if (previousRule?.aggregationFunction !== newRule?.aggregationFunction) {\n      return false;\n    }\n\n    if (previousRule?.aggregationFunctionName !== newRule?.aggregationFunctionName) {\n      return false;\n    }\n\n    return true;\n  });\n};\n\nexports.areAggregationRulesEqual = areAggregationRulesEqual;\n\nconst getAggregationFunctionLabel = _ref6 => {\n  let {\n    apiRef,\n    aggregationRule\n  } = _ref6;\n\n  if (aggregationRule.aggregationFunction.label != null) {\n    return aggregationRule.aggregationFunction.label;\n  }\n\n  try {\n    return apiRef.current.getLocaleText(`aggregationFunctionLabel${(0, _utils.unstable_capitalize)(aggregationRule.aggregationFunctionName)}`);\n  } catch (e) {\n    return aggregationRule.aggregationFunctionName;\n  }\n};\n\nexports.getAggregationFunctionLabel = getAggregationFunctionLabel;","map":{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","mergeStateWithAggregationModel","getAvailableAggregationFunctions","getAggregationRules","getAggregationFunctionLabel","getAggregationFooterRowIdFromGroupId","canColumnHaveAggregationFunction","areAggregationRulesEqual","addFooterRows","GRID_AGGREGATION_ROOT_FOOTER_ROW_ID","_extends2","_utils","_internals","_xDataGridPro","_internals2","groupId","colDef","aggregationFunctionName","aggregationFunction","availableAggregationFunctions","includes","columnTypes","type","aggregationFunctions","keys","filter","aggregationModel","state","default","aggregation","model","columnsLookup","aggregationRules","entries","forEach","field","columnItem","groupingParams","apiRef","getAggregationPosition","hasAggregationRule","newGroupingParams","tree","treeDepths","updateChildGroupFooter","groupNode","shouldHaveFooter","footerId","id","removeNodeFromTree","node","footerNode","parent","depth","insertNodeInTree","updateRootGroupFooter","rowId","addPinnedRow","rowModel","GRID_ID_AUTOGENERATED","position","isAutoGenerated","updateGroupFooter","GRID_ROOT_GROUP_ID","children","childId","childNode","previousValue","newValue","previousFields","newFields","isDeepEqual","every","previousRule","newRule","aggregationRule","label","current","getLocaleText","unstable_capitalize","e"],"sources":["C:/Users/kb/node_modules/@mui/x-data-grid-premium/hooks/features/aggregation/gridAggregationUtils.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mergeStateWithAggregationModel = exports.getAvailableAggregationFunctions = exports.getAggregationRules = exports.getAggregationFunctionLabel = exports.getAggregationFooterRowIdFromGroupId = exports.canColumnHaveAggregationFunction = exports.areAggregationRulesEqual = exports.addFooterRows = exports.GRID_AGGREGATION_ROOT_FOOTER_ROW_ID = void 0;\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nvar _utils = require(\"@mui/utils\");\nvar _internals = require(\"@mui/x-data-grid/internals\");\nvar _xDataGridPro = require(\"@mui/x-data-grid-pro\");\nvar _internals2 = require(\"@mui/x-data-grid-pro/internals\");\nconst GRID_AGGREGATION_ROOT_FOOTER_ROW_ID = exports.GRID_AGGREGATION_ROOT_FOOTER_ROW_ID = 'auto-generated-group-footer-root';\nconst getAggregationFooterRowIdFromGroupId = groupId => {\n  if (groupId == null) {\n    return GRID_AGGREGATION_ROOT_FOOTER_ROW_ID;\n  }\n  return `auto-generated-group-footer-${groupId}`;\n};\nexports.getAggregationFooterRowIdFromGroupId = getAggregationFooterRowIdFromGroupId;\nconst canColumnHaveAggregationFunction = ({\n  colDef,\n  aggregationFunctionName,\n  aggregationFunction\n}) => {\n  if (!colDef) {\n    return false;\n  }\n  if (!aggregationFunction) {\n    return false;\n  }\n  if (colDef.availableAggregationFunctions != null) {\n    return colDef.availableAggregationFunctions.includes(aggregationFunctionName);\n  }\n  if (!aggregationFunction.columnTypes) {\n    return true;\n  }\n  return aggregationFunction.columnTypes.includes(colDef.type);\n};\nexports.canColumnHaveAggregationFunction = canColumnHaveAggregationFunction;\nconst getAvailableAggregationFunctions = ({\n  aggregationFunctions,\n  colDef\n}) => Object.keys(aggregationFunctions).filter(aggregationFunctionName => canColumnHaveAggregationFunction({\n  colDef,\n  aggregationFunctionName,\n  aggregationFunction: aggregationFunctions[aggregationFunctionName]\n}));\nexports.getAvailableAggregationFunctions = getAvailableAggregationFunctions;\nconst mergeStateWithAggregationModel = aggregationModel => state => (0, _extends2.default)({}, state, {\n  aggregation: (0, _extends2.default)({}, state.aggregation, {\n    model: aggregationModel\n  })\n});\nexports.mergeStateWithAggregationModel = mergeStateWithAggregationModel;\nconst getAggregationRules = ({\n  columnsLookup,\n  aggregationModel,\n  aggregationFunctions\n}) => {\n  const aggregationRules = {};\n  Object.entries(aggregationModel).forEach(([field, columnItem]) => {\n    if (columnsLookup[field] && canColumnHaveAggregationFunction({\n      colDef: columnsLookup[field],\n      aggregationFunctionName: columnItem,\n      aggregationFunction: aggregationFunctions[columnItem]\n    })) {\n      aggregationRules[field] = {\n        aggregationFunctionName: columnItem,\n        aggregationFunction: aggregationFunctions[columnItem]\n      };\n    }\n  });\n  return aggregationRules;\n};\nexports.getAggregationRules = getAggregationRules;\n/**\n * Add a footer for each group that has at least one column with an aggregated value.\n */\nconst addFooterRows = ({\n  groupingParams,\n  apiRef,\n  getAggregationPosition,\n  hasAggregationRule\n}) => {\n  let newGroupingParams = (0, _extends2.default)({}, groupingParams, {\n    tree: (0, _extends2.default)({}, groupingParams.tree),\n    treeDepths: (0, _extends2.default)({}, groupingParams.treeDepths)\n  });\n  const updateChildGroupFooter = groupNode => {\n    const shouldHaveFooter = hasAggregationRule && getAggregationPosition(groupNode) === 'footer';\n    if (shouldHaveFooter) {\n      const footerId = getAggregationFooterRowIdFromGroupId(groupNode.id);\n      if (groupNode.footerId !== footerId) {\n        if (groupNode.footerId != null) {\n          (0, _internals2.removeNodeFromTree)({\n            node: newGroupingParams.tree[groupNode.footerId],\n            tree: newGroupingParams.tree,\n            treeDepths: newGroupingParams.treeDepths\n          });\n        }\n        const footerNode = {\n          id: footerId,\n          parent: groupNode.id,\n          depth: groupNode ? groupNode.depth + 1 : 0,\n          type: 'footer'\n        };\n        (0, _internals2.insertNodeInTree)(footerNode, newGroupingParams.tree, newGroupingParams.treeDepths, null);\n      }\n    } else if (groupNode.footerId != null) {\n      (0, _internals2.removeNodeFromTree)({\n        node: newGroupingParams.tree[groupNode.footerId],\n        tree: newGroupingParams.tree,\n        treeDepths: newGroupingParams.treeDepths\n      });\n      newGroupingParams.tree[groupNode.id] = (0, _extends2.default)({}, newGroupingParams.tree[groupNode.id], {\n        footerId: null\n      });\n    }\n  };\n  const updateRootGroupFooter = groupNode => {\n    const shouldHaveFooter = hasAggregationRule && getAggregationPosition(groupNode) === 'footer';\n    if (shouldHaveFooter) {\n      const rowId = getAggregationFooterRowIdFromGroupId(null);\n      newGroupingParams = (0, _internals2.addPinnedRow)({\n        groupingParams: newGroupingParams,\n        rowModel: {\n          [_internals.GRID_ID_AUTOGENERATED]: rowId\n        },\n        rowId,\n        position: 'bottom',\n        apiRef,\n        isAutoGenerated: true\n      });\n    }\n  };\n  const updateGroupFooter = groupNode => {\n    if (groupNode.id === _xDataGridPro.GRID_ROOT_GROUP_ID) {\n      updateRootGroupFooter(groupNode);\n    } else {\n      updateChildGroupFooter(groupNode);\n    }\n    groupNode.children.forEach(childId => {\n      const childNode = newGroupingParams.tree[childId];\n      if (childNode.type === 'group') {\n        updateGroupFooter(childNode);\n      }\n    });\n  };\n  updateGroupFooter(newGroupingParams.tree[_xDataGridPro.GRID_ROOT_GROUP_ID]);\n  return newGroupingParams;\n};\n\n/**\n * Compares two sets of aggregation rules to determine if they are equal or not.\n */\nexports.addFooterRows = addFooterRows;\nconst areAggregationRulesEqual = (previousValue, newValue) => {\n  const previousFields = Object.keys(previousValue ?? {});\n  const newFields = Object.keys(newValue);\n  if (!(0, _internals2.isDeepEqual)(previousFields, newFields)) {\n    return false;\n  }\n  return newFields.every(field => {\n    const previousRule = previousValue?.[field];\n    const newRule = newValue[field];\n    if (previousRule?.aggregationFunction !== newRule?.aggregationFunction) {\n      return false;\n    }\n    if (previousRule?.aggregationFunctionName !== newRule?.aggregationFunctionName) {\n      return false;\n    }\n    return true;\n  });\n};\nexports.areAggregationRulesEqual = areAggregationRulesEqual;\nconst getAggregationFunctionLabel = ({\n  apiRef,\n  aggregationRule\n}) => {\n  if (aggregationRule.aggregationFunction.label != null) {\n    return aggregationRule.aggregationFunction.label;\n  }\n  try {\n    return apiRef.current.getLocaleText(`aggregationFunctionLabel${(0, _utils.unstable_capitalize)(aggregationRule.aggregationFunctionName)}`);\n  } catch (e) {\n    return aggregationRule.aggregationFunctionName;\n  }\n};\nexports.getAggregationFunctionLabel = getAggregationFunctionLabel;"],"mappings":"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"},"metadata":{},"sourceType":"script"}