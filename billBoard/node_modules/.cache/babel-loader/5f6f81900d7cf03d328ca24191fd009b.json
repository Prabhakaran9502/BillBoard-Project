{"ast":null,"code":"import { base64Decode, base64Encode } from '../encoding/base64';\nimport { md5 } from '../encoding/md5';\nimport { LICENSE_STATUS } from '../utils/licenseStatus';\nimport { LICENSE_SCOPES } from '../utils/licenseScope';\nimport { LICENSING_MODELS } from '../utils/licensingModel';\n\nconst getDefaultReleaseDate = () => {\n  const today = new Date();\n  today.setHours(0, 0, 0, 0);\n  return today;\n};\n\nexport function generateReleaseInfo() {\n  let releaseDate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getDefaultReleaseDate();\n  return base64Encode(releaseDate.getTime().toString());\n}\n\nfunction isLicenseScopeSufficient(packageName, licenseScope) {\n  let acceptedScopes;\n\n  if (packageName.includes('-pro')) {\n    acceptedScopes = ['pro', 'premium'];\n  } else if (packageName.includes('-premium')) {\n    acceptedScopes = ['premium'];\n  } else {\n    acceptedScopes = [];\n  }\n\n  return acceptedScopes.includes(licenseScope);\n}\n\nconst expiryReg = /^.*EXPIRY=([0-9]+),.*$/;\nconst PRO_PACKAGES_AVAILABLE_IN_INITIAL_PRO_PLAN = ['x-data-grid-pro', 'x-date-pickers-pro'];\n/**\n * Format: ORDER:${orderNumber},EXPIRY=${expiryTimestamp},KEYVERSION=1\n */\n\nconst decodeLicenseVersion1 = license => {\n  let expiryTimestamp;\n\n  try {\n    expiryTimestamp = parseInt(license.match(expiryReg)[1], 10);\n\n    if (!expiryTimestamp || Number.isNaN(expiryTimestamp)) {\n      expiryTimestamp = null;\n    }\n  } catch (err) {\n    expiryTimestamp = null;\n  }\n\n  return {\n    scope: 'pro',\n    licensingModel: 'perpetual',\n    expiryTimestamp,\n    planVersion: 'initial'\n  };\n};\n/**\n * Format: O=${orderNumber},E=${expiryTimestamp},S=${scope},LM=${licensingModel},PV=${planVersion},KV=2`;\n */\n\n\nconst decodeLicenseVersion2 = license => {\n  const licenseInfo = {\n    scope: null,\n    licensingModel: null,\n    expiryTimestamp: null,\n    planVersion: 'initial'\n  };\n  license.split(',').map(token => token.split('=')).filter(el => el.length === 2).forEach(_ref => {\n    let [key, value] = _ref;\n\n    if (key === 'S') {\n      licenseInfo.scope = value;\n    }\n\n    if (key === 'LM') {\n      licenseInfo.licensingModel = value;\n    }\n\n    if (key === 'E') {\n      const expiryTimestamp = parseInt(value, 10);\n\n      if (expiryTimestamp && !Number.isNaN(expiryTimestamp)) {\n        licenseInfo.expiryTimestamp = expiryTimestamp;\n      }\n    }\n\n    if (key === 'PV') {\n      licenseInfo.planVersion = value;\n    }\n  });\n  return licenseInfo;\n};\n/**\n * Decode the license based on its key version and return a version-agnostic `MuiLicense` object.\n */\n\n\nconst decodeLicense = encodedLicense => {\n  const license = base64Decode(encodedLicense);\n\n  if (license.includes('KEYVERSION=1')) {\n    return decodeLicenseVersion1(license);\n  }\n\n  if (license.includes('KV=2')) {\n    return decodeLicenseVersion2(license);\n  }\n\n  return null;\n};\n\nexport function verifyLicense(_ref2) {\n  let {\n    releaseInfo,\n    licenseKey,\n    packageName\n  } = _ref2;\n\n  if (!releaseInfo) {\n    throw new Error('MUI X: The release information is missing. Not able to validate license.');\n  }\n\n  if (!licenseKey) {\n    return {\n      status: LICENSE_STATUS.NotFound\n    };\n  }\n\n  const hash = licenseKey.substr(0, 32);\n  const encoded = licenseKey.substr(32);\n\n  if (hash !== md5(encoded)) {\n    return {\n      status: LICENSE_STATUS.Invalid\n    };\n  }\n\n  const license = decodeLicense(encoded);\n\n  if (license == null) {\n    console.error('MUI X: Error checking license. Key version not found!');\n    return {\n      status: LICENSE_STATUS.Invalid\n    };\n  }\n\n  if (license.licensingModel == null || !LICENSING_MODELS.includes(license.licensingModel)) {\n    console.error('MUI X: Error checking license. Licensing model not found or invalid!');\n    return {\n      status: LICENSE_STATUS.Invalid\n    };\n  }\n\n  if (license.expiryTimestamp == null) {\n    console.error('MUI X: Error checking license. Expiry timestamp not found or invalid!');\n    return {\n      status: LICENSE_STATUS.Invalid\n    };\n  }\n\n  if (license.licensingModel === 'perpetual' || process.env.NODE_ENV === 'production') {\n    const pkgTimestamp = parseInt(base64Decode(releaseInfo), 10);\n\n    if (Number.isNaN(pkgTimestamp)) {\n      throw new Error('MUI X: The release information is invalid. Not able to validate license.');\n    }\n\n    if (license.expiryTimestamp < pkgTimestamp) {\n      return {\n        status: LICENSE_STATUS.ExpiredVersion\n      };\n    }\n  } else if (license.licensingModel === 'subscription' || license.licensingModel === 'annual') {\n    if (new Date().getTime() > license.expiryTimestamp) {\n      if ( // 30 days grace\n      new Date().getTime() < license.expiryTimestamp + 1000 * 3600 * 24 * 30 || process.env.NODE_ENV !== 'development') {\n        return {\n          status: LICENSE_STATUS.ExpiredAnnualGrace,\n          meta: {\n            expiryTimestamp: license.expiryTimestamp,\n            licenseKey\n          }\n        };\n      }\n\n      return {\n        status: LICENSE_STATUS.ExpiredAnnual,\n        meta: {\n          expiryTimestamp: license.expiryTimestamp,\n          licenseKey\n        }\n      };\n    }\n  }\n\n  if (license.scope == null || !LICENSE_SCOPES.includes(license.scope)) {\n    console.error('MUI X: Error checking license. scope not found or invalid!');\n    return {\n      status: LICENSE_STATUS.Invalid\n    };\n  }\n\n  if (!isLicenseScopeSufficient(packageName, license.scope)) {\n    return {\n      status: LICENSE_STATUS.OutOfScope\n    };\n  } // 'charts-pro' or 'tree-view-pro' can only be used with a newer Pro license\n\n\n  if (license.planVersion === 'initial' && license.scope === 'pro' && !PRO_PACKAGES_AVAILABLE_IN_INITIAL_PRO_PLAN.includes(packageName)) {\n    return {\n      status: LICENSE_STATUS.NotAvailableInInitialProPlan\n    };\n  }\n\n  return {\n    status: LICENSE_STATUS.Valid\n  };\n}","map":{"version":3,"names":["base64Decode","base64Encode","md5","LICENSE_STATUS","LICENSE_SCOPES","LICENSING_MODELS","getDefaultReleaseDate","today","Date","setHours","generateReleaseInfo","releaseDate","getTime","toString","isLicenseScopeSufficient","packageName","licenseScope","acceptedScopes","includes","expiryReg","PRO_PACKAGES_AVAILABLE_IN_INITIAL_PRO_PLAN","decodeLicenseVersion1","license","expiryTimestamp","parseInt","match","Number","isNaN","err","scope","licensingModel","planVersion","decodeLicenseVersion2","licenseInfo","split","map","token","filter","el","length","forEach","key","value","decodeLicense","encodedLicense","verifyLicense","releaseInfo","licenseKey","Error","status","NotFound","hash","substr","encoded","Invalid","console","error","process","env","NODE_ENV","pkgTimestamp","ExpiredVersion","ExpiredAnnualGrace","meta","ExpiredAnnual","OutOfScope","NotAvailableInInitialProPlan","Valid"],"sources":["C:/Users/kb/Downloads/billBoard/billboard/node_modules/@mui/x-date-pickers-pro/node_modules/@mui/x-license/verifyLicense/verifyLicense.js"],"sourcesContent":["import { base64Decode, base64Encode } from '../encoding/base64';\nimport { md5 } from '../encoding/md5';\nimport { LICENSE_STATUS } from '../utils/licenseStatus';\nimport { LICENSE_SCOPES } from '../utils/licenseScope';\nimport { LICENSING_MODELS } from '../utils/licensingModel';\nconst getDefaultReleaseDate = () => {\n  const today = new Date();\n  today.setHours(0, 0, 0, 0);\n  return today;\n};\nexport function generateReleaseInfo(releaseDate = getDefaultReleaseDate()) {\n  return base64Encode(releaseDate.getTime().toString());\n}\nfunction isLicenseScopeSufficient(packageName, licenseScope) {\n  let acceptedScopes;\n  if (packageName.includes('-pro')) {\n    acceptedScopes = ['pro', 'premium'];\n  } else if (packageName.includes('-premium')) {\n    acceptedScopes = ['premium'];\n  } else {\n    acceptedScopes = [];\n  }\n  return acceptedScopes.includes(licenseScope);\n}\nconst expiryReg = /^.*EXPIRY=([0-9]+),.*$/;\nconst PRO_PACKAGES_AVAILABLE_IN_INITIAL_PRO_PLAN = ['x-data-grid-pro', 'x-date-pickers-pro'];\n\n/**\n * Format: ORDER:${orderNumber},EXPIRY=${expiryTimestamp},KEYVERSION=1\n */\nconst decodeLicenseVersion1 = license => {\n  let expiryTimestamp;\n  try {\n    expiryTimestamp = parseInt(license.match(expiryReg)[1], 10);\n    if (!expiryTimestamp || Number.isNaN(expiryTimestamp)) {\n      expiryTimestamp = null;\n    }\n  } catch (err) {\n    expiryTimestamp = null;\n  }\n  return {\n    scope: 'pro',\n    licensingModel: 'perpetual',\n    expiryTimestamp,\n    planVersion: 'initial'\n  };\n};\n\n/**\n * Format: O=${orderNumber},E=${expiryTimestamp},S=${scope},LM=${licensingModel},PV=${planVersion},KV=2`;\n */\nconst decodeLicenseVersion2 = license => {\n  const licenseInfo = {\n    scope: null,\n    licensingModel: null,\n    expiryTimestamp: null,\n    planVersion: 'initial'\n  };\n  license.split(',').map(token => token.split('=')).filter(el => el.length === 2).forEach(([key, value]) => {\n    if (key === 'S') {\n      licenseInfo.scope = value;\n    }\n    if (key === 'LM') {\n      licenseInfo.licensingModel = value;\n    }\n    if (key === 'E') {\n      const expiryTimestamp = parseInt(value, 10);\n      if (expiryTimestamp && !Number.isNaN(expiryTimestamp)) {\n        licenseInfo.expiryTimestamp = expiryTimestamp;\n      }\n    }\n    if (key === 'PV') {\n      licenseInfo.planVersion = value;\n    }\n  });\n  return licenseInfo;\n};\n\n/**\n * Decode the license based on its key version and return a version-agnostic `MuiLicense` object.\n */\nconst decodeLicense = encodedLicense => {\n  const license = base64Decode(encodedLicense);\n  if (license.includes('KEYVERSION=1')) {\n    return decodeLicenseVersion1(license);\n  }\n  if (license.includes('KV=2')) {\n    return decodeLicenseVersion2(license);\n  }\n  return null;\n};\nexport function verifyLicense({\n  releaseInfo,\n  licenseKey,\n  packageName\n}) {\n  if (!releaseInfo) {\n    throw new Error('MUI X: The release information is missing. Not able to validate license.');\n  }\n  if (!licenseKey) {\n    return {\n      status: LICENSE_STATUS.NotFound\n    };\n  }\n  const hash = licenseKey.substr(0, 32);\n  const encoded = licenseKey.substr(32);\n  if (hash !== md5(encoded)) {\n    return {\n      status: LICENSE_STATUS.Invalid\n    };\n  }\n  const license = decodeLicense(encoded);\n  if (license == null) {\n    console.error('MUI X: Error checking license. Key version not found!');\n    return {\n      status: LICENSE_STATUS.Invalid\n    };\n  }\n  if (license.licensingModel == null || !LICENSING_MODELS.includes(license.licensingModel)) {\n    console.error('MUI X: Error checking license. Licensing model not found or invalid!');\n    return {\n      status: LICENSE_STATUS.Invalid\n    };\n  }\n  if (license.expiryTimestamp == null) {\n    console.error('MUI X: Error checking license. Expiry timestamp not found or invalid!');\n    return {\n      status: LICENSE_STATUS.Invalid\n    };\n  }\n  if (license.licensingModel === 'perpetual' || process.env.NODE_ENV === 'production') {\n    const pkgTimestamp = parseInt(base64Decode(releaseInfo), 10);\n    if (Number.isNaN(pkgTimestamp)) {\n      throw new Error('MUI X: The release information is invalid. Not able to validate license.');\n    }\n    if (license.expiryTimestamp < pkgTimestamp) {\n      return {\n        status: LICENSE_STATUS.ExpiredVersion\n      };\n    }\n  } else if (license.licensingModel === 'subscription' || license.licensingModel === 'annual') {\n    if (new Date().getTime() > license.expiryTimestamp) {\n      if (\n      // 30 days grace\n      new Date().getTime() < license.expiryTimestamp + 1000 * 3600 * 24 * 30 || process.env.NODE_ENV !== 'development') {\n        return {\n          status: LICENSE_STATUS.ExpiredAnnualGrace,\n          meta: {\n            expiryTimestamp: license.expiryTimestamp,\n            licenseKey\n          }\n        };\n      }\n      return {\n        status: LICENSE_STATUS.ExpiredAnnual,\n        meta: {\n          expiryTimestamp: license.expiryTimestamp,\n          licenseKey\n        }\n      };\n    }\n  }\n  if (license.scope == null || !LICENSE_SCOPES.includes(license.scope)) {\n    console.error('MUI X: Error checking license. scope not found or invalid!');\n    return {\n      status: LICENSE_STATUS.Invalid\n    };\n  }\n  if (!isLicenseScopeSufficient(packageName, license.scope)) {\n    return {\n      status: LICENSE_STATUS.OutOfScope\n    };\n  }\n\n  // 'charts-pro' or 'tree-view-pro' can only be used with a newer Pro license\n  if (license.planVersion === 'initial' && license.scope === 'pro' && !PRO_PACKAGES_AVAILABLE_IN_INITIAL_PRO_PLAN.includes(packageName)) {\n    return {\n      status: LICENSE_STATUS.NotAvailableInInitialProPlan\n    };\n  }\n  return {\n    status: LICENSE_STATUS.Valid\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}