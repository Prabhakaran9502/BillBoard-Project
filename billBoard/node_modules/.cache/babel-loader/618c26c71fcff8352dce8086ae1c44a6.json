{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridRegisterPipeProcessor } from '@mui/x-data-grid/internals';\nimport { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid';\nimport { insertNodeInTree } from '../../../utils/tree/utils';\nexport function addPinnedRow(_ref) {\n  let {\n    groupingParams,\n    rowModel,\n    rowId,\n    position,\n    apiRef,\n    isAutoGenerated\n  } = _ref;\n\n  const dataRowIdToModelLookup = _extends({}, groupingParams.dataRowIdToModelLookup);\n\n  const dataRowIdToIdLookup = _extends({}, groupingParams.dataRowIdToIdLookup);\n\n  const tree = _extends({}, groupingParams.tree);\n\n  const treeDepths = _extends({}, groupingParams.treeDepths); // TODO: warn if id is already present in `props.rows`\n\n\n  const node = {\n    type: 'pinnedRow',\n    id: rowId,\n    depth: 0,\n    parent: GRID_ROOT_GROUP_ID,\n    isAutoGenerated\n  };\n  insertNodeInTree(node, tree, treeDepths, null);\n\n  if (!isAutoGenerated) {\n    dataRowIdToModelLookup[rowId] = rowModel;\n    dataRowIdToIdLookup[rowId] = rowId;\n  } // Do not push it to ids list so that pagination is not affected by pinned rows\n\n\n  apiRef.current.caches.rows.dataRowIdToModelLookup[rowId] = _extends({}, rowModel);\n  apiRef.current.caches.rows.dataRowIdToIdLookup[rowId] = rowId;\n  const previousPinnedRows = groupingParams.additionalRowGroups?.pinnedRows || {};\n  const newPinnedRow = {\n    id: rowId,\n    model: rowModel\n  };\n\n  if (groupingParams.additionalRowGroups?.pinnedRows?.[position]?.includes(newPinnedRow)) {\n    return _extends({}, groupingParams, {\n      dataRowIdToModelLookup,\n      dataRowIdToIdLookup,\n      tree,\n      treeDepths\n    });\n  }\n\n  return _extends({}, groupingParams, {\n    dataRowIdToModelLookup,\n    dataRowIdToIdLookup,\n    tree,\n    treeDepths,\n    additionalRowGroups: _extends({}, groupingParams.additionalRowGroups, {\n      pinnedRows: _extends({}, previousPinnedRows, {\n        [position]: [...(previousPinnedRows[position] || []), newPinnedRow]\n      })\n    })\n  });\n}\nexport const useGridRowPinningPreProcessors = apiRef => {\n  const addPinnedRows = React.useCallback(groupingParams => {\n    const pinnedRowsCache = apiRef.current.caches.pinnedRows || {};\n\n    let newGroupingParams = _extends({}, groupingParams, {\n      additionalRowGroups: _extends({}, groupingParams.additionalRowGroups, {\n        // reset pinned rows state\n        pinnedRows: {}\n      })\n    });\n\n    pinnedRowsCache.topIds?.forEach(rowId => {\n      newGroupingParams = addPinnedRow({\n        groupingParams: newGroupingParams,\n        rowModel: pinnedRowsCache.idLookup[rowId],\n        rowId,\n        position: 'top',\n        apiRef,\n        isAutoGenerated: false\n      });\n    });\n    pinnedRowsCache.bottomIds?.forEach(rowId => {\n      newGroupingParams = addPinnedRow({\n        groupingParams: newGroupingParams,\n        rowModel: pinnedRowsCache.idLookup[rowId],\n        rowId,\n        position: 'bottom',\n        apiRef,\n        isAutoGenerated: false\n      });\n    }); // If row with the same `id` is present both in `rows` and `pinnedRows` - remove it from the root group children\n\n    if (pinnedRowsCache.bottomIds?.length || pinnedRowsCache.topIds?.length) {\n      const shouldKeepRow = rowId => {\n        if (newGroupingParams.tree[rowId] && newGroupingParams.tree[rowId].type === 'pinnedRow') {\n          return false;\n        }\n\n        return true;\n      };\n\n      const rootGroupNode = newGroupingParams.tree[GRID_ROOT_GROUP_ID];\n      newGroupingParams.tree[GRID_ROOT_GROUP_ID] = _extends({}, rootGroupNode, {\n        children: rootGroupNode.children.filter(shouldKeepRow)\n      });\n      newGroupingParams.dataRowIds = newGroupingParams.dataRowIds.filter(shouldKeepRow);\n    }\n\n    return newGroupingParams;\n  }, [apiRef]);\n  useGridRegisterPipeProcessor(apiRef, 'hydrateRows', addPinnedRows);\n};","map":{"version":3,"names":["_extends","React","useGridRegisterPipeProcessor","GRID_ROOT_GROUP_ID","insertNodeInTree","addPinnedRow","groupingParams","rowModel","rowId","position","apiRef","isAutoGenerated","dataRowIdToModelLookup","dataRowIdToIdLookup","tree","treeDepths","node","type","id","depth","parent","current","caches","rows","previousPinnedRows","additionalRowGroups","pinnedRows","newPinnedRow","model","includes","useGridRowPinningPreProcessors","addPinnedRows","useCallback","pinnedRowsCache","newGroupingParams","topIds","forEach","idLookup","bottomIds","length","shouldKeepRow","rootGroupNode","children","filter","dataRowIds"],"sources":["C:/Users/kb/Downloads/billBoard/billboard/node_modules/@mui/x-data-grid-pro/esm/hooks/features/rowPinning/useGridRowPinningPreProcessors.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridRegisterPipeProcessor } from '@mui/x-data-grid/internals';\nimport { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid';\nimport { insertNodeInTree } from '../../../utils/tree/utils';\nexport function addPinnedRow({\n  groupingParams,\n  rowModel,\n  rowId,\n  position,\n  apiRef,\n  isAutoGenerated\n}) {\n  const dataRowIdToModelLookup = _extends({}, groupingParams.dataRowIdToModelLookup);\n  const dataRowIdToIdLookup = _extends({}, groupingParams.dataRowIdToIdLookup);\n  const tree = _extends({}, groupingParams.tree);\n  const treeDepths = _extends({}, groupingParams.treeDepths);\n\n  // TODO: warn if id is already present in `props.rows`\n\n  const node = {\n    type: 'pinnedRow',\n    id: rowId,\n    depth: 0,\n    parent: GRID_ROOT_GROUP_ID,\n    isAutoGenerated\n  };\n  insertNodeInTree(node, tree, treeDepths, null);\n  if (!isAutoGenerated) {\n    dataRowIdToModelLookup[rowId] = rowModel;\n    dataRowIdToIdLookup[rowId] = rowId;\n  }\n  // Do not push it to ids list so that pagination is not affected by pinned rows\n\n  apiRef.current.caches.rows.dataRowIdToModelLookup[rowId] = _extends({}, rowModel);\n  apiRef.current.caches.rows.dataRowIdToIdLookup[rowId] = rowId;\n  const previousPinnedRows = groupingParams.additionalRowGroups?.pinnedRows || {};\n  const newPinnedRow = {\n    id: rowId,\n    model: rowModel\n  };\n  if (groupingParams.additionalRowGroups?.pinnedRows?.[position]?.includes(newPinnedRow)) {\n    return _extends({}, groupingParams, {\n      dataRowIdToModelLookup,\n      dataRowIdToIdLookup,\n      tree,\n      treeDepths\n    });\n  }\n  return _extends({}, groupingParams, {\n    dataRowIdToModelLookup,\n    dataRowIdToIdLookup,\n    tree,\n    treeDepths,\n    additionalRowGroups: _extends({}, groupingParams.additionalRowGroups, {\n      pinnedRows: _extends({}, previousPinnedRows, {\n        [position]: [...(previousPinnedRows[position] || []), newPinnedRow]\n      })\n    })\n  });\n}\nexport const useGridRowPinningPreProcessors = apiRef => {\n  const addPinnedRows = React.useCallback(groupingParams => {\n    const pinnedRowsCache = apiRef.current.caches.pinnedRows || {};\n    let newGroupingParams = _extends({}, groupingParams, {\n      additionalRowGroups: _extends({}, groupingParams.additionalRowGroups, {\n        // reset pinned rows state\n        pinnedRows: {}\n      })\n    });\n    pinnedRowsCache.topIds?.forEach(rowId => {\n      newGroupingParams = addPinnedRow({\n        groupingParams: newGroupingParams,\n        rowModel: pinnedRowsCache.idLookup[rowId],\n        rowId,\n        position: 'top',\n        apiRef,\n        isAutoGenerated: false\n      });\n    });\n    pinnedRowsCache.bottomIds?.forEach(rowId => {\n      newGroupingParams = addPinnedRow({\n        groupingParams: newGroupingParams,\n        rowModel: pinnedRowsCache.idLookup[rowId],\n        rowId,\n        position: 'bottom',\n        apiRef,\n        isAutoGenerated: false\n      });\n    });\n\n    // If row with the same `id` is present both in `rows` and `pinnedRows` - remove it from the root group children\n    if (pinnedRowsCache.bottomIds?.length || pinnedRowsCache.topIds?.length) {\n      const shouldKeepRow = rowId => {\n        if (newGroupingParams.tree[rowId] && newGroupingParams.tree[rowId].type === 'pinnedRow') {\n          return false;\n        }\n        return true;\n      };\n      const rootGroupNode = newGroupingParams.tree[GRID_ROOT_GROUP_ID];\n      newGroupingParams.tree[GRID_ROOT_GROUP_ID] = _extends({}, rootGroupNode, {\n        children: rootGroupNode.children.filter(shouldKeepRow)\n      });\n      newGroupingParams.dataRowIds = newGroupingParams.dataRowIds.filter(shouldKeepRow);\n    }\n    return newGroupingParams;\n  }, [apiRef]);\n  useGridRegisterPipeProcessor(apiRef, 'hydrateRows', addPinnedRows);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}