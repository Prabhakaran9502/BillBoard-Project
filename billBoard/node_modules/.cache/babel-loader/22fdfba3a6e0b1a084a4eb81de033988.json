{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.wrapColumnWithAggregationValue = exports.unwrapColumnFromAggregation = void 0;\n\nvar _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutPropertiesLoose\"));\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _gridAggregationSelectors = require(\"./gridAggregationSelectors\");\n\nvar _GridFooterCell = require(\"../../../components/GridFooterCell\");\n\nvar _GridAggregationHeader = require(\"../../../components/GridAggregationHeader\");\n\nvar _jsxRuntime = require(\"react/jsx-runtime\");\n\nconst _excluded = [\"aggregationWrappedProperties\"];\n\nfunction _getRequireWildcardCache(e) {\n  if (\"function\" != typeof WeakMap) return null;\n  var r = new WeakMap(),\n      t = new WeakMap();\n  return (_getRequireWildcardCache = function (e) {\n    return e ? t : r;\n  })(e);\n}\n\nfunction _interopRequireWildcard(e, r) {\n  if (!r && e && e.__esModule) return e;\n  if (null === e || \"object\" != typeof e && \"function\" != typeof e) return {\n    default: e\n  };\n\n  var t = _getRequireWildcardCache(r);\n\n  if (t && t.has(e)) return t.get(e);\n  var n = {\n    __proto__: null\n  },\n      a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) {\n    var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n    i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n  }\n\n  return n.default = e, t && t.set(e, n), n;\n}\n\nconst AGGREGATION_WRAPPABLE_PROPERTIES = ['valueGetter', 'valueFormatter', 'renderCell', 'renderHeader', 'filterOperators'];\n\nconst getAggregationValueWrappedValueGetter = _ref2 => {\n  let {\n    value: valueGetter,\n    getCellAggregationResult\n  } = _ref2;\n\n  const wrappedValueGetter = (value, row, column, apiRef) => {\n    const rowId = apiRef.current.getRowId(row);\n    const cellAggregationResult = getCellAggregationResult(rowId, column.field);\n\n    if (cellAggregationResult != null) {\n      return cellAggregationResult?.value ?? null;\n    }\n\n    if (valueGetter) {\n      return valueGetter(value, row, column, apiRef);\n    }\n\n    return row[column.field];\n  };\n\n  return wrappedValueGetter;\n};\n\nconst getAggregationValueWrappedValueFormatter = _ref3 => {\n  let {\n    value: valueFormatter,\n    aggregationRule,\n    getCellAggregationResult\n  } = _ref3;\n\n  // If neither the inline aggregation function nor the footer aggregation function have a custom value formatter,\n  // Then we don't wrap the column value formatter\n  if (!aggregationRule.aggregationFunction.valueFormatter) {\n    return valueFormatter;\n  }\n\n  const wrappedValueFormatter = (value, row, column, apiRef) => {\n    const rowId = apiRef.current.getRowId(row);\n\n    if (rowId != null) {\n      const cellAggregationResult = getCellAggregationResult(rowId, column.field);\n\n      if (cellAggregationResult != null) {\n        return aggregationRule.aggregationFunction.valueFormatter?.(value, row, column, apiRef);\n      }\n    }\n\n    if (valueFormatter) {\n      return valueFormatter(value, row, column, apiRef);\n    }\n\n    return value;\n  };\n\n  return wrappedValueFormatter;\n};\n\nconst getAggregationValueWrappedRenderCell = _ref4 => {\n  let {\n    value: renderCell,\n    aggregationRule,\n    getCellAggregationResult\n  } = _ref4;\n\n  const wrappedRenderCell = params => {\n    const cellAggregationResult = getCellAggregationResult(params.id, params.field);\n\n    if (cellAggregationResult != null) {\n      if (!renderCell) {\n        if (cellAggregationResult.position === 'footer') {\n          return /*#__PURE__*/(0, _jsxRuntime.jsx)(_GridFooterCell.GridFooterCell, (0, _extends2.default)({}, params));\n        }\n\n        return params.formattedValue;\n      }\n\n      const aggregationMeta = {\n        hasCellUnit: aggregationRule.aggregationFunction.hasCellUnit ?? true,\n        aggregationFunctionName: aggregationRule.aggregationFunctionName\n      };\n      return renderCell((0, _extends2.default)({}, params, {\n        aggregation: aggregationMeta\n      }));\n    }\n\n    if (!renderCell) {\n      return params.formattedValue;\n    }\n\n    return renderCell(params);\n  };\n\n  return wrappedRenderCell;\n};\n/**\n * Skips the filtering for aggregated rows\n */\n\n\nconst getWrappedFilterOperators = _ref5 => {\n  let {\n    value: filterOperators,\n    apiRef,\n    getCellAggregationResult\n  } = _ref5;\n  return filterOperators.map(operator => {\n    const baseGetApplyFilterFn = operator.getApplyFilterFn;\n\n    const getApplyFilterFn = (filterItem, colDef) => {\n      const filterFn = baseGetApplyFilterFn(filterItem, colDef);\n\n      if (!filterFn) {\n        return null;\n      }\n\n      return (value, row, column, api) => {\n        if (getCellAggregationResult(apiRef.current.getRowId(row), column.field) != null) {\n          return true;\n        }\n\n        return filterFn(value, row, column, api);\n      };\n    };\n\n    return (0, _extends2.default)({}, operator, {\n      getApplyFilterFn\n    });\n  });\n};\n/**\n * Add the aggregation method around the header name\n */\n\n\nconst getWrappedRenderHeader = _ref6 => {\n  let {\n    value: renderHeader,\n    aggregationRule\n  } = _ref6;\n\n  const wrappedRenderHeader = params => {\n    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_GridAggregationHeader.GridAggregationHeader, (0, _extends2.default)({}, params, {\n      aggregation: {\n        aggregationRule\n      },\n      renderHeader: renderHeader\n    }));\n  };\n\n  return wrappedRenderHeader;\n};\n/**\n * Add a wrapper around each wrappable property of the column to customize the behavior of the aggregation cells.\n */\n\n\nconst wrapColumnWithAggregationValue = _ref7 => {\n  let {\n    column,\n    apiRef,\n    aggregationRule\n  } = _ref7;\n\n  const getCellAggregationResult = (id, field) => {\n    let cellAggregationPosition = null;\n    const rowNode = apiRef.current.getRowNode(id);\n\n    if (rowNode.type === 'group') {\n      cellAggregationPosition = 'inline';\n    } else if (id.toString().startsWith('auto-generated-group-footer-')) {\n      cellAggregationPosition = 'footer';\n    }\n\n    if (cellAggregationPosition == null) {\n      return null;\n    } // TODO: Add custom root id\n\n\n    const groupId = cellAggregationPosition === 'inline' ? id : rowNode.parent ?? '';\n    const aggregationResult = (0, _gridAggregationSelectors.gridAggregationLookupSelector)(apiRef)?.[groupId]?.[field];\n\n    if (!aggregationResult || aggregationResult.position !== cellAggregationPosition) {\n      return null;\n    }\n\n    return aggregationResult;\n  };\n\n  let didWrapSomeProperty = false;\n  const wrappedColumn = (0, _extends2.default)({}, column, {\n    aggregationWrappedProperties: []\n  });\n\n  const wrapColumnProperty = (property, wrapper) => {\n    const originalValue = column[property];\n    const wrappedProperty = wrapper({\n      apiRef,\n      value: originalValue,\n      colDef: column,\n      aggregationRule,\n      getCellAggregationResult\n    });\n\n    if (wrappedProperty !== originalValue) {\n      didWrapSomeProperty = true;\n      wrappedColumn[property] = wrappedProperty;\n      wrappedColumn.aggregationWrappedProperties.push({\n        name: property,\n        originalValue,\n        wrappedValue: wrappedProperty\n      });\n    }\n  };\n\n  wrapColumnProperty('valueGetter', getAggregationValueWrappedValueGetter);\n  wrapColumnProperty('valueFormatter', getAggregationValueWrappedValueFormatter);\n  wrapColumnProperty('renderCell', getAggregationValueWrappedRenderCell);\n  wrapColumnProperty('renderHeader', getWrappedRenderHeader);\n  wrapColumnProperty('filterOperators', getWrappedFilterOperators);\n\n  if (!didWrapSomeProperty) {\n    return column;\n  }\n\n  return wrappedColumn;\n};\n/**\n * Remove the aggregation wrappers around the wrappable properties of the column.\n */\n\n\nexports.wrapColumnWithAggregationValue = wrapColumnWithAggregationValue;\n\nconst unwrapColumnFromAggregation = _ref8 => {\n  let {\n    column\n  } = _ref8;\n\n  if (!column.aggregationWrappedProperties) {\n    return column;\n  }\n\n  const _ref = column,\n        {\n    aggregationWrappedProperties\n  } = _ref,\n        unwrappedColumn = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);\n  aggregationWrappedProperties.forEach(_ref9 => {\n    let {\n      name,\n      originalValue,\n      wrappedValue\n    } = _ref9;\n\n    // The value changed since we wrapped it\n    if (wrappedValue !== unwrappedColumn[name]) {\n      return;\n    }\n\n    unwrappedColumn[name] = originalValue;\n  });\n  return unwrappedColumn;\n};\n\nexports.unwrapColumnFromAggregation = unwrapColumnFromAggregation;","map":{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","wrapColumnWithAggregationValue","unwrapColumnFromAggregation","_objectWithoutPropertiesLoose2","_extends2","React","_interopRequireWildcard","_gridAggregationSelectors","_GridFooterCell","_GridAggregationHeader","_jsxRuntime","_excluded","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","AGGREGATION_WRAPPABLE_PROPERTIES","getAggregationValueWrappedValueGetter","valueGetter","getCellAggregationResult","wrappedValueGetter","row","column","apiRef","rowId","current","getRowId","cellAggregationResult","field","getAggregationValueWrappedValueFormatter","valueFormatter","aggregationRule","aggregationFunction","wrappedValueFormatter","getAggregationValueWrappedRenderCell","renderCell","wrappedRenderCell","params","id","position","jsx","GridFooterCell","formattedValue","aggregationMeta","hasCellUnit","aggregationFunctionName","aggregation","getWrappedFilterOperators","filterOperators","map","operator","baseGetApplyFilterFn","getApplyFilterFn","filterItem","colDef","filterFn","api","getWrappedRenderHeader","renderHeader","wrappedRenderHeader","GridAggregationHeader","cellAggregationPosition","rowNode","getRowNode","type","toString","startsWith","groupId","parent","aggregationResult","gridAggregationLookupSelector","didWrapSomeProperty","wrappedColumn","aggregationWrappedProperties","wrapColumnProperty","property","wrapper","originalValue","wrappedProperty","push","name","wrappedValue","_ref","unwrappedColumn","forEach"],"sources":["C:/Users/kb/node_modules/@mui/x-data-grid-premium/hooks/features/aggregation/wrapColumnWithAggregation.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.wrapColumnWithAggregationValue = exports.unwrapColumnFromAggregation = void 0;\nvar _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutPropertiesLoose\"));\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _gridAggregationSelectors = require(\"./gridAggregationSelectors\");\nvar _GridFooterCell = require(\"../../../components/GridFooterCell\");\nvar _GridAggregationHeader = require(\"../../../components/GridAggregationHeader\");\nvar _jsxRuntime = require(\"react/jsx-runtime\");\nconst _excluded = [\"aggregationWrappedProperties\"];\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\nconst AGGREGATION_WRAPPABLE_PROPERTIES = ['valueGetter', 'valueFormatter', 'renderCell', 'renderHeader', 'filterOperators'];\nconst getAggregationValueWrappedValueGetter = ({\n  value: valueGetter,\n  getCellAggregationResult\n}) => {\n  const wrappedValueGetter = (value, row, column, apiRef) => {\n    const rowId = apiRef.current.getRowId(row);\n    const cellAggregationResult = getCellAggregationResult(rowId, column.field);\n    if (cellAggregationResult != null) {\n      return cellAggregationResult?.value ?? null;\n    }\n    if (valueGetter) {\n      return valueGetter(value, row, column, apiRef);\n    }\n    return row[column.field];\n  };\n  return wrappedValueGetter;\n};\nconst getAggregationValueWrappedValueFormatter = ({\n  value: valueFormatter,\n  aggregationRule,\n  getCellAggregationResult\n}) => {\n  // If neither the inline aggregation function nor the footer aggregation function have a custom value formatter,\n  // Then we don't wrap the column value formatter\n  if (!aggregationRule.aggregationFunction.valueFormatter) {\n    return valueFormatter;\n  }\n  const wrappedValueFormatter = (value, row, column, apiRef) => {\n    const rowId = apiRef.current.getRowId(row);\n    if (rowId != null) {\n      const cellAggregationResult = getCellAggregationResult(rowId, column.field);\n      if (cellAggregationResult != null) {\n        return aggregationRule.aggregationFunction.valueFormatter?.(value, row, column, apiRef);\n      }\n    }\n    if (valueFormatter) {\n      return valueFormatter(value, row, column, apiRef);\n    }\n    return value;\n  };\n  return wrappedValueFormatter;\n};\nconst getAggregationValueWrappedRenderCell = ({\n  value: renderCell,\n  aggregationRule,\n  getCellAggregationResult\n}) => {\n  const wrappedRenderCell = params => {\n    const cellAggregationResult = getCellAggregationResult(params.id, params.field);\n    if (cellAggregationResult != null) {\n      if (!renderCell) {\n        if (cellAggregationResult.position === 'footer') {\n          return /*#__PURE__*/(0, _jsxRuntime.jsx)(_GridFooterCell.GridFooterCell, (0, _extends2.default)({}, params));\n        }\n        return params.formattedValue;\n      }\n      const aggregationMeta = {\n        hasCellUnit: aggregationRule.aggregationFunction.hasCellUnit ?? true,\n        aggregationFunctionName: aggregationRule.aggregationFunctionName\n      };\n      return renderCell((0, _extends2.default)({}, params, {\n        aggregation: aggregationMeta\n      }));\n    }\n    if (!renderCell) {\n      return params.formattedValue;\n    }\n    return renderCell(params);\n  };\n  return wrappedRenderCell;\n};\n\n/**\n * Skips the filtering for aggregated rows\n */\nconst getWrappedFilterOperators = ({\n  value: filterOperators,\n  apiRef,\n  getCellAggregationResult\n}) => filterOperators.map(operator => {\n  const baseGetApplyFilterFn = operator.getApplyFilterFn;\n  const getApplyFilterFn = (filterItem, colDef) => {\n    const filterFn = baseGetApplyFilterFn(filterItem, colDef);\n    if (!filterFn) {\n      return null;\n    }\n    return (value, row, column, api) => {\n      if (getCellAggregationResult(apiRef.current.getRowId(row), column.field) != null) {\n        return true;\n      }\n      return filterFn(value, row, column, api);\n    };\n  };\n  return (0, _extends2.default)({}, operator, {\n    getApplyFilterFn\n  });\n});\n\n/**\n * Add the aggregation method around the header name\n */\nconst getWrappedRenderHeader = ({\n  value: renderHeader,\n  aggregationRule\n}) => {\n  const wrappedRenderHeader = params => {\n    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_GridAggregationHeader.GridAggregationHeader, (0, _extends2.default)({}, params, {\n      aggregation: {\n        aggregationRule\n      },\n      renderHeader: renderHeader\n    }));\n  };\n  return wrappedRenderHeader;\n};\n\n/**\n * Add a wrapper around each wrappable property of the column to customize the behavior of the aggregation cells.\n */\nconst wrapColumnWithAggregationValue = ({\n  column,\n  apiRef,\n  aggregationRule\n}) => {\n  const getCellAggregationResult = (id, field) => {\n    let cellAggregationPosition = null;\n    const rowNode = apiRef.current.getRowNode(id);\n    if (rowNode.type === 'group') {\n      cellAggregationPosition = 'inline';\n    } else if (id.toString().startsWith('auto-generated-group-footer-')) {\n      cellAggregationPosition = 'footer';\n    }\n    if (cellAggregationPosition == null) {\n      return null;\n    }\n\n    // TODO: Add custom root id\n    const groupId = cellAggregationPosition === 'inline' ? id : rowNode.parent ?? '';\n    const aggregationResult = (0, _gridAggregationSelectors.gridAggregationLookupSelector)(apiRef)?.[groupId]?.[field];\n    if (!aggregationResult || aggregationResult.position !== cellAggregationPosition) {\n      return null;\n    }\n    return aggregationResult;\n  };\n  let didWrapSomeProperty = false;\n  const wrappedColumn = (0, _extends2.default)({}, column, {\n    aggregationWrappedProperties: []\n  });\n  const wrapColumnProperty = (property, wrapper) => {\n    const originalValue = column[property];\n    const wrappedProperty = wrapper({\n      apiRef,\n      value: originalValue,\n      colDef: column,\n      aggregationRule,\n      getCellAggregationResult\n    });\n    if (wrappedProperty !== originalValue) {\n      didWrapSomeProperty = true;\n      wrappedColumn[property] = wrappedProperty;\n      wrappedColumn.aggregationWrappedProperties.push({\n        name: property,\n        originalValue,\n        wrappedValue: wrappedProperty\n      });\n    }\n  };\n  wrapColumnProperty('valueGetter', getAggregationValueWrappedValueGetter);\n  wrapColumnProperty('valueFormatter', getAggregationValueWrappedValueFormatter);\n  wrapColumnProperty('renderCell', getAggregationValueWrappedRenderCell);\n  wrapColumnProperty('renderHeader', getWrappedRenderHeader);\n  wrapColumnProperty('filterOperators', getWrappedFilterOperators);\n  if (!didWrapSomeProperty) {\n    return column;\n  }\n  return wrappedColumn;\n};\n\n/**\n * Remove the aggregation wrappers around the wrappable properties of the column.\n */\nexports.wrapColumnWithAggregationValue = wrapColumnWithAggregationValue;\nconst unwrapColumnFromAggregation = ({\n  column\n}) => {\n  if (!column.aggregationWrappedProperties) {\n    return column;\n  }\n  const _ref = column,\n    {\n      aggregationWrappedProperties\n    } = _ref,\n    unwrappedColumn = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);\n  aggregationWrappedProperties.forEach(({\n    name,\n    originalValue,\n    wrappedValue\n  }) => {\n    // The value changed since we wrapped it\n    if (wrappedValue !== unwrappedColumn[name]) {\n      return;\n    }\n    unwrappedColumn[name] = originalValue;\n  });\n  return unwrappedColumn;\n};\nexports.unwrapColumnFromAggregation = unwrapColumnFromAggregation;"],"mappings":"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"},"metadata":{},"sourceType":"script"}