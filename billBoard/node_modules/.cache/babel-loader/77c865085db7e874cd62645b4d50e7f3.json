{"ast":null,"code":"import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"leafField\", \"mainGroupingCriteria\", \"hideDescendantCount\"],\n      _excluded2 = [\"leafField\", \"mainGroupingCriteria\", \"hideDescendantCount\"];\nimport * as React from 'react';\nimport { GRID_STRING_COL_DEF } from '@mui/x-data-grid-pro';\nimport { isSingleSelectColDef } from '@mui/x-data-grid-pro/internals';\nimport { GridGroupingColumnFooterCell } from '../../../components/GridGroupingColumnFooterCell';\nimport { GridGroupingCriteriaCell } from '../../../components/GridGroupingCriteriaCell';\nimport { GridGroupingColumnLeafCell } from '../../../components/GridGroupingColumnLeafCell';\nimport { getRowGroupingFieldFromGroupingCriteria, GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD } from './gridRowGroupingUtils';\nimport { gridRowGroupingSanitizedModelSelector } from './gridRowGroupingSelector';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n\nconst GROUPING_COL_DEF_DEFAULT_PROPERTIES = _extends({}, GRID_STRING_COL_DEF, {\n  type: 'custom',\n  disableReorder: true\n});\n\nconst GROUPING_COL_DEF_FORCED_PROPERTIES = {\n  editable: false,\n  groupable: false\n};\n/**\n * When sorting two cells with different grouping criteria, we consider that the cell with the grouping criteria coming first in the model should be displayed below.\n * This can occur when some rows don't have all the fields. In which case we want the rows with the missing field to be displayed above.\n * TODO: Make this index comparator depth invariant, the logic should not be inverted when sorting in the \"desc\" direction (but the current return format of `sortComparator` does not support this behavior).\n */\n\nconst groupingFieldIndexComparator = (v1, v2, cellParams1, cellParams2) => {\n  const model = gridRowGroupingSanitizedModelSelector(cellParams1.api.state, cellParams1.api.instanceId);\n  const groupingField1 = cellParams1.rowNode.groupingField ?? null;\n  const groupingField2 = cellParams2.rowNode.groupingField ?? null;\n\n  if (groupingField1 === groupingField2) {\n    return 0;\n  }\n\n  if (groupingField1 == null) {\n    return -1;\n  }\n\n  if (groupingField2 == null) {\n    return 1;\n  }\n\n  if (model.indexOf(groupingField1) < model.indexOf(groupingField2)) {\n    return -1;\n  }\n\n  return 1;\n};\n\nconst getLeafProperties = leafColDef => ({\n  headerName: leafColDef.headerName ?? leafColDef.field,\n  sortable: leafColDef.sortable,\n  filterable: leafColDef.filterable,\n  valueOptions: isSingleSelectColDef(leafColDef) ? leafColDef.valueOptions : undefined,\n  filterOperators: leafColDef.filterOperators,\n  sortComparator: (v1, v2, cellParams1, cellParams2) => {\n    // We only want to sort the leaves\n    if (cellParams1.rowNode.type === 'leaf' && cellParams2.rowNode.type === 'leaf') {\n      return leafColDef.sortComparator(v1, v2, cellParams1, cellParams2);\n    }\n\n    return groupingFieldIndexComparator(v1, v2, cellParams1, cellParams2);\n  }\n});\n\nconst getGroupingCriteriaProperties = (groupedByColDef, applyHeaderName) => {\n  const properties = {\n    sortable: groupedByColDef.sortable,\n    filterable: groupedByColDef.filterable,\n    valueOptions: isSingleSelectColDef(groupedByColDef) ? groupedByColDef.valueOptions : undefined,\n    sortComparator: (v1, v2, cellParams1, cellParams2) => {\n      // We only want to sort the groups of the current grouping criteria\n      if (cellParams1.rowNode.type === 'group' && cellParams2.rowNode.type === 'group' && cellParams1.rowNode.groupingField === cellParams2.rowNode.groupingField) {\n        const colDef = cellParams1.api.getColumn(cellParams1.rowNode.groupingField);\n        return colDef.sortComparator(v1, v2, cellParams1, cellParams2);\n      }\n\n      return groupingFieldIndexComparator(v1, v2, cellParams1, cellParams2);\n    },\n    filterOperators: groupedByColDef.filterOperators\n  };\n\n  if (applyHeaderName) {\n    properties.headerName = groupedByColDef.headerName ?? groupedByColDef.field;\n  }\n\n  return properties;\n};\n/**\n * Creates the `GridColDef` for a grouping column that only takes care of a single grouping criteria\n */\n\n\nexport const createGroupingColDefForOneGroupingCriteria = _ref3 => {\n  let {\n    columnsLookup,\n    groupedByColDef,\n    groupingCriteria,\n    colDefOverride\n  } = _ref3;\n\n  const _ref = colDefOverride ?? {},\n        {\n    leafField,\n    mainGroupingCriteria,\n    hideDescendantCount\n  } = _ref,\n        colDefOverrideProperties = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n  const leafColDef = leafField ? columnsLookup[leafField] : null; // The properties that do not depend on the presence of a `leafColDef` and that can be overridden by `colDefOverride`\n\n  const commonProperties = {\n    width: Math.max((groupedByColDef.width ?? GRID_STRING_COL_DEF.width) + 40, leafColDef?.width ?? 0),\n    renderCell: params => {\n      // Render footer\n      if (params.rowNode.type === 'footer' || params.rowNode.type === 'pinnedRow') {\n        return /*#__PURE__*/_jsx(GridGroupingColumnFooterCell, _extends({}, params));\n      } // Render leaves\n\n\n      if (params.rowNode.type === 'leaf') {\n        if (leafColDef) {\n          const leafParams = _extends({}, params.api.getCellParams(params.id, leafField), {\n            api: params.api,\n            hasFocus: params.hasFocus\n          });\n\n          if (leafColDef.renderCell) {\n            return leafColDef.renderCell(leafParams);\n          }\n\n          return /*#__PURE__*/_jsx(GridGroupingColumnLeafCell, _extends({}, leafParams));\n        }\n\n        return '';\n      } // Render current grouping criteria groups\n\n\n      if (params.rowNode.groupingField === groupingCriteria) {\n        return /*#__PURE__*/_jsx(GridGroupingCriteriaCell, _extends({}, params, {\n          hideDescendantCount: hideDescendantCount\n        }));\n      }\n\n      return '';\n    },\n    valueGetter: (value, row, column, apiRef) => {\n      const rowId = apiRef.current.getRowId(row);\n      const rowNode = apiRef.current.getRowNode(rowId);\n\n      if (!rowNode || rowNode.type === 'footer' || rowNode.type === 'pinnedRow') {\n        return undefined;\n      }\n\n      if (rowNode.type === 'leaf') {\n        if (leafColDef) {\n          return apiRef.current.getCellValue(rowId, leafField);\n        }\n\n        return undefined;\n      }\n\n      if (rowNode.groupingField === groupingCriteria) {\n        return rowNode.groupingKey;\n      }\n\n      return undefined;\n    }\n  }; // If we have a `mainGroupingCriteria` defined and matching the `groupingCriteria`\n  // Then we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `groupedByColDef`.\n  // It can be useful to define a `leafField` for leaves rendering but still use the grouping criteria for the sorting / filtering\n  //\n  // If we have a `leafField` defined and matching an existing column\n  // Then we apply the sorting / filtering on the leaves based on the properties of `leavesColDef`\n  //\n  // By default, we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `groupedColDef`.\n\n  let sourceProperties;\n\n  if (mainGroupingCriteria && mainGroupingCriteria === groupingCriteria) {\n    sourceProperties = getGroupingCriteriaProperties(groupedByColDef, true);\n  } else if (leafColDef) {\n    sourceProperties = getLeafProperties(leafColDef);\n  } else {\n    sourceProperties = getGroupingCriteriaProperties(groupedByColDef, true);\n  } // The properties that can't be overridden with `colDefOverride`\n\n\n  const forcedProperties = _extends({\n    field: getRowGroupingFieldFromGroupingCriteria(groupingCriteria)\n  }, GROUPING_COL_DEF_FORCED_PROPERTIES);\n\n  return _extends({}, GROUPING_COL_DEF_DEFAULT_PROPERTIES, commonProperties, sourceProperties, colDefOverrideProperties, forcedProperties);\n};\n/**\n * Creates the `GridColDef` for a grouping column that takes care of all the grouping criteria\n */\n\nexport const createGroupingColDefForAllGroupingCriteria = _ref4 => {\n  let {\n    apiRef,\n    columnsLookup,\n    rowGroupingModel,\n    colDefOverride\n  } = _ref4;\n\n  const _ref2 = colDefOverride ?? {},\n        {\n    leafField,\n    mainGroupingCriteria,\n    hideDescendantCount\n  } = _ref2,\n        colDefOverrideProperties = _objectWithoutPropertiesLoose(_ref2, _excluded2);\n\n  const leafColDef = leafField ? columnsLookup[leafField] : null; // The properties that do not depend on the presence of a `leafColDef` and that can be overridden by `colDefOverride`\n\n  const commonProperties = {\n    headerName: apiRef.current.getLocaleText('groupingColumnHeaderName'),\n    width: Math.max(...rowGroupingModel.map(field => (columnsLookup[field].width ?? GRID_STRING_COL_DEF.width) + 40), leafColDef?.width ?? 0),\n    renderCell: params => {\n      // Render footer\n      if (params.rowNode.type === 'footer' || params.rowNode.type === 'pinnedRow') {\n        return /*#__PURE__*/_jsx(GridGroupingColumnFooterCell, _extends({}, params));\n      } // Render the leaves\n\n\n      if (params.rowNode.type === 'leaf') {\n        if (leafColDef) {\n          const leafParams = _extends({}, params.api.getCellParams(params.id, leafField), {\n            api: params.api,\n            hasFocus: params.hasFocus\n          });\n\n          if (leafColDef.renderCell) {\n            return leafColDef.renderCell(leafParams);\n          }\n\n          return /*#__PURE__*/_jsx(GridGroupingColumnLeafCell, _extends({}, leafParams));\n        }\n\n        return '';\n      } // Render the groups\n\n\n      return /*#__PURE__*/_jsx(GridGroupingCriteriaCell, _extends({}, params, {\n        hideDescendantCount: hideDescendantCount\n      }));\n    },\n    valueGetter: (value, row) => {\n      const rowId = apiRef.current.getRowId(row);\n      const rowNode = apiRef.current.getRowNode(rowId);\n\n      if (!rowNode || rowNode.type === 'footer' || rowNode.type === 'pinnedRow') {\n        return undefined;\n      }\n\n      if (rowNode.type === 'leaf') {\n        if (leafColDef) {\n          return apiRef.current.getCellValue(rowId, leafField);\n        }\n\n        return undefined;\n      }\n\n      return rowNode.groupingKey;\n    }\n  }; // If we have a `mainGroupingCriteria` defined and matching one of the `orderedGroupedByFields`\n  // Then we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `columnsLookup[mainGroupingCriteria]`.\n  // It can be useful to use another grouping criteria than the top level one for the sorting / filtering\n  //\n  // If we have a `leafField` defined and matching an existing column\n  // Then we apply the sorting / filtering on the leaves based on the properties of `leavesColDef`\n  //\n  // By default, we apply the sorting / filtering on the groups of the top level grouping criteria based on the properties of `columnsLookup[orderedGroupedByFields[0]]`.\n\n  let sourceProperties;\n\n  if (mainGroupingCriteria && rowGroupingModel.includes(mainGroupingCriteria)) {\n    sourceProperties = getGroupingCriteriaProperties(columnsLookup[mainGroupingCriteria], true);\n  } else if (leafColDef) {\n    sourceProperties = getLeafProperties(leafColDef);\n  } else {\n    sourceProperties = getGroupingCriteriaProperties(columnsLookup[rowGroupingModel[0]], rowGroupingModel.length === 1);\n  } // The properties that can't be overridden with `colDefOverride`\n\n\n  const forcedProperties = _extends({\n    field: GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD\n  }, GROUPING_COL_DEF_FORCED_PROPERTIES);\n\n  return _extends({}, GROUPING_COL_DEF_DEFAULT_PROPERTIES, commonProperties, sourceProperties, colDefOverrideProperties, forcedProperties);\n};","map":{"version":3,"names":["_objectWithoutPropertiesLoose","_extends","_excluded","_excluded2","React","GRID_STRING_COL_DEF","isSingleSelectColDef","GridGroupingColumnFooterCell","GridGroupingCriteriaCell","GridGroupingColumnLeafCell","getRowGroupingFieldFromGroupingCriteria","GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD","gridRowGroupingSanitizedModelSelector","jsx","_jsx","GROUPING_COL_DEF_DEFAULT_PROPERTIES","type","disableReorder","GROUPING_COL_DEF_FORCED_PROPERTIES","editable","groupable","groupingFieldIndexComparator","v1","v2","cellParams1","cellParams2","model","api","state","instanceId","groupingField1","rowNode","groupingField","groupingField2","indexOf","getLeafProperties","leafColDef","headerName","field","sortable","filterable","valueOptions","undefined","filterOperators","sortComparator","getGroupingCriteriaProperties","groupedByColDef","applyHeaderName","properties","colDef","getColumn","createGroupingColDefForOneGroupingCriteria","columnsLookup","groupingCriteria","colDefOverride","_ref","leafField","mainGroupingCriteria","hideDescendantCount","colDefOverrideProperties","commonProperties","width","Math","max","renderCell","params","leafParams","getCellParams","id","hasFocus","valueGetter","value","row","column","apiRef","rowId","current","getRowId","getRowNode","getCellValue","groupingKey","sourceProperties","forcedProperties","createGroupingColDefForAllGroupingCriteria","rowGroupingModel","_ref2","getLocaleText","map","includes","length"],"sources":["C:/Users/kb/node_modules/@mui/x-data-grid-premium/esm/hooks/features/rowGrouping/createGroupingColDef.js"],"sourcesContent":["import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"leafField\", \"mainGroupingCriteria\", \"hideDescendantCount\"],\n  _excluded2 = [\"leafField\", \"mainGroupingCriteria\", \"hideDescendantCount\"];\nimport * as React from 'react';\nimport { GRID_STRING_COL_DEF } from '@mui/x-data-grid-pro';\nimport { isSingleSelectColDef } from '@mui/x-data-grid-pro/internals';\nimport { GridGroupingColumnFooterCell } from '../../../components/GridGroupingColumnFooterCell';\nimport { GridGroupingCriteriaCell } from '../../../components/GridGroupingCriteriaCell';\nimport { GridGroupingColumnLeafCell } from '../../../components/GridGroupingColumnLeafCell';\nimport { getRowGroupingFieldFromGroupingCriteria, GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD } from './gridRowGroupingUtils';\nimport { gridRowGroupingSanitizedModelSelector } from './gridRowGroupingSelector';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst GROUPING_COL_DEF_DEFAULT_PROPERTIES = _extends({}, GRID_STRING_COL_DEF, {\n  type: 'custom',\n  disableReorder: true\n});\nconst GROUPING_COL_DEF_FORCED_PROPERTIES = {\n  editable: false,\n  groupable: false\n};\n\n/**\n * When sorting two cells with different grouping criteria, we consider that the cell with the grouping criteria coming first in the model should be displayed below.\n * This can occur when some rows don't have all the fields. In which case we want the rows with the missing field to be displayed above.\n * TODO: Make this index comparator depth invariant, the logic should not be inverted when sorting in the \"desc\" direction (but the current return format of `sortComparator` does not support this behavior).\n */\nconst groupingFieldIndexComparator = (v1, v2, cellParams1, cellParams2) => {\n  const model = gridRowGroupingSanitizedModelSelector(cellParams1.api.state, cellParams1.api.instanceId);\n  const groupingField1 = cellParams1.rowNode.groupingField ?? null;\n  const groupingField2 = cellParams2.rowNode.groupingField ?? null;\n  if (groupingField1 === groupingField2) {\n    return 0;\n  }\n  if (groupingField1 == null) {\n    return -1;\n  }\n  if (groupingField2 == null) {\n    return 1;\n  }\n  if (model.indexOf(groupingField1) < model.indexOf(groupingField2)) {\n    return -1;\n  }\n  return 1;\n};\nconst getLeafProperties = leafColDef => ({\n  headerName: leafColDef.headerName ?? leafColDef.field,\n  sortable: leafColDef.sortable,\n  filterable: leafColDef.filterable,\n  valueOptions: isSingleSelectColDef(leafColDef) ? leafColDef.valueOptions : undefined,\n  filterOperators: leafColDef.filterOperators,\n  sortComparator: (v1, v2, cellParams1, cellParams2) => {\n    // We only want to sort the leaves\n    if (cellParams1.rowNode.type === 'leaf' && cellParams2.rowNode.type === 'leaf') {\n      return leafColDef.sortComparator(v1, v2, cellParams1, cellParams2);\n    }\n    return groupingFieldIndexComparator(v1, v2, cellParams1, cellParams2);\n  }\n});\nconst getGroupingCriteriaProperties = (groupedByColDef, applyHeaderName) => {\n  const properties = {\n    sortable: groupedByColDef.sortable,\n    filterable: groupedByColDef.filterable,\n    valueOptions: isSingleSelectColDef(groupedByColDef) ? groupedByColDef.valueOptions : undefined,\n    sortComparator: (v1, v2, cellParams1, cellParams2) => {\n      // We only want to sort the groups of the current grouping criteria\n      if (cellParams1.rowNode.type === 'group' && cellParams2.rowNode.type === 'group' && cellParams1.rowNode.groupingField === cellParams2.rowNode.groupingField) {\n        const colDef = cellParams1.api.getColumn(cellParams1.rowNode.groupingField);\n        return colDef.sortComparator(v1, v2, cellParams1, cellParams2);\n      }\n      return groupingFieldIndexComparator(v1, v2, cellParams1, cellParams2);\n    },\n    filterOperators: groupedByColDef.filterOperators\n  };\n  if (applyHeaderName) {\n    properties.headerName = groupedByColDef.headerName ?? groupedByColDef.field;\n  }\n  return properties;\n};\n/**\n * Creates the `GridColDef` for a grouping column that only takes care of a single grouping criteria\n */\nexport const createGroupingColDefForOneGroupingCriteria = ({\n  columnsLookup,\n  groupedByColDef,\n  groupingCriteria,\n  colDefOverride\n}) => {\n  const _ref = colDefOverride ?? {},\n    {\n      leafField,\n      mainGroupingCriteria,\n      hideDescendantCount\n    } = _ref,\n    colDefOverrideProperties = _objectWithoutPropertiesLoose(_ref, _excluded);\n  const leafColDef = leafField ? columnsLookup[leafField] : null;\n\n  // The properties that do not depend on the presence of a `leafColDef` and that can be overridden by `colDefOverride`\n  const commonProperties = {\n    width: Math.max((groupedByColDef.width ?? GRID_STRING_COL_DEF.width) + 40, leafColDef?.width ?? 0),\n    renderCell: params => {\n      // Render footer\n      if (params.rowNode.type === 'footer' || params.rowNode.type === 'pinnedRow') {\n        return /*#__PURE__*/_jsx(GridGroupingColumnFooterCell, _extends({}, params));\n      }\n\n      // Render leaves\n      if (params.rowNode.type === 'leaf') {\n        if (leafColDef) {\n          const leafParams = _extends({}, params.api.getCellParams(params.id, leafField), {\n            api: params.api,\n            hasFocus: params.hasFocus\n          });\n          if (leafColDef.renderCell) {\n            return leafColDef.renderCell(leafParams);\n          }\n          return /*#__PURE__*/_jsx(GridGroupingColumnLeafCell, _extends({}, leafParams));\n        }\n        return '';\n      }\n\n      // Render current grouping criteria groups\n      if (params.rowNode.groupingField === groupingCriteria) {\n        return /*#__PURE__*/_jsx(GridGroupingCriteriaCell, _extends({}, params, {\n          hideDescendantCount: hideDescendantCount\n        }));\n      }\n      return '';\n    },\n    valueGetter: (value, row, column, apiRef) => {\n      const rowId = apiRef.current.getRowId(row);\n      const rowNode = apiRef.current.getRowNode(rowId);\n      if (!rowNode || rowNode.type === 'footer' || rowNode.type === 'pinnedRow') {\n        return undefined;\n      }\n      if (rowNode.type === 'leaf') {\n        if (leafColDef) {\n          return apiRef.current.getCellValue(rowId, leafField);\n        }\n        return undefined;\n      }\n      if (rowNode.groupingField === groupingCriteria) {\n        return rowNode.groupingKey;\n      }\n      return undefined;\n    }\n  };\n\n  // If we have a `mainGroupingCriteria` defined and matching the `groupingCriteria`\n  // Then we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `groupedByColDef`.\n  // It can be useful to define a `leafField` for leaves rendering but still use the grouping criteria for the sorting / filtering\n  //\n  // If we have a `leafField` defined and matching an existing column\n  // Then we apply the sorting / filtering on the leaves based on the properties of `leavesColDef`\n  //\n  // By default, we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `groupedColDef`.\n  let sourceProperties;\n  if (mainGroupingCriteria && mainGroupingCriteria === groupingCriteria) {\n    sourceProperties = getGroupingCriteriaProperties(groupedByColDef, true);\n  } else if (leafColDef) {\n    sourceProperties = getLeafProperties(leafColDef);\n  } else {\n    sourceProperties = getGroupingCriteriaProperties(groupedByColDef, true);\n  }\n\n  // The properties that can't be overridden with `colDefOverride`\n  const forcedProperties = _extends({\n    field: getRowGroupingFieldFromGroupingCriteria(groupingCriteria)\n  }, GROUPING_COL_DEF_FORCED_PROPERTIES);\n  return _extends({}, GROUPING_COL_DEF_DEFAULT_PROPERTIES, commonProperties, sourceProperties, colDefOverrideProperties, forcedProperties);\n};\n/**\n * Creates the `GridColDef` for a grouping column that takes care of all the grouping criteria\n */\nexport const createGroupingColDefForAllGroupingCriteria = ({\n  apiRef,\n  columnsLookup,\n  rowGroupingModel,\n  colDefOverride\n}) => {\n  const _ref2 = colDefOverride ?? {},\n    {\n      leafField,\n      mainGroupingCriteria,\n      hideDescendantCount\n    } = _ref2,\n    colDefOverrideProperties = _objectWithoutPropertiesLoose(_ref2, _excluded2);\n  const leafColDef = leafField ? columnsLookup[leafField] : null;\n\n  // The properties that do not depend on the presence of a `leafColDef` and that can be overridden by `colDefOverride`\n  const commonProperties = {\n    headerName: apiRef.current.getLocaleText('groupingColumnHeaderName'),\n    width: Math.max(...rowGroupingModel.map(field => (columnsLookup[field].width ?? GRID_STRING_COL_DEF.width) + 40), leafColDef?.width ?? 0),\n    renderCell: params => {\n      // Render footer\n      if (params.rowNode.type === 'footer' || params.rowNode.type === 'pinnedRow') {\n        return /*#__PURE__*/_jsx(GridGroupingColumnFooterCell, _extends({}, params));\n      }\n\n      // Render the leaves\n      if (params.rowNode.type === 'leaf') {\n        if (leafColDef) {\n          const leafParams = _extends({}, params.api.getCellParams(params.id, leafField), {\n            api: params.api,\n            hasFocus: params.hasFocus\n          });\n          if (leafColDef.renderCell) {\n            return leafColDef.renderCell(leafParams);\n          }\n          return /*#__PURE__*/_jsx(GridGroupingColumnLeafCell, _extends({}, leafParams));\n        }\n        return '';\n      }\n\n      // Render the groups\n      return /*#__PURE__*/_jsx(GridGroupingCriteriaCell, _extends({}, params, {\n        hideDescendantCount: hideDescendantCount\n      }));\n    },\n    valueGetter: (value, row) => {\n      const rowId = apiRef.current.getRowId(row);\n      const rowNode = apiRef.current.getRowNode(rowId);\n      if (!rowNode || rowNode.type === 'footer' || rowNode.type === 'pinnedRow') {\n        return undefined;\n      }\n      if (rowNode.type === 'leaf') {\n        if (leafColDef) {\n          return apiRef.current.getCellValue(rowId, leafField);\n        }\n        return undefined;\n      }\n      return rowNode.groupingKey;\n    }\n  };\n\n  // If we have a `mainGroupingCriteria` defined and matching one of the `orderedGroupedByFields`\n  // Then we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `columnsLookup[mainGroupingCriteria]`.\n  // It can be useful to use another grouping criteria than the top level one for the sorting / filtering\n  //\n  // If we have a `leafField` defined and matching an existing column\n  // Then we apply the sorting / filtering on the leaves based on the properties of `leavesColDef`\n  //\n  // By default, we apply the sorting / filtering on the groups of the top level grouping criteria based on the properties of `columnsLookup[orderedGroupedByFields[0]]`.\n  let sourceProperties;\n  if (mainGroupingCriteria && rowGroupingModel.includes(mainGroupingCriteria)) {\n    sourceProperties = getGroupingCriteriaProperties(columnsLookup[mainGroupingCriteria], true);\n  } else if (leafColDef) {\n    sourceProperties = getLeafProperties(leafColDef);\n  } else {\n    sourceProperties = getGroupingCriteriaProperties(columnsLookup[rowGroupingModel[0]], rowGroupingModel.length === 1);\n  }\n\n  // The properties that can't be overridden with `colDefOverride`\n  const forcedProperties = _extends({\n    field: GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD\n  }, GROUPING_COL_DEF_FORCED_PROPERTIES);\n  return _extends({}, GROUPING_COL_DEF_DEFAULT_PROPERTIES, commonProperties, sourceProperties, colDefOverrideProperties, forcedProperties);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}