{"ast":null,"code":"import { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid';\nimport { updateGroupDefaultExpansion, getGroupRowIdFromPath, insertNodeInTree, updateGroupNodeIdAndAutoGenerated } from './utils';\n/**\n * Inserts a data row in a tree.\n * For each steps of its path:\n * - if a node exists with the same partial path, it will register this node as the ancestor of the data row.\n * - if not, it will create an auto-generated node and register it as ancestor of the data row.\n */\n\nexport const insertDataRowInTree = _ref => {\n  let {\n    id,\n    path,\n    updatedGroupsManager,\n    previousTree,\n    tree,\n    treeDepths,\n    onDuplicatePath,\n    isGroupExpandedByDefault,\n    defaultGroupingExpansionDepth\n  } = _ref;\n  let parentNodeId = GRID_ROOT_GROUP_ID;\n\n  for (let depth = 0; depth < path.length; depth += 1) {\n    const {\n      key,\n      field\n    } = path[depth];\n    const fieldWithDefaultValue = field ?? '__no_field__';\n    const keyWithDefaultValue = key ?? '__no_key__';\n    const existingNodeIdWithPartialPath = tree[parentNodeId].childrenFromPath?.[fieldWithDefaultValue]?.[keyWithDefaultValue.toString()]; // When we reach the last step of the path,\n    // We need to create a node for the row passed to `insertNodeInTree`\n\n    if (depth === path.length - 1) {\n      // If no node matches the full path,\n      // We create a leaf node for the data row.\n      if (existingNodeIdWithPartialPath == null) {\n        const leafNode = {\n          type: 'leaf',\n          id,\n          depth,\n          parent: parentNodeId,\n          groupingKey: key\n        };\n        updatedGroupsManager?.addAction(parentNodeId, 'insertChildren');\n        insertNodeInTree(leafNode, tree, treeDepths, previousTree);\n      } else {\n        const existingNodeWithPartialPath = tree[existingNodeIdWithPartialPath]; // If we already have an auto-generated group matching the partial path,\n        // We replace it with the node from of data row passed to `insertNodeInTree`\n\n        if (existingNodeWithPartialPath.type === 'group' && existingNodeWithPartialPath.isAutoGenerated) {\n          updatedGroupsManager?.addAction(parentNodeId, 'removeChildren');\n          updatedGroupsManager?.addAction(parentNodeId, 'insertChildren');\n          updateGroupNodeIdAndAutoGenerated({\n            tree,\n            previousTree,\n            treeDepths,\n            node: existingNodeWithPartialPath,\n            updatedNode: {\n              id,\n              isAutoGenerated: false\n            }\n          });\n        } else {\n          // If we have another row matching the partial path, then there is a duplicate in the dataset.\n          // We warn the user and skip the current row.\n          onDuplicatePath?.(existingNodeIdWithPartialPath, id, path);\n        }\n      }\n    } // For the intermediary steps of the path,\n    // We need to make sure that there is a node matching the partial path.\n    //\n    // If no node matches the partial path,\n    // We create an auto-generated group node.\n    else if (existingNodeIdWithPartialPath == null) {\n      const nodeId = getGroupRowIdFromPath(path.slice(0, depth + 1));\n      const autoGeneratedGroupNode = {\n        type: 'group',\n        id: nodeId,\n        parent: parentNodeId,\n        depth,\n        isAutoGenerated: true,\n        groupingKey: key,\n        groupingField: field,\n        children: [],\n        childrenFromPath: {},\n        childrenExpanded: false\n      };\n      updatedGroupsManager?.addAction(parentNodeId, 'insertChildren');\n      insertNodeInTree(updateGroupDefaultExpansion(autoGeneratedGroupNode, defaultGroupingExpansionDepth, isGroupExpandedByDefault), tree, treeDepths, previousTree);\n      parentNodeId = nodeId;\n    } // For the intermediary steps of the path\n    // If a node matches the partial path, we use it as parent for the next step\n    else {\n      const currentGroupNode = tree[existingNodeIdWithPartialPath]; // If the node matching the partial path is not a group, we turn it into a group\n\n      if (currentGroupNode.type !== 'group') {\n        const groupNode = {\n          type: 'group',\n          id: currentGroupNode.id,\n          parent: currentGroupNode.parent,\n          depth: currentGroupNode.depth,\n          isAutoGenerated: false,\n          groupingKey: key,\n          groupingField: field,\n          children: [],\n          childrenFromPath: {},\n          childrenExpanded: false\n        };\n        tree[existingNodeIdWithPartialPath] = updateGroupDefaultExpansion(groupNode, defaultGroupingExpansionDepth, isGroupExpandedByDefault);\n      }\n\n      parentNodeId = currentGroupNode.id;\n    }\n  }\n};","map":{"version":3,"names":["GRID_ROOT_GROUP_ID","updateGroupDefaultExpansion","getGroupRowIdFromPath","insertNodeInTree","updateGroupNodeIdAndAutoGenerated","insertDataRowInTree","id","path","updatedGroupsManager","previousTree","tree","treeDepths","onDuplicatePath","isGroupExpandedByDefault","defaultGroupingExpansionDepth","parentNodeId","depth","length","key","field","fieldWithDefaultValue","keyWithDefaultValue","existingNodeIdWithPartialPath","childrenFromPath","toString","leafNode","type","parent","groupingKey","addAction","existingNodeWithPartialPath","isAutoGenerated","node","updatedNode","nodeId","slice","autoGeneratedGroupNode","groupingField","children","childrenExpanded","currentGroupNode","groupNode"],"sources":["C:/Users/kb/node_modules/@mui/x-data-grid-pro/esm/utils/tree/insertDataRowInTree.js"],"sourcesContent":["import { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid';\nimport { updateGroupDefaultExpansion, getGroupRowIdFromPath, insertNodeInTree, updateGroupNodeIdAndAutoGenerated } from './utils';\n/**\n * Inserts a data row in a tree.\n * For each steps of its path:\n * - if a node exists with the same partial path, it will register this node as the ancestor of the data row.\n * - if not, it will create an auto-generated node and register it as ancestor of the data row.\n */\nexport const insertDataRowInTree = ({\n  id,\n  path,\n  updatedGroupsManager,\n  previousTree,\n  tree,\n  treeDepths,\n  onDuplicatePath,\n  isGroupExpandedByDefault,\n  defaultGroupingExpansionDepth\n}) => {\n  let parentNodeId = GRID_ROOT_GROUP_ID;\n  for (let depth = 0; depth < path.length; depth += 1) {\n    const {\n      key,\n      field\n    } = path[depth];\n    const fieldWithDefaultValue = field ?? '__no_field__';\n    const keyWithDefaultValue = key ?? '__no_key__';\n    const existingNodeIdWithPartialPath = tree[parentNodeId].childrenFromPath?.[fieldWithDefaultValue]?.[keyWithDefaultValue.toString()];\n\n    // When we reach the last step of the path,\n    // We need to create a node for the row passed to `insertNodeInTree`\n    if (depth === path.length - 1) {\n      // If no node matches the full path,\n      // We create a leaf node for the data row.\n      if (existingNodeIdWithPartialPath == null) {\n        const leafNode = {\n          type: 'leaf',\n          id,\n          depth,\n          parent: parentNodeId,\n          groupingKey: key\n        };\n        updatedGroupsManager?.addAction(parentNodeId, 'insertChildren');\n        insertNodeInTree(leafNode, tree, treeDepths, previousTree);\n      } else {\n        const existingNodeWithPartialPath = tree[existingNodeIdWithPartialPath];\n\n        // If we already have an auto-generated group matching the partial path,\n        // We replace it with the node from of data row passed to `insertNodeInTree`\n        if (existingNodeWithPartialPath.type === 'group' && existingNodeWithPartialPath.isAutoGenerated) {\n          updatedGroupsManager?.addAction(parentNodeId, 'removeChildren');\n          updatedGroupsManager?.addAction(parentNodeId, 'insertChildren');\n          updateGroupNodeIdAndAutoGenerated({\n            tree,\n            previousTree,\n            treeDepths,\n            node: existingNodeWithPartialPath,\n            updatedNode: {\n              id,\n              isAutoGenerated: false\n            }\n          });\n        } else {\n          // If we have another row matching the partial path, then there is a duplicate in the dataset.\n          // We warn the user and skip the current row.\n          onDuplicatePath?.(existingNodeIdWithPartialPath, id, path);\n        }\n      }\n    }\n    // For the intermediary steps of the path,\n    // We need to make sure that there is a node matching the partial path.\n    //\n    // If no node matches the partial path,\n    // We create an auto-generated group node.\n    else if (existingNodeIdWithPartialPath == null) {\n      const nodeId = getGroupRowIdFromPath(path.slice(0, depth + 1));\n      const autoGeneratedGroupNode = {\n        type: 'group',\n        id: nodeId,\n        parent: parentNodeId,\n        depth,\n        isAutoGenerated: true,\n        groupingKey: key,\n        groupingField: field,\n        children: [],\n        childrenFromPath: {},\n        childrenExpanded: false\n      };\n      updatedGroupsManager?.addAction(parentNodeId, 'insertChildren');\n      insertNodeInTree(updateGroupDefaultExpansion(autoGeneratedGroupNode, defaultGroupingExpansionDepth, isGroupExpandedByDefault), tree, treeDepths, previousTree);\n      parentNodeId = nodeId;\n    }\n    // For the intermediary steps of the path\n    // If a node matches the partial path, we use it as parent for the next step\n    else {\n      const currentGroupNode = tree[existingNodeIdWithPartialPath];\n\n      // If the node matching the partial path is not a group, we turn it into a group\n      if (currentGroupNode.type !== 'group') {\n        const groupNode = {\n          type: 'group',\n          id: currentGroupNode.id,\n          parent: currentGroupNode.parent,\n          depth: currentGroupNode.depth,\n          isAutoGenerated: false,\n          groupingKey: key,\n          groupingField: field,\n          children: [],\n          childrenFromPath: {},\n          childrenExpanded: false\n        };\n        tree[existingNodeIdWithPartialPath] = updateGroupDefaultExpansion(groupNode, defaultGroupingExpansionDepth, isGroupExpandedByDefault);\n      }\n      parentNodeId = currentGroupNode.id;\n    }\n  }\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}