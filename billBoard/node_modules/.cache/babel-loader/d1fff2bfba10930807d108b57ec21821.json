{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.updateGroupNodeIdAndAutoGenerated = exports.updateGroupDefaultExpansion = exports.removeNodeFromTree = exports.insertNodeInTree = exports.getVisibleRowsLookup = exports.getNodePathInTree = exports.getGroupRowIdFromPath = exports.createUpdatedGroupsManager = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _xDataGrid = require(\"@mui/x-data-grid\");\n\nconst getGroupRowIdFromPath = path => {\n  const pathStr = path.map(groupingCriteria => `${groupingCriteria.field}/${groupingCriteria.key}`).join('-');\n  return `auto-generated-row-${pathStr}`;\n};\n\nexports.getGroupRowIdFromPath = getGroupRowIdFromPath;\n\nconst getNodePathInTree = _ref => {\n  let {\n    id,\n    tree\n  } = _ref;\n  const path = [];\n  let node = tree[id];\n\n  while (node.id !== _xDataGrid.GRID_ROOT_GROUP_ID) {\n    path.push({\n      field: node.type === 'leaf' ? null : node.groupingField,\n      key: node.groupingKey\n    });\n    node = tree[node.parent];\n  }\n\n  path.reverse();\n  return path;\n};\n\nexports.getNodePathInTree = getNodePathInTree;\n\nconst updateGroupDefaultExpansion = (node, defaultGroupingExpansionDepth, isGroupExpandedByDefault) => {\n  let childrenExpanded;\n\n  if (node.id === _xDataGrid.GRID_ROOT_GROUP_ID) {\n    childrenExpanded = true;\n  } else if (isGroupExpandedByDefault) {\n    childrenExpanded = isGroupExpandedByDefault(node);\n  } else {\n    childrenExpanded = defaultGroupingExpansionDepth === -1 || defaultGroupingExpansionDepth > node.depth;\n  }\n\n  node.childrenExpanded = childrenExpanded;\n  return node;\n};\n/**\n * Insert a node in the tree\n */\n\n\nexports.updateGroupDefaultExpansion = updateGroupDefaultExpansion;\n\nconst insertNodeInTree = (node, tree, treeDepths, previousTree) => {\n  // 1. Insert node in the tree.\n  tree[node.id] = node; // 2. Increment the `treeDepths` object for the node's depth.\n\n  treeDepths[node.depth] = (treeDepths[node.depth] ?? 0) + 1; // 3. Register the new node in its parent.\n\n  const parentNode = tree[node.parent];\n\n  if (node.type === 'group' || node.type === 'leaf') {\n    // For groups and leaves,\n    // Register the node from its parents `children` and `childrenFromPath` properties.\n    const groupingFieldName = node.groupingField ?? '__no_field__';\n    const groupingKeyName = node.groupingKey ?? '__no_key__';\n    const groupingField = parentNode.childrenFromPath?.[groupingFieldName];\n\n    if (previousTree !== null && previousTree[parentNode.id] === tree[parentNode.id]) {\n      parentNode.children = [...parentNode.children, node.id];\n    } else {\n      parentNode.children.push(node.id);\n    }\n\n    if (groupingField == null) {\n      parentNode.childrenFromPath[groupingFieldName] = {\n        [groupingKeyName.toString()]: node.id\n      };\n    } else {\n      groupingField[groupingKeyName.toString()] = node.id;\n    }\n  } else if (node.type === 'footer') {\n    // For footers,\n    // Register the node from its parent `footerId` property.\n    parentNode.footerId = node.id;\n  }\n};\n/**\n * Removes a node from the tree\n */\n\n\nexports.insertNodeInTree = insertNodeInTree;\n\nconst removeNodeFromTree = _ref2 => {\n  let {\n    node,\n    tree,\n    treeDepths\n  } = _ref2;\n  // 1. Remove node from the tree.\n  delete tree[node.id]; // 2. Decrement the `treeDepths` object for the node's depth.\n\n  const nodeDepth = node.depth;\n  const currentNodeCount = treeDepths[nodeDepth];\n\n  if (currentNodeCount === 1) {\n    delete treeDepths[nodeDepth];\n  } else {\n    treeDepths[nodeDepth] = currentNodeCount - 1;\n  } // 3. Unregister the new node in its parent.\n\n\n  const parentNode = tree[node.parent]; // For footers,\n  // Unregister the node from its parent `footerId` property.\n\n  if (node.type === 'footer') {\n    tree[parentNode.id] = (0, _extends2.default)({}, parentNode, {\n      footerId: null\n    });\n  } // For groups and leaves,\n  // Unregister the node from its parents `children` and `childrenFromPath` properties.\n  else {\n    const groupingField = node.groupingField ?? '__no_field__';\n    const groupingKey = node.groupingKey ?? '__no_key__'; // TODO rows v6: Can we avoid this linear complexity ?\n\n    const children = parentNode.children.filter(childId => childId !== node.id);\n    const childrenFromPath = parentNode.childrenFromPath;\n    delete childrenFromPath[groupingField][groupingKey.toString()];\n    tree[parentNode.id] = (0, _extends2.default)({}, parentNode, {\n      children,\n      childrenFromPath\n    });\n  }\n};\n/**\n * Updates the `id` and `isAutoGenerated` properties of a group node.\n */\n\n\nexports.removeNodeFromTree = removeNodeFromTree;\n\nconst updateGroupNodeIdAndAutoGenerated = _ref3 => {\n  let {\n    node,\n    updatedNode,\n    previousTree,\n    tree,\n    treeDepths\n  } = _ref3;\n  // 1. Set the new parent for all children from the old group\n  node.children.forEach(childId => {\n    tree[childId] = (0, _extends2.default)({}, tree[childId], {\n      parent: updatedNode.id\n    });\n  }); // 2. Remove the old group from the tree\n\n  removeNodeFromTree({\n    node,\n    tree,\n    treeDepths\n  }); // 3. Add the new group in the tree\n\n  const groupNode = (0, _extends2.default)({}, node, updatedNode);\n  insertNodeInTree(groupNode, tree, treeDepths, previousTree);\n};\n\nexports.updateGroupNodeIdAndAutoGenerated = updateGroupNodeIdAndAutoGenerated;\n\nconst createUpdatedGroupsManager = () => ({\n  value: {},\n\n  addAction(groupId, action) {\n    if (!this.value[groupId]) {\n      this.value[groupId] = {};\n    }\n\n    this.value[groupId][action] = true;\n  }\n\n});\n\nexports.createUpdatedGroupsManager = createUpdatedGroupsManager;\n\nconst getVisibleRowsLookup = _ref4 => {\n  let {\n    tree,\n    filteredRowsLookup\n  } = _ref4;\n\n  if (!filteredRowsLookup) {\n    return {};\n  }\n\n  const visibleRowsLookup = {};\n\n  const handleTreeNode = (node, areAncestorsExpanded) => {\n    const isPassingFiltering = filteredRowsLookup[node.id];\n\n    if (node.type === 'group') {\n      node.children.forEach(childId => {\n        const childNode = tree[childId];\n        handleTreeNode(childNode, areAncestorsExpanded && !!node.childrenExpanded);\n      });\n    }\n\n    visibleRowsLookup[node.id] = isPassingFiltering && areAncestorsExpanded; // TODO rows v6: Should we keep storing the visibility status of footer independently or rely on the group visibility in the selector ?\n\n    if (node.type === 'group' && node.footerId != null) {\n      visibleRowsLookup[node.footerId] = isPassingFiltering && areAncestorsExpanded && !!node.childrenExpanded;\n    }\n  };\n\n  const nodes = Object.values(tree);\n\n  for (let i = 0; i < nodes.length; i += 1) {\n    const node = nodes[i];\n\n    if (node.depth === 0) {\n      handleTreeNode(node, true);\n    }\n  }\n\n  return visibleRowsLookup;\n};\n\nexports.getVisibleRowsLookup = getVisibleRowsLookup;","map":{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","updateGroupNodeIdAndAutoGenerated","updateGroupDefaultExpansion","removeNodeFromTree","insertNodeInTree","getVisibleRowsLookup","getNodePathInTree","getGroupRowIdFromPath","createUpdatedGroupsManager","_extends2","_xDataGrid","path","pathStr","map","groupingCriteria","field","key","join","id","tree","node","GRID_ROOT_GROUP_ID","push","type","groupingField","groupingKey","parent","reverse","defaultGroupingExpansionDepth","isGroupExpandedByDefault","childrenExpanded","depth","treeDepths","previousTree","parentNode","groupingFieldName","groupingKeyName","childrenFromPath","children","toString","footerId","nodeDepth","currentNodeCount","default","filter","childId","updatedNode","forEach","groupNode","addAction","groupId","action","filteredRowsLookup","visibleRowsLookup","handleTreeNode","areAncestorsExpanded","isPassingFiltering","childNode","nodes","values","i","length"],"sources":["C:/Users/kb/node_modules/@mui/x-data-grid-pro/utils/tree/utils.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.updateGroupNodeIdAndAutoGenerated = exports.updateGroupDefaultExpansion = exports.removeNodeFromTree = exports.insertNodeInTree = exports.getVisibleRowsLookup = exports.getNodePathInTree = exports.getGroupRowIdFromPath = exports.createUpdatedGroupsManager = void 0;\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nvar _xDataGrid = require(\"@mui/x-data-grid\");\nconst getGroupRowIdFromPath = path => {\n  const pathStr = path.map(groupingCriteria => `${groupingCriteria.field}/${groupingCriteria.key}`).join('-');\n  return `auto-generated-row-${pathStr}`;\n};\nexports.getGroupRowIdFromPath = getGroupRowIdFromPath;\nconst getNodePathInTree = ({\n  id,\n  tree\n}) => {\n  const path = [];\n  let node = tree[id];\n  while (node.id !== _xDataGrid.GRID_ROOT_GROUP_ID) {\n    path.push({\n      field: node.type === 'leaf' ? null : node.groupingField,\n      key: node.groupingKey\n    });\n    node = tree[node.parent];\n  }\n  path.reverse();\n  return path;\n};\nexports.getNodePathInTree = getNodePathInTree;\nconst updateGroupDefaultExpansion = (node, defaultGroupingExpansionDepth, isGroupExpandedByDefault) => {\n  let childrenExpanded;\n  if (node.id === _xDataGrid.GRID_ROOT_GROUP_ID) {\n    childrenExpanded = true;\n  } else if (isGroupExpandedByDefault) {\n    childrenExpanded = isGroupExpandedByDefault(node);\n  } else {\n    childrenExpanded = defaultGroupingExpansionDepth === -1 || defaultGroupingExpansionDepth > node.depth;\n  }\n  node.childrenExpanded = childrenExpanded;\n  return node;\n};\n\n/**\n * Insert a node in the tree\n */\nexports.updateGroupDefaultExpansion = updateGroupDefaultExpansion;\nconst insertNodeInTree = (node, tree, treeDepths, previousTree) => {\n  // 1. Insert node in the tree.\n  tree[node.id] = node;\n\n  // 2. Increment the `treeDepths` object for the node's depth.\n  treeDepths[node.depth] = (treeDepths[node.depth] ?? 0) + 1;\n\n  // 3. Register the new node in its parent.\n  const parentNode = tree[node.parent];\n  if (node.type === 'group' || node.type === 'leaf') {\n    // For groups and leaves,\n    // Register the node from its parents `children` and `childrenFromPath` properties.\n    const groupingFieldName = node.groupingField ?? '__no_field__';\n    const groupingKeyName = node.groupingKey ?? '__no_key__';\n    const groupingField = parentNode.childrenFromPath?.[groupingFieldName];\n    if (previousTree !== null && previousTree[parentNode.id] === tree[parentNode.id]) {\n      parentNode.children = [...parentNode.children, node.id];\n    } else {\n      parentNode.children.push(node.id);\n    }\n    if (groupingField == null) {\n      parentNode.childrenFromPath[groupingFieldName] = {\n        [groupingKeyName.toString()]: node.id\n      };\n    } else {\n      groupingField[groupingKeyName.toString()] = node.id;\n    }\n  } else if (node.type === 'footer') {\n    // For footers,\n    // Register the node from its parent `footerId` property.\n    parentNode.footerId = node.id;\n  }\n};\n\n/**\n * Removes a node from the tree\n */\nexports.insertNodeInTree = insertNodeInTree;\nconst removeNodeFromTree = ({\n  node,\n  tree,\n  treeDepths\n}) => {\n  // 1. Remove node from the tree.\n  delete tree[node.id];\n\n  // 2. Decrement the `treeDepths` object for the node's depth.\n  const nodeDepth = node.depth;\n  const currentNodeCount = treeDepths[nodeDepth];\n  if (currentNodeCount === 1) {\n    delete treeDepths[nodeDepth];\n  } else {\n    treeDepths[nodeDepth] = currentNodeCount - 1;\n  }\n\n  // 3. Unregister the new node in its parent.\n  const parentNode = tree[node.parent];\n  // For footers,\n  // Unregister the node from its parent `footerId` property.\n  if (node.type === 'footer') {\n    tree[parentNode.id] = (0, _extends2.default)({}, parentNode, {\n      footerId: null\n    });\n  }\n  // For groups and leaves,\n  // Unregister the node from its parents `children` and `childrenFromPath` properties.\n  else {\n    const groupingField = node.groupingField ?? '__no_field__';\n    const groupingKey = node.groupingKey ?? '__no_key__';\n\n    // TODO rows v6: Can we avoid this linear complexity ?\n    const children = parentNode.children.filter(childId => childId !== node.id);\n    const childrenFromPath = parentNode.childrenFromPath;\n    delete childrenFromPath[groupingField][groupingKey.toString()];\n    tree[parentNode.id] = (0, _extends2.default)({}, parentNode, {\n      children,\n      childrenFromPath\n    });\n  }\n};\n\n/**\n * Updates the `id` and `isAutoGenerated` properties of a group node.\n */\nexports.removeNodeFromTree = removeNodeFromTree;\nconst updateGroupNodeIdAndAutoGenerated = ({\n  node,\n  updatedNode,\n  previousTree,\n  tree,\n  treeDepths\n}) => {\n  // 1. Set the new parent for all children from the old group\n  node.children.forEach(childId => {\n    tree[childId] = (0, _extends2.default)({}, tree[childId], {\n      parent: updatedNode.id\n    });\n  });\n\n  // 2. Remove the old group from the tree\n  removeNodeFromTree({\n    node,\n    tree,\n    treeDepths\n  });\n\n  // 3. Add the new group in the tree\n  const groupNode = (0, _extends2.default)({}, node, updatedNode);\n  insertNodeInTree(groupNode, tree, treeDepths, previousTree);\n};\nexports.updateGroupNodeIdAndAutoGenerated = updateGroupNodeIdAndAutoGenerated;\nconst createUpdatedGroupsManager = () => ({\n  value: {},\n  addAction(groupId, action) {\n    if (!this.value[groupId]) {\n      this.value[groupId] = {};\n    }\n    this.value[groupId][action] = true;\n  }\n});\nexports.createUpdatedGroupsManager = createUpdatedGroupsManager;\nconst getVisibleRowsLookup = ({\n  tree,\n  filteredRowsLookup\n}) => {\n  if (!filteredRowsLookup) {\n    return {};\n  }\n  const visibleRowsLookup = {};\n  const handleTreeNode = (node, areAncestorsExpanded) => {\n    const isPassingFiltering = filteredRowsLookup[node.id];\n    if (node.type === 'group') {\n      node.children.forEach(childId => {\n        const childNode = tree[childId];\n        handleTreeNode(childNode, areAncestorsExpanded && !!node.childrenExpanded);\n      });\n    }\n    visibleRowsLookup[node.id] = isPassingFiltering && areAncestorsExpanded;\n\n    // TODO rows v6: Should we keep storing the visibility status of footer independently or rely on the group visibility in the selector ?\n    if (node.type === 'group' && node.footerId != null) {\n      visibleRowsLookup[node.footerId] = isPassingFiltering && areAncestorsExpanded && !!node.childrenExpanded;\n    }\n  };\n  const nodes = Object.values(tree);\n  for (let i = 0; i < nodes.length; i += 1) {\n    const node = nodes[i];\n    if (node.depth === 0) {\n      handleTreeNode(node, true);\n    }\n  }\n  return visibleRowsLookup;\n};\nexports.getVisibleRowsLookup = getVisibleRowsLookup;"],"mappings":"AAAA;;AAEA,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8CAAD,CAApC;;AACAC,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAC3CC,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,iCAAR,GAA4CF,OAAO,CAACG,2BAAR,GAAsCH,OAAO,CAACI,kBAAR,GAA6BJ,OAAO,CAACK,gBAAR,GAA2BL,OAAO,CAACM,oBAAR,GAA+BN,OAAO,CAACO,iBAAR,GAA4BP,OAAO,CAACQ,qBAAR,GAAgCR,OAAO,CAACS,0BAAR,GAAqC,KAAK,CAA/Q;;AACA,IAAIC,SAAS,GAAGd,sBAAsB,CAACC,OAAO,CAAC,gCAAD,CAAR,CAAtC;;AACA,IAAIc,UAAU,GAAGd,OAAO,CAAC,kBAAD,CAAxB;;AACA,MAAMW,qBAAqB,GAAGI,IAAI,IAAI;EACpC,MAAMC,OAAO,GAAGD,IAAI,CAACE,GAAL,CAASC,gBAAgB,IAAK,GAAEA,gBAAgB,CAACC,KAAM,IAAGD,gBAAgB,CAACE,GAAI,EAA/E,EAAkFC,IAAlF,CAAuF,GAAvF,CAAhB;EACA,OAAQ,sBAAqBL,OAAQ,EAArC;AACD,CAHD;;AAIAb,OAAO,CAACQ,qBAAR,GAAgCA,qBAAhC;;AACA,MAAMD,iBAAiB,GAAG,QAGpB;EAAA,IAHqB;IACzBY,EADyB;IAEzBC;EAFyB,CAGrB;EACJ,MAAMR,IAAI,GAAG,EAAb;EACA,IAAIS,IAAI,GAAGD,IAAI,CAACD,EAAD,CAAf;;EACA,OAAOE,IAAI,CAACF,EAAL,KAAYR,UAAU,CAACW,kBAA9B,EAAkD;IAChDV,IAAI,CAACW,IAAL,CAAU;MACRP,KAAK,EAAEK,IAAI,CAACG,IAAL,KAAc,MAAd,GAAuB,IAAvB,GAA8BH,IAAI,CAACI,aADlC;MAERR,GAAG,EAAEI,IAAI,CAACK;IAFF,CAAV;IAIAL,IAAI,GAAGD,IAAI,CAACC,IAAI,CAACM,MAAN,CAAX;EACD;;EACDf,IAAI,CAACgB,OAAL;EACA,OAAOhB,IAAP;AACD,CAfD;;AAgBAZ,OAAO,CAACO,iBAAR,GAA4BA,iBAA5B;;AACA,MAAMJ,2BAA2B,GAAG,CAACkB,IAAD,EAAOQ,6BAAP,EAAsCC,wBAAtC,KAAmE;EACrG,IAAIC,gBAAJ;;EACA,IAAIV,IAAI,CAACF,EAAL,KAAYR,UAAU,CAACW,kBAA3B,EAA+C;IAC7CS,gBAAgB,GAAG,IAAnB;EACD,CAFD,MAEO,IAAID,wBAAJ,EAA8B;IACnCC,gBAAgB,GAAGD,wBAAwB,CAACT,IAAD,CAA3C;EACD,CAFM,MAEA;IACLU,gBAAgB,GAAGF,6BAA6B,KAAK,CAAC,CAAnC,IAAwCA,6BAA6B,GAAGR,IAAI,CAACW,KAAhG;EACD;;EACDX,IAAI,CAACU,gBAAL,GAAwBA,gBAAxB;EACA,OAAOV,IAAP;AACD,CAXD;AAaA;AACA;AACA;;;AACArB,OAAO,CAACG,2BAAR,GAAsCA,2BAAtC;;AACA,MAAME,gBAAgB,GAAG,CAACgB,IAAD,EAAOD,IAAP,EAAaa,UAAb,EAAyBC,YAAzB,KAA0C;EACjE;EACAd,IAAI,CAACC,IAAI,CAACF,EAAN,CAAJ,GAAgBE,IAAhB,CAFiE,CAIjE;;EACAY,UAAU,CAACZ,IAAI,CAACW,KAAN,CAAV,GAAyB,CAACC,UAAU,CAACZ,IAAI,CAACW,KAAN,CAAV,IAA0B,CAA3B,IAAgC,CAAzD,CALiE,CAOjE;;EACA,MAAMG,UAAU,GAAGf,IAAI,CAACC,IAAI,CAACM,MAAN,CAAvB;;EACA,IAAIN,IAAI,CAACG,IAAL,KAAc,OAAd,IAAyBH,IAAI,CAACG,IAAL,KAAc,MAA3C,EAAmD;IACjD;IACA;IACA,MAAMY,iBAAiB,GAAGf,IAAI,CAACI,aAAL,IAAsB,cAAhD;IACA,MAAMY,eAAe,GAAGhB,IAAI,CAACK,WAAL,IAAoB,YAA5C;IACA,MAAMD,aAAa,GAAGU,UAAU,CAACG,gBAAX,GAA8BF,iBAA9B,CAAtB;;IACA,IAAIF,YAAY,KAAK,IAAjB,IAAyBA,YAAY,CAACC,UAAU,CAAChB,EAAZ,CAAZ,KAAgCC,IAAI,CAACe,UAAU,CAAChB,EAAZ,CAAjE,EAAkF;MAChFgB,UAAU,CAACI,QAAX,GAAsB,CAAC,GAAGJ,UAAU,CAACI,QAAf,EAAyBlB,IAAI,CAACF,EAA9B,CAAtB;IACD,CAFD,MAEO;MACLgB,UAAU,CAACI,QAAX,CAAoBhB,IAApB,CAAyBF,IAAI,CAACF,EAA9B;IACD;;IACD,IAAIM,aAAa,IAAI,IAArB,EAA2B;MACzBU,UAAU,CAACG,gBAAX,CAA4BF,iBAA5B,IAAiD;QAC/C,CAACC,eAAe,CAACG,QAAhB,EAAD,GAA8BnB,IAAI,CAACF;MADY,CAAjD;IAGD,CAJD,MAIO;MACLM,aAAa,CAACY,eAAe,CAACG,QAAhB,EAAD,CAAb,GAA4CnB,IAAI,CAACF,EAAjD;IACD;EACF,CAlBD,MAkBO,IAAIE,IAAI,CAACG,IAAL,KAAc,QAAlB,EAA4B;IACjC;IACA;IACAW,UAAU,CAACM,QAAX,GAAsBpB,IAAI,CAACF,EAA3B;EACD;AACF,CAhCD;AAkCA;AACA;AACA;;;AACAnB,OAAO,CAACK,gBAAR,GAA2BA,gBAA3B;;AACA,MAAMD,kBAAkB,GAAG,SAIrB;EAAA,IAJsB;IAC1BiB,IAD0B;IAE1BD,IAF0B;IAG1Ba;EAH0B,CAItB;EACJ;EACA,OAAOb,IAAI,CAACC,IAAI,CAACF,EAAN,CAAX,CAFI,CAIJ;;EACA,MAAMuB,SAAS,GAAGrB,IAAI,CAACW,KAAvB;EACA,MAAMW,gBAAgB,GAAGV,UAAU,CAACS,SAAD,CAAnC;;EACA,IAAIC,gBAAgB,KAAK,CAAzB,EAA4B;IAC1B,OAAOV,UAAU,CAACS,SAAD,CAAjB;EACD,CAFD,MAEO;IACLT,UAAU,CAACS,SAAD,CAAV,GAAwBC,gBAAgB,GAAG,CAA3C;EACD,CAXG,CAaJ;;;EACA,MAAMR,UAAU,GAAGf,IAAI,CAACC,IAAI,CAACM,MAAN,CAAvB,CAdI,CAeJ;EACA;;EACA,IAAIN,IAAI,CAACG,IAAL,KAAc,QAAlB,EAA4B;IAC1BJ,IAAI,CAACe,UAAU,CAAChB,EAAZ,CAAJ,GAAsB,CAAC,GAAGT,SAAS,CAACkC,OAAd,EAAuB,EAAvB,EAA2BT,UAA3B,EAAuC;MAC3DM,QAAQ,EAAE;IADiD,CAAvC,CAAtB;EAGD,CAJD,CAKA;EACA;EANA,KAOK;IACH,MAAMhB,aAAa,GAAGJ,IAAI,CAACI,aAAL,IAAsB,cAA5C;IACA,MAAMC,WAAW,GAAGL,IAAI,CAACK,WAAL,IAAoB,YAAxC,CAFG,CAIH;;IACA,MAAMa,QAAQ,GAAGJ,UAAU,CAACI,QAAX,CAAoBM,MAApB,CAA2BC,OAAO,IAAIA,OAAO,KAAKzB,IAAI,CAACF,EAAvD,CAAjB;IACA,MAAMmB,gBAAgB,GAAGH,UAAU,CAACG,gBAApC;IACA,OAAOA,gBAAgB,CAACb,aAAD,CAAhB,CAAgCC,WAAW,CAACc,QAAZ,EAAhC,CAAP;IACApB,IAAI,CAACe,UAAU,CAAChB,EAAZ,CAAJ,GAAsB,CAAC,GAAGT,SAAS,CAACkC,OAAd,EAAuB,EAAvB,EAA2BT,UAA3B,EAAuC;MAC3DI,QAD2D;MAE3DD;IAF2D,CAAvC,CAAtB;EAID;AACF,CAzCD;AA2CA;AACA;AACA;;;AACAtC,OAAO,CAACI,kBAAR,GAA6BA,kBAA7B;;AACA,MAAMF,iCAAiC,GAAG,SAMpC;EAAA,IANqC;IACzCmB,IADyC;IAEzC0B,WAFyC;IAGzCb,YAHyC;IAIzCd,IAJyC;IAKzCa;EALyC,CAMrC;EACJ;EACAZ,IAAI,CAACkB,QAAL,CAAcS,OAAd,CAAsBF,OAAO,IAAI;IAC/B1B,IAAI,CAAC0B,OAAD,CAAJ,GAAgB,CAAC,GAAGpC,SAAS,CAACkC,OAAd,EAAuB,EAAvB,EAA2BxB,IAAI,CAAC0B,OAAD,CAA/B,EAA0C;MACxDnB,MAAM,EAAEoB,WAAW,CAAC5B;IADoC,CAA1C,CAAhB;EAGD,CAJD,EAFI,CAQJ;;EACAf,kBAAkB,CAAC;IACjBiB,IADiB;IAEjBD,IAFiB;IAGjBa;EAHiB,CAAD,CAAlB,CATI,CAeJ;;EACA,MAAMgB,SAAS,GAAG,CAAC,GAAGvC,SAAS,CAACkC,OAAd,EAAuB,EAAvB,EAA2BvB,IAA3B,EAAiC0B,WAAjC,CAAlB;EACA1C,gBAAgB,CAAC4C,SAAD,EAAY7B,IAAZ,EAAkBa,UAAlB,EAA8BC,YAA9B,CAAhB;AACD,CAxBD;;AAyBAlC,OAAO,CAACE,iCAAR,GAA4CA,iCAA5C;;AACA,MAAMO,0BAA0B,GAAG,OAAO;EACxCR,KAAK,EAAE,EADiC;;EAExCiD,SAAS,CAACC,OAAD,EAAUC,MAAV,EAAkB;IACzB,IAAI,CAAC,KAAKnD,KAAL,CAAWkD,OAAX,CAAL,EAA0B;MACxB,KAAKlD,KAAL,CAAWkD,OAAX,IAAsB,EAAtB;IACD;;IACD,KAAKlD,KAAL,CAAWkD,OAAX,EAAoBC,MAApB,IAA8B,IAA9B;EACD;;AAPuC,CAAP,CAAnC;;AASApD,OAAO,CAACS,0BAAR,GAAqCA,0BAArC;;AACA,MAAMH,oBAAoB,GAAG,SAGvB;EAAA,IAHwB;IAC5Bc,IAD4B;IAE5BiC;EAF4B,CAGxB;;EACJ,IAAI,CAACA,kBAAL,EAAyB;IACvB,OAAO,EAAP;EACD;;EACD,MAAMC,iBAAiB,GAAG,EAA1B;;EACA,MAAMC,cAAc,GAAG,CAAClC,IAAD,EAAOmC,oBAAP,KAAgC;IACrD,MAAMC,kBAAkB,GAAGJ,kBAAkB,CAAChC,IAAI,CAACF,EAAN,CAA7C;;IACA,IAAIE,IAAI,CAACG,IAAL,KAAc,OAAlB,EAA2B;MACzBH,IAAI,CAACkB,QAAL,CAAcS,OAAd,CAAsBF,OAAO,IAAI;QAC/B,MAAMY,SAAS,GAAGtC,IAAI,CAAC0B,OAAD,CAAtB;QACAS,cAAc,CAACG,SAAD,EAAYF,oBAAoB,IAAI,CAAC,CAACnC,IAAI,CAACU,gBAA3C,CAAd;MACD,CAHD;IAID;;IACDuB,iBAAiB,CAACjC,IAAI,CAACF,EAAN,CAAjB,GAA6BsC,kBAAkB,IAAID,oBAAnD,CARqD,CAUrD;;IACA,IAAInC,IAAI,CAACG,IAAL,KAAc,OAAd,IAAyBH,IAAI,CAACoB,QAAL,IAAiB,IAA9C,EAAoD;MAClDa,iBAAiB,CAACjC,IAAI,CAACoB,QAAN,CAAjB,GAAmCgB,kBAAkB,IAAID,oBAAtB,IAA8C,CAAC,CAACnC,IAAI,CAACU,gBAAxF;IACD;EACF,CAdD;;EAeA,MAAM4B,KAAK,GAAG7D,MAAM,CAAC8D,MAAP,CAAcxC,IAAd,CAAd;;EACA,KAAK,IAAIyC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,KAAK,CAACG,MAA1B,EAAkCD,CAAC,IAAI,CAAvC,EAA0C;IACxC,MAAMxC,IAAI,GAAGsC,KAAK,CAACE,CAAD,CAAlB;;IACA,IAAIxC,IAAI,CAACW,KAAL,KAAe,CAAnB,EAAsB;MACpBuB,cAAc,CAAClC,IAAD,EAAO,IAAP,CAAd;IACD;EACF;;EACD,OAAOiC,iBAAP;AACD,CA/BD;;AAgCAtD,OAAO,CAACM,oBAAR,GAA+BA,oBAA/B"},"metadata":{},"sourceType":"script"}