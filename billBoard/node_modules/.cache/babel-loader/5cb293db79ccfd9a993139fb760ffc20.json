{"ast":null,"code":"import { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid';\nimport { getNodePathInTree, getGroupRowIdFromPath, removeNodeFromTree, updateGroupNodeIdAndAutoGenerated } from './utils';\n\nconst removeNodeAndCleanParent = _ref => {\n  let {\n    node,\n    tree,\n    treeDepths,\n    updatedGroupsManager\n  } = _ref;\n  removeNodeFromTree({\n    node,\n    tree,\n    treeDepths\n  });\n\n  if (node.type === 'group' && node.footerId != null) {\n    removeNodeFromTree({\n      node: tree[node.footerId],\n      tree,\n      treeDepths\n    });\n  }\n\n  const parentNode = tree[node.parent];\n  updatedGroupsManager?.addAction(parentNode.id, 'removeChildren');\n  const shouldDeleteGroup = parentNode.id !== GRID_ROOT_GROUP_ID && parentNode.children.length === 0;\n\n  if (shouldDeleteGroup) {\n    if (parentNode.isAutoGenerated) {\n      removeNodeAndCleanParent({\n        node: parentNode,\n        tree,\n        treeDepths\n      });\n    } else {\n      tree[parentNode.id] = {\n        type: 'leaf',\n        id: parentNode.id,\n        depth: parentNode.depth,\n        parent: parentNode.parent,\n        groupingKey: parentNode.groupingKey\n      };\n    }\n  }\n};\n\nconst replaceDataGroupWithAutoGeneratedGroup = _ref2 => {\n  let {\n    node,\n    tree,\n    treeDepths,\n    updatedGroupsManager\n  } = _ref2;\n  updatedGroupsManager?.addAction(node.parent, 'removeChildren');\n  updatedGroupsManager?.addAction(node.parent, 'insertChildren');\n  updateGroupNodeIdAndAutoGenerated({\n    previousTree: null,\n    tree,\n    treeDepths,\n    node,\n    updatedNode: {\n      id: getGroupRowIdFromPath(getNodePathInTree({\n        id: node.id,\n        tree\n      })),\n      isAutoGenerated: true\n    }\n  });\n};\n/**\n * Removed a data row from the tree.\n * If the node is a non-empty group, replace it with an auto-generated group to be able to keep displaying its children.\n * If not, remove it and recursively clean its parent with the following rules:\n * - An empty auto-generated should be removed from the tree\n * - An empty non-auto-generated should be turned into a leaf\n */\n\n\nexport const removeDataRowFromTree = _ref3 => {\n  let {\n    id,\n    tree,\n    treeDepths,\n    updatedGroupsManager\n  } = _ref3;\n  const node = tree[id];\n\n  if (node.type === 'group' && node.children.length > 0) {\n    replaceDataGroupWithAutoGeneratedGroup({\n      node,\n      tree,\n      treeDepths,\n      updatedGroupsManager\n    });\n  } else {\n    removeNodeAndCleanParent({\n      node,\n      tree,\n      treeDepths,\n      updatedGroupsManager\n    });\n  }\n};","map":{"version":3,"names":["GRID_ROOT_GROUP_ID","getNodePathInTree","getGroupRowIdFromPath","removeNodeFromTree","updateGroupNodeIdAndAutoGenerated","removeNodeAndCleanParent","node","tree","treeDepths","updatedGroupsManager","type","footerId","parentNode","parent","addAction","id","shouldDeleteGroup","children","length","isAutoGenerated","depth","groupingKey","replaceDataGroupWithAutoGeneratedGroup","previousTree","updatedNode","removeDataRowFromTree"],"sources":["C:/Users/kb/Downloads/billBoard/billboard/node_modules/@mui/x-data-grid-pro/esm/utils/tree/removeDataRowFromTree.js"],"sourcesContent":["import { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid';\nimport { getNodePathInTree, getGroupRowIdFromPath, removeNodeFromTree, updateGroupNodeIdAndAutoGenerated } from './utils';\nconst removeNodeAndCleanParent = ({\n  node,\n  tree,\n  treeDepths,\n  updatedGroupsManager\n}) => {\n  removeNodeFromTree({\n    node,\n    tree,\n    treeDepths\n  });\n  if (node.type === 'group' && node.footerId != null) {\n    removeNodeFromTree({\n      node: tree[node.footerId],\n      tree,\n      treeDepths\n    });\n  }\n  const parentNode = tree[node.parent];\n  updatedGroupsManager?.addAction(parentNode.id, 'removeChildren');\n  const shouldDeleteGroup = parentNode.id !== GRID_ROOT_GROUP_ID && parentNode.children.length === 0;\n  if (shouldDeleteGroup) {\n    if (parentNode.isAutoGenerated) {\n      removeNodeAndCleanParent({\n        node: parentNode,\n        tree,\n        treeDepths\n      });\n    } else {\n      tree[parentNode.id] = {\n        type: 'leaf',\n        id: parentNode.id,\n        depth: parentNode.depth,\n        parent: parentNode.parent,\n        groupingKey: parentNode.groupingKey\n      };\n    }\n  }\n};\nconst replaceDataGroupWithAutoGeneratedGroup = ({\n  node,\n  tree,\n  treeDepths,\n  updatedGroupsManager\n}) => {\n  updatedGroupsManager?.addAction(node.parent, 'removeChildren');\n  updatedGroupsManager?.addAction(node.parent, 'insertChildren');\n  updateGroupNodeIdAndAutoGenerated({\n    previousTree: null,\n    tree,\n    treeDepths,\n    node,\n    updatedNode: {\n      id: getGroupRowIdFromPath(getNodePathInTree({\n        id: node.id,\n        tree\n      })),\n      isAutoGenerated: true\n    }\n  });\n};\n\n/**\n * Removed a data row from the tree.\n * If the node is a non-empty group, replace it with an auto-generated group to be able to keep displaying its children.\n * If not, remove it and recursively clean its parent with the following rules:\n * - An empty auto-generated should be removed from the tree\n * - An empty non-auto-generated should be turned into a leaf\n */\nexport const removeDataRowFromTree = ({\n  id,\n  tree,\n  treeDepths,\n  updatedGroupsManager\n}) => {\n  const node = tree[id];\n  if (node.type === 'group' && node.children.length > 0) {\n    replaceDataGroupWithAutoGeneratedGroup({\n      node,\n      tree,\n      treeDepths,\n      updatedGroupsManager\n    });\n  } else {\n    removeNodeAndCleanParent({\n      node,\n      tree,\n      treeDepths,\n      updatedGroupsManager\n    });\n  }\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}