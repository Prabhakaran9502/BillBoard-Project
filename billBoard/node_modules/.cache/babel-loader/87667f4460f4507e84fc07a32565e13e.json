{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { applyLocalizedDigits, cleanLeadingZeros, doesSectionFormatHaveLeadingZeros, getDateSectionConfigFromFormatToken, removeLocalizedDigits } from './useField.utils';\n\nconst expandFormat = _ref => {\n  let {\n    utils,\n    format\n  } = _ref;\n  // Expand the provided format\n  let formatExpansionOverflow = 10;\n  let prevFormat = format;\n  let nextFormat = utils.expandFormat(format);\n\n  while (nextFormat !== prevFormat) {\n    prevFormat = nextFormat;\n    nextFormat = utils.expandFormat(prevFormat);\n    formatExpansionOverflow -= 1;\n\n    if (formatExpansionOverflow < 0) {\n      throw new Error('MUI X: The format expansion seems to be in an infinite loop. Please open an issue with the format passed to the picker component.');\n    }\n  }\n\n  return nextFormat;\n};\n\nconst getEscapedPartsFromFormat = _ref2 => {\n  let {\n    utils,\n    expandedFormat\n  } = _ref2;\n  const escapedParts = [];\n  const {\n    start: startChar,\n    end: endChar\n  } = utils.escapedCharacters;\n  const regExp = new RegExp(`(\\\\${startChar}[^\\\\${endChar}]*\\\\${endChar})+`, 'g');\n  let match = null; // eslint-disable-next-line no-cond-assign\n\n  while (match = regExp.exec(expandedFormat)) {\n    escapedParts.push({\n      start: match.index,\n      end: regExp.lastIndex - 1\n    });\n  }\n\n  return escapedParts;\n};\n\nconst getSectionPlaceholder = (utils, timezone, localeText, sectionConfig, sectionFormat) => {\n  switch (sectionConfig.type) {\n    case 'year':\n      {\n        return localeText.fieldYearPlaceholder({\n          digitAmount: utils.formatByString(utils.date(undefined, timezone), sectionFormat).length,\n          format: sectionFormat\n        });\n      }\n\n    case 'month':\n      {\n        return localeText.fieldMonthPlaceholder({\n          contentType: sectionConfig.contentType,\n          format: sectionFormat\n        });\n      }\n\n    case 'day':\n      {\n        return localeText.fieldDayPlaceholder({\n          format: sectionFormat\n        });\n      }\n\n    case 'weekDay':\n      {\n        return localeText.fieldWeekDayPlaceholder({\n          contentType: sectionConfig.contentType,\n          format: sectionFormat\n        });\n      }\n\n    case 'hours':\n      {\n        return localeText.fieldHoursPlaceholder({\n          format: sectionFormat\n        });\n      }\n\n    case 'minutes':\n      {\n        return localeText.fieldMinutesPlaceholder({\n          format: sectionFormat\n        });\n      }\n\n    case 'seconds':\n      {\n        return localeText.fieldSecondsPlaceholder({\n          format: sectionFormat\n        });\n      }\n\n    case 'meridiem':\n      {\n        return localeText.fieldMeridiemPlaceholder({\n          format: sectionFormat\n        });\n      }\n\n    default:\n      {\n        return sectionFormat;\n      }\n  }\n};\n\nconst createSection = _ref3 => {\n  let {\n    utils,\n    timezone,\n    date,\n    shouldRespectLeadingZeros,\n    localeText,\n    localizedDigits,\n    now,\n    token,\n    startSeparator\n  } = _ref3;\n\n  if (token === '') {\n    throw new Error('MUI X: Should not call `commitToken` with an empty token');\n  }\n\n  const sectionConfig = getDateSectionConfigFromFormatToken(utils, token);\n  const hasLeadingZerosInFormat = doesSectionFormatHaveLeadingZeros(utils, timezone, sectionConfig.contentType, sectionConfig.type, token);\n  const hasLeadingZerosInInput = shouldRespectLeadingZeros ? hasLeadingZerosInFormat : sectionConfig.contentType === 'digit';\n  const isValidDate = date != null && utils.isValid(date);\n  let sectionValue = isValidDate ? utils.formatByString(date, token) : '';\n  let maxLength = null;\n\n  if (hasLeadingZerosInInput) {\n    if (hasLeadingZerosInFormat) {\n      maxLength = sectionValue === '' ? utils.formatByString(now, token).length : sectionValue.length;\n    } else {\n      if (sectionConfig.maxLength == null) {\n        throw new Error(`MUI X: The token ${token} should have a 'maxDigitNumber' property on it's adapter`);\n      }\n\n      maxLength = sectionConfig.maxLength;\n\n      if (isValidDate) {\n        sectionValue = applyLocalizedDigits(cleanLeadingZeros(removeLocalizedDigits(sectionValue, localizedDigits), maxLength), localizedDigits);\n      }\n    }\n  }\n\n  return _extends({}, sectionConfig, {\n    format: token,\n    maxLength,\n    value: sectionValue,\n    placeholder: getSectionPlaceholder(utils, timezone, localeText, sectionConfig, token),\n    hasLeadingZerosInFormat,\n    hasLeadingZerosInInput,\n    startSeparator,\n    endSeparator: '',\n    modified: false\n  });\n};\n\nconst buildSections = params => {\n  const {\n    utils,\n    expandedFormat,\n    escapedParts\n  } = params;\n  const now = utils.date(undefined);\n  const sections = [];\n  let startSeparator = ''; // This RegExp tests if the beginning of a string corresponds to a supported token\n\n  const validTokens = Object.keys(utils.formatTokenMap).sort((a, b) => b.length - a.length); // Sort to put longest word first\n\n  const regExpFirstWordInFormat = /^([a-zA-Z]+)/;\n  const regExpWordOnlyComposedOfTokens = new RegExp(`^(${validTokens.join('|')})*$`);\n  const regExpFirstTokenInWord = new RegExp(`^(${validTokens.join('|')})`);\n\n  const getEscapedPartOfCurrentChar = i => escapedParts.find(escapeIndex => escapeIndex.start <= i && escapeIndex.end >= i);\n\n  let i = 0;\n\n  while (i < expandedFormat.length) {\n    const escapedPartOfCurrentChar = getEscapedPartOfCurrentChar(i);\n    const isEscapedChar = escapedPartOfCurrentChar != null;\n    const firstWordInFormat = regExpFirstWordInFormat.exec(expandedFormat.slice(i))?.[1]; // The first word in the format is only composed of tokens.\n    // We extract those tokens to create a new sections.\n\n    if (!isEscapedChar && firstWordInFormat != null && regExpWordOnlyComposedOfTokens.test(firstWordInFormat)) {\n      let word = firstWordInFormat;\n\n      while (word.length > 0) {\n        const firstWord = regExpFirstTokenInWord.exec(word)[1];\n        word = word.slice(firstWord.length);\n        sections.push(createSection(_extends({}, params, {\n          now,\n          token: firstWord,\n          startSeparator\n        })));\n        startSeparator = '';\n      }\n\n      i += firstWordInFormat.length;\n    } // The remaining format does not start with a token,\n    // We take the first character and add it to the current section's end separator.\n    else {\n      const char = expandedFormat[i]; // If we are on the opening or closing character of an escaped part of the format,\n      // Then we ignore this character.\n\n      const isEscapeBoundary = isEscapedChar && escapedPartOfCurrentChar?.start === i || escapedPartOfCurrentChar?.end === i;\n\n      if (!isEscapeBoundary) {\n        if (sections.length === 0) {\n          startSeparator += char;\n        } else {\n          sections[sections.length - 1].endSeparator += char;\n        }\n      }\n\n      i += 1;\n    }\n  }\n\n  if (sections.length === 0 && startSeparator.length > 0) {\n    sections.push({\n      type: 'empty',\n      contentType: 'letter',\n      maxLength: null,\n      format: '',\n      value: '',\n      placeholder: '',\n      hasLeadingZerosInFormat: false,\n      hasLeadingZerosInInput: false,\n      startSeparator,\n      endSeparator: '',\n      modified: false\n    });\n  }\n\n  return sections;\n};\n\nconst postProcessSections = _ref4 => {\n  let {\n    isRtl,\n    formatDensity,\n    sections\n  } = _ref4;\n  return sections.map(section => {\n    const cleanSeparator = separator => {\n      let cleanedSeparator = separator;\n\n      if (isRtl && cleanedSeparator !== null && cleanedSeparator.includes(' ')) {\n        cleanedSeparator = `\\u2069${cleanedSeparator}\\u2066`;\n      }\n\n      if (formatDensity === 'spacious' && ['/', '.', '-'].includes(cleanedSeparator)) {\n        cleanedSeparator = ` ${cleanedSeparator} `;\n      }\n\n      return cleanedSeparator;\n    };\n\n    section.startSeparator = cleanSeparator(section.startSeparator);\n    section.endSeparator = cleanSeparator(section.endSeparator);\n    return section;\n  });\n};\n\nexport const buildSectionsFromFormat = params => {\n  let expandedFormat = expandFormat(params);\n\n  if (params.isRtl && params.enableAccessibleFieldDOMStructure) {\n    expandedFormat = expandedFormat.split(' ').reverse().join(' ');\n  }\n\n  const escapedParts = getEscapedPartsFromFormat(_extends({}, params, {\n    expandedFormat\n  }));\n  const sections = buildSections(_extends({}, params, {\n    expandedFormat,\n    escapedParts\n  }));\n  return postProcessSections(_extends({}, params, {\n    sections\n  }));\n};","map":{"version":3,"names":["_extends","applyLocalizedDigits","cleanLeadingZeros","doesSectionFormatHaveLeadingZeros","getDateSectionConfigFromFormatToken","removeLocalizedDigits","expandFormat","utils","format","formatExpansionOverflow","prevFormat","nextFormat","Error","getEscapedPartsFromFormat","expandedFormat","escapedParts","start","startChar","end","endChar","escapedCharacters","regExp","RegExp","match","exec","push","index","lastIndex","getSectionPlaceholder","timezone","localeText","sectionConfig","sectionFormat","type","fieldYearPlaceholder","digitAmount","formatByString","date","undefined","length","fieldMonthPlaceholder","contentType","fieldDayPlaceholder","fieldWeekDayPlaceholder","fieldHoursPlaceholder","fieldMinutesPlaceholder","fieldSecondsPlaceholder","fieldMeridiemPlaceholder","createSection","shouldRespectLeadingZeros","localizedDigits","now","token","startSeparator","hasLeadingZerosInFormat","hasLeadingZerosInInput","isValidDate","isValid","sectionValue","maxLength","value","placeholder","endSeparator","modified","buildSections","params","sections","validTokens","Object","keys","formatTokenMap","sort","a","b","regExpFirstWordInFormat","regExpWordOnlyComposedOfTokens","join","regExpFirstTokenInWord","getEscapedPartOfCurrentChar","i","find","escapeIndex","escapedPartOfCurrentChar","isEscapedChar","firstWordInFormat","slice","test","word","firstWord","char","isEscapeBoundary","postProcessSections","isRtl","formatDensity","map","section","cleanSeparator","separator","cleanedSeparator","includes","buildSectionsFromFormat","enableAccessibleFieldDOMStructure","split","reverse"],"sources":["C:/Users/kb/Downloads/billBoard/billboard/node_modules/@mui/x-date-pickers/internals/hooks/useField/buildSectionsFromFormat.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { applyLocalizedDigits, cleanLeadingZeros, doesSectionFormatHaveLeadingZeros, getDateSectionConfigFromFormatToken, removeLocalizedDigits } from './useField.utils';\nconst expandFormat = ({\n  utils,\n  format\n}) => {\n  // Expand the provided format\n  let formatExpansionOverflow = 10;\n  let prevFormat = format;\n  let nextFormat = utils.expandFormat(format);\n  while (nextFormat !== prevFormat) {\n    prevFormat = nextFormat;\n    nextFormat = utils.expandFormat(prevFormat);\n    formatExpansionOverflow -= 1;\n    if (formatExpansionOverflow < 0) {\n      throw new Error('MUI X: The format expansion seems to be in an infinite loop. Please open an issue with the format passed to the picker component.');\n    }\n  }\n  return nextFormat;\n};\nconst getEscapedPartsFromFormat = ({\n  utils,\n  expandedFormat\n}) => {\n  const escapedParts = [];\n  const {\n    start: startChar,\n    end: endChar\n  } = utils.escapedCharacters;\n  const regExp = new RegExp(`(\\\\${startChar}[^\\\\${endChar}]*\\\\${endChar})+`, 'g');\n  let match = null;\n  // eslint-disable-next-line no-cond-assign\n  while (match = regExp.exec(expandedFormat)) {\n    escapedParts.push({\n      start: match.index,\n      end: regExp.lastIndex - 1\n    });\n  }\n  return escapedParts;\n};\nconst getSectionPlaceholder = (utils, timezone, localeText, sectionConfig, sectionFormat) => {\n  switch (sectionConfig.type) {\n    case 'year':\n      {\n        return localeText.fieldYearPlaceholder({\n          digitAmount: utils.formatByString(utils.date(undefined, timezone), sectionFormat).length,\n          format: sectionFormat\n        });\n      }\n    case 'month':\n      {\n        return localeText.fieldMonthPlaceholder({\n          contentType: sectionConfig.contentType,\n          format: sectionFormat\n        });\n      }\n    case 'day':\n      {\n        return localeText.fieldDayPlaceholder({\n          format: sectionFormat\n        });\n      }\n    case 'weekDay':\n      {\n        return localeText.fieldWeekDayPlaceholder({\n          contentType: sectionConfig.contentType,\n          format: sectionFormat\n        });\n      }\n    case 'hours':\n      {\n        return localeText.fieldHoursPlaceholder({\n          format: sectionFormat\n        });\n      }\n    case 'minutes':\n      {\n        return localeText.fieldMinutesPlaceholder({\n          format: sectionFormat\n        });\n      }\n    case 'seconds':\n      {\n        return localeText.fieldSecondsPlaceholder({\n          format: sectionFormat\n        });\n      }\n    case 'meridiem':\n      {\n        return localeText.fieldMeridiemPlaceholder({\n          format: sectionFormat\n        });\n      }\n    default:\n      {\n        return sectionFormat;\n      }\n  }\n};\nconst createSection = ({\n  utils,\n  timezone,\n  date,\n  shouldRespectLeadingZeros,\n  localeText,\n  localizedDigits,\n  now,\n  token,\n  startSeparator\n}) => {\n  if (token === '') {\n    throw new Error('MUI X: Should not call `commitToken` with an empty token');\n  }\n  const sectionConfig = getDateSectionConfigFromFormatToken(utils, token);\n  const hasLeadingZerosInFormat = doesSectionFormatHaveLeadingZeros(utils, timezone, sectionConfig.contentType, sectionConfig.type, token);\n  const hasLeadingZerosInInput = shouldRespectLeadingZeros ? hasLeadingZerosInFormat : sectionConfig.contentType === 'digit';\n  const isValidDate = date != null && utils.isValid(date);\n  let sectionValue = isValidDate ? utils.formatByString(date, token) : '';\n  let maxLength = null;\n  if (hasLeadingZerosInInput) {\n    if (hasLeadingZerosInFormat) {\n      maxLength = sectionValue === '' ? utils.formatByString(now, token).length : sectionValue.length;\n    } else {\n      if (sectionConfig.maxLength == null) {\n        throw new Error(`MUI X: The token ${token} should have a 'maxDigitNumber' property on it's adapter`);\n      }\n      maxLength = sectionConfig.maxLength;\n      if (isValidDate) {\n        sectionValue = applyLocalizedDigits(cleanLeadingZeros(removeLocalizedDigits(sectionValue, localizedDigits), maxLength), localizedDigits);\n      }\n    }\n  }\n  return _extends({}, sectionConfig, {\n    format: token,\n    maxLength,\n    value: sectionValue,\n    placeholder: getSectionPlaceholder(utils, timezone, localeText, sectionConfig, token),\n    hasLeadingZerosInFormat,\n    hasLeadingZerosInInput,\n    startSeparator,\n    endSeparator: '',\n    modified: false\n  });\n};\nconst buildSections = params => {\n  const {\n    utils,\n    expandedFormat,\n    escapedParts\n  } = params;\n  const now = utils.date(undefined);\n  const sections = [];\n  let startSeparator = '';\n\n  // This RegExp tests if the beginning of a string corresponds to a supported token\n  const validTokens = Object.keys(utils.formatTokenMap).sort((a, b) => b.length - a.length); // Sort to put longest word first\n\n  const regExpFirstWordInFormat = /^([a-zA-Z]+)/;\n  const regExpWordOnlyComposedOfTokens = new RegExp(`^(${validTokens.join('|')})*$`);\n  const regExpFirstTokenInWord = new RegExp(`^(${validTokens.join('|')})`);\n  const getEscapedPartOfCurrentChar = i => escapedParts.find(escapeIndex => escapeIndex.start <= i && escapeIndex.end >= i);\n  let i = 0;\n  while (i < expandedFormat.length) {\n    const escapedPartOfCurrentChar = getEscapedPartOfCurrentChar(i);\n    const isEscapedChar = escapedPartOfCurrentChar != null;\n    const firstWordInFormat = regExpFirstWordInFormat.exec(expandedFormat.slice(i))?.[1];\n\n    // The first word in the format is only composed of tokens.\n    // We extract those tokens to create a new sections.\n    if (!isEscapedChar && firstWordInFormat != null && regExpWordOnlyComposedOfTokens.test(firstWordInFormat)) {\n      let word = firstWordInFormat;\n      while (word.length > 0) {\n        const firstWord = regExpFirstTokenInWord.exec(word)[1];\n        word = word.slice(firstWord.length);\n        sections.push(createSection(_extends({}, params, {\n          now,\n          token: firstWord,\n          startSeparator\n        })));\n        startSeparator = '';\n      }\n      i += firstWordInFormat.length;\n    }\n    // The remaining format does not start with a token,\n    // We take the first character and add it to the current section's end separator.\n    else {\n      const char = expandedFormat[i];\n\n      // If we are on the opening or closing character of an escaped part of the format,\n      // Then we ignore this character.\n      const isEscapeBoundary = isEscapedChar && escapedPartOfCurrentChar?.start === i || escapedPartOfCurrentChar?.end === i;\n      if (!isEscapeBoundary) {\n        if (sections.length === 0) {\n          startSeparator += char;\n        } else {\n          sections[sections.length - 1].endSeparator += char;\n        }\n      }\n      i += 1;\n    }\n  }\n  if (sections.length === 0 && startSeparator.length > 0) {\n    sections.push({\n      type: 'empty',\n      contentType: 'letter',\n      maxLength: null,\n      format: '',\n      value: '',\n      placeholder: '',\n      hasLeadingZerosInFormat: false,\n      hasLeadingZerosInInput: false,\n      startSeparator,\n      endSeparator: '',\n      modified: false\n    });\n  }\n  return sections;\n};\nconst postProcessSections = ({\n  isRtl,\n  formatDensity,\n  sections\n}) => {\n  return sections.map(section => {\n    const cleanSeparator = separator => {\n      let cleanedSeparator = separator;\n      if (isRtl && cleanedSeparator !== null && cleanedSeparator.includes(' ')) {\n        cleanedSeparator = `\\u2069${cleanedSeparator}\\u2066`;\n      }\n      if (formatDensity === 'spacious' && ['/', '.', '-'].includes(cleanedSeparator)) {\n        cleanedSeparator = ` ${cleanedSeparator} `;\n      }\n      return cleanedSeparator;\n    };\n    section.startSeparator = cleanSeparator(section.startSeparator);\n    section.endSeparator = cleanSeparator(section.endSeparator);\n    return section;\n  });\n};\nexport const buildSectionsFromFormat = params => {\n  let expandedFormat = expandFormat(params);\n  if (params.isRtl && params.enableAccessibleFieldDOMStructure) {\n    expandedFormat = expandedFormat.split(' ').reverse().join(' ');\n  }\n  const escapedParts = getEscapedPartsFromFormat(_extends({}, params, {\n    expandedFormat\n  }));\n  const sections = buildSections(_extends({}, params, {\n    expandedFormat,\n    escapedParts\n  }));\n  return postProcessSections(_extends({}, params, {\n    sections\n  }));\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}