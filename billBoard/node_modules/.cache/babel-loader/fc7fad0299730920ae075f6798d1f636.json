{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { unstable_useEnhancedEffect as useEnhancedEffect, unstable_useEventCallback as useEventCallback } from '@mui/utils';\nimport useLazyRef from '@mui/utils/useLazyRef';\nimport useTimeout from '@mui/utils/useTimeout';\nimport { useTheme } from '@mui/material/styles';\nimport { useGridPrivateApiContext } from '../../utils/useGridPrivateApiContext';\nimport { useGridRootProps } from '../../utils/useGridRootProps';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { useResizeObserver } from '../../utils/useResizeObserver';\nimport { useRunOnce } from '../../utils/useRunOnce';\nimport { gridVisibleColumnDefinitionsSelector, gridVisiblePinnedColumnDefinitionsSelector, gridColumnPositionsSelector, gridHasColSpanSelector } from '../columns/gridColumnsSelector';\nimport { gridDimensionsSelector } from '../dimensions/gridDimensionsSelectors';\nimport { gridPinnedRowsSelector } from '../rows/gridRowsSelector';\nimport { gridFocusCellSelector, gridTabIndexCellSelector } from '../focus/gridFocusStateSelector';\nimport { useGridVisibleRows, getVisibleRows } from '../../utils/useGridVisibleRows';\nimport { useGridApiEventHandler } from '../../utils';\nimport { clamp, range } from '../../../utils/utils';\nimport { selectedIdsLookupSelector } from '../rowSelection/gridRowSelectionSelector';\nimport { gridRowsMetaSelector } from '../rows/gridRowsMetaSelector';\nimport { getFirstNonSpannedColumnToRender } from '../columns/gridColumnsUtils';\nimport { getMinimalContentHeight } from '../rows/gridRowsUtils';\nimport { gridRenderContextSelector, gridVirtualizationEnabledSelector, gridVirtualizationColumnEnabledSelector } from './gridVirtualizationSelectors';\nimport { EMPTY_RENDER_CONTEXT } from './useGridVirtualization';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst MINIMUM_COLUMN_WIDTH = 50;\n\nvar ScrollDirection = /*#__PURE__*/function (ScrollDirection) {\n  ScrollDirection[ScrollDirection[\"NONE\"] = 0] = \"NONE\";\n  ScrollDirection[ScrollDirection[\"UP\"] = 1] = \"UP\";\n  ScrollDirection[ScrollDirection[\"DOWN\"] = 2] = \"DOWN\";\n  ScrollDirection[ScrollDirection[\"LEFT\"] = 3] = \"LEFT\";\n  ScrollDirection[ScrollDirection[\"RIGHT\"] = 4] = \"RIGHT\";\n  return ScrollDirection;\n}(ScrollDirection || {});\n\nconst EMPTY_SCROLL_POSITION = {\n  top: 0,\n  left: 0\n};\nexport const EMPTY_DETAIL_PANELS = Object.freeze(new Map());\n\nconst createScrollCache = (mode, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer) => ({\n  direction: ScrollDirection.NONE,\n  buffer: bufferForDirection(mode, ScrollDirection.NONE, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer)\n});\n\nlet isJSDOM = false;\n\ntry {\n  if (typeof window !== 'undefined') {\n    isJSDOM = /jsdom/.test(window.navigator.userAgent);\n  }\n} catch (_) {\n  /* ignore */\n}\n\nexport const useGridVirtualScroller = () => {\n  const apiRef = useGridPrivateApiContext();\n  const rootProps = useGridRootProps();\n  const visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);\n  const enabled = useGridSelector(apiRef, gridVirtualizationEnabledSelector) && !isJSDOM;\n  const enabledForColumns = useGridSelector(apiRef, gridVirtualizationColumnEnabledSelector) && !isJSDOM;\n  const dimensions = useGridSelector(apiRef, gridDimensionsSelector);\n  const outerSize = dimensions.viewportOuterSize;\n  const pinnedRows = useGridSelector(apiRef, gridPinnedRowsSelector);\n  const pinnedColumns = useGridSelector(apiRef, gridVisiblePinnedColumnDefinitionsSelector);\n  const hasBottomPinnedRows = pinnedRows.bottom.length > 0;\n  const [panels, setPanels] = React.useState(EMPTY_DETAIL_PANELS);\n  const theme = useTheme();\n  const cellFocus = useGridSelector(apiRef, gridFocusCellSelector);\n  const cellTabIndex = useGridSelector(apiRef, gridTabIndexCellSelector);\n  const rowsMeta = useGridSelector(apiRef, gridRowsMetaSelector);\n  const selectedRowsLookup = useGridSelector(apiRef, selectedIdsLookupSelector);\n  const currentPage = useGridVisibleRows(apiRef, rootProps);\n  const gridRootRef = apiRef.current.rootElementRef;\n  const mainRef = apiRef.current.mainElementRef;\n  const scrollerRef = apiRef.current.virtualScrollerRef;\n  const scrollbarVerticalRef = React.useRef(null);\n  const scrollbarHorizontalRef = React.useRef(null);\n  const contentHeight = dimensions.contentSize.height;\n  const columnsTotalWidth = dimensions.columnsTotalWidth;\n  const hasColSpan = useGridSelector(apiRef, gridHasColSpanSelector);\n  useResizeObserver(mainRef, () => apiRef.current.resize());\n  /*\n   * Scroll context logic\n   * ====================\n   * We only render the cells contained in the `renderContext`. However, when the user starts scrolling the grid\n   * in a direction, we want to render as many cells as possible in that direction, as to avoid presenting white\n   * areas if the user scrolls too fast/far and the viewport ends up in a region we haven't rendered yet. To render\n   * more cells, we store some offsets to add to the viewport in `scrollCache.buffer`. Those offsets make the render\n   * context wider in the direction the user is going, but also makes the buffer around the viewport `0` for the\n   * dimension (horizontal or vertical) in which the user is not scrolling. So if the normal viewport is 8 columns\n   * wide, with a 1 column buffer (10 columns total), then we want it to be exactly 8 columns wide during vertical\n   * scroll.\n   * However, we don't want the rows in the old context to re-render from e.g. 10 columns to 8 columns, because that's\n   * work that's not necessary. Thus we store the context at the start of the scroll in `frozenContext`, and the rows\n   * that are part of this old context will keep their same render context as to avoid re-rendering.\n   */\n\n  const scrollPosition = React.useRef(EMPTY_SCROLL_POSITION);\n  const previousContextScrollPosition = React.useRef(EMPTY_SCROLL_POSITION);\n  const previousRowContext = React.useRef(EMPTY_RENDER_CONTEXT);\n  const renderContext = useGridSelector(apiRef, gridRenderContextSelector);\n  const scrollTimeout = useTimeout();\n  const frozenContext = React.useRef(undefined);\n  const scrollCache = useLazyRef(() => createScrollCache(theme.direction, rootProps.rowBufferPx, rootProps.columnBufferPx, dimensions.rowHeight * 15, MINIMUM_COLUMN_WIDTH * 6)).current;\n  const focusedCell = {\n    rowIndex: React.useMemo(() => cellFocus ? currentPage.rows.findIndex(row => row.id === cellFocus.id) : -1, [cellFocus, currentPage.rows]),\n    columnIndex: React.useMemo(() => cellFocus ? visibleColumns.findIndex(column => column.field === cellFocus.field) : -1, [cellFocus, visibleColumns])\n  };\n  const updateRenderContext = React.useCallback(nextRenderContext => {\n    if (areRenderContextsEqual(nextRenderContext, apiRef.current.state.virtualization.renderContext)) {\n      return;\n    }\n\n    const didRowsIntervalChange = nextRenderContext.firstRowIndex !== previousRowContext.current.firstRowIndex || nextRenderContext.lastRowIndex !== previousRowContext.current.lastRowIndex;\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        virtualization: _extends({}, state.virtualization, {\n          renderContext: nextRenderContext\n        })\n      });\n    }); // The lazy-loading hook is listening to `renderedRowsIntervalChange`,\n    // but only does something if the dimensions are also available.\n    // So we wait until we have valid dimensions before publishing the first event.\n\n    if (dimensions.isReady && didRowsIntervalChange) {\n      previousRowContext.current = nextRenderContext;\n      apiRef.current.publishEvent('renderedRowsIntervalChange', nextRenderContext);\n    }\n\n    previousContextScrollPosition.current = scrollPosition.current;\n  }, [apiRef, dimensions.isReady]);\n\n  const triggerUpdateRenderContext = () => {\n    const newScroll = {\n      top: scrollerRef.current.scrollTop,\n      left: scrollerRef.current.scrollLeft\n    };\n    const dx = newScroll.left - scrollPosition.current.left;\n    const dy = newScroll.top - scrollPosition.current.top;\n    const isScrolling = dx !== 0 || dy !== 0;\n    scrollPosition.current = newScroll;\n    const direction = isScrolling ? directionForDelta(dx, dy) : ScrollDirection.NONE; // Since previous render, we have scrolled...\n\n    const rowScroll = Math.abs(scrollPosition.current.top - previousContextScrollPosition.current.top);\n    const columnScroll = Math.abs(scrollPosition.current.left - previousContextScrollPosition.current.left); // PERF: use the computed minimum column width instead of a static one\n\n    const didCrossThreshold = rowScroll >= dimensions.rowHeight || columnScroll >= MINIMUM_COLUMN_WIDTH;\n    const didChangeDirection = scrollCache.direction !== direction;\n    const shouldUpdate = didCrossThreshold || didChangeDirection;\n\n    if (!shouldUpdate) {\n      return renderContext;\n    } // Render a new context\n\n\n    if (didChangeDirection) {\n      switch (direction) {\n        case ScrollDirection.NONE:\n        case ScrollDirection.LEFT:\n        case ScrollDirection.RIGHT:\n          frozenContext.current = undefined;\n          break;\n\n        default:\n          frozenContext.current = renderContext;\n          break;\n      }\n    }\n\n    scrollCache.direction = direction;\n    scrollCache.buffer = bufferForDirection(theme.direction, direction, rootProps.rowBufferPx, rootProps.columnBufferPx, dimensions.rowHeight * 15, MINIMUM_COLUMN_WIDTH * 6);\n    const inputs = inputsSelector(apiRef, rootProps, enabled, enabledForColumns);\n    const nextRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache); // Prevents batching render context changes\n\n    ReactDOM.flushSync(() => {\n      updateRenderContext(nextRenderContext);\n    });\n    scrollTimeout.start(1000, triggerUpdateRenderContext);\n    return nextRenderContext;\n  };\n\n  const forceUpdateRenderContext = () => {\n    const inputs = inputsSelector(apiRef, rootProps, enabled, enabledForColumns);\n    const nextRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache);\n    updateRenderContext(nextRenderContext);\n  };\n\n  const handleScroll = useEventCallback(event => {\n    const {\n      scrollTop,\n      scrollLeft\n    } = event.currentTarget; // On iOS and macOS, negative offsets are possible when swiping past the start\n\n    if (scrollTop < 0) {\n      return;\n    }\n\n    if (theme.direction === 'ltr') {\n      if (scrollLeft < 0) {\n        return;\n      }\n    }\n\n    if (theme.direction === 'rtl') {\n      if (scrollLeft > 0) {\n        return;\n      }\n    }\n\n    const nextRenderContext = triggerUpdateRenderContext();\n    apiRef.current.publishEvent('scrollPositionChange', {\n      top: scrollTop,\n      left: scrollLeft,\n      renderContext: nextRenderContext\n    });\n  });\n  const handleWheel = useEventCallback(event => {\n    apiRef.current.publishEvent('virtualScrollerWheel', {}, event);\n  });\n  const handleTouchMove = useEventCallback(event => {\n    apiRef.current.publishEvent('virtualScrollerTouchMove', {}, event);\n  });\n\n  const getRows = function () {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!params.rows && !currentPage.range) {\n      return [];\n    }\n\n    const baseRenderContext = params.renderContext ?? renderContext;\n    const isLastSection = !hasBottomPinnedRows && params.position === undefined || hasBottomPinnedRows && params.position === 'bottom';\n    const isPinnedSection = params.position !== undefined;\n    let rowIndexOffset; // FIXME: Why is the switch check exhaustiveness not validated with typescript-eslint?\n    // eslint-disable-next-line default-case\n\n    switch (params.position) {\n      case 'top':\n        rowIndexOffset = 0;\n        break;\n\n      case 'bottom':\n        rowIndexOffset = pinnedRows.top.length + currentPage.rows.length;\n        break;\n\n      case undefined:\n        rowIndexOffset = pinnedRows.top.length;\n        break;\n    }\n\n    const rowModels = params.rows ?? currentPage.rows;\n    const firstRowToRender = baseRenderContext.firstRowIndex;\n    const lastRowToRender = Math.min(baseRenderContext.lastRowIndex, rowModels.length);\n    const rowIndexes = params.rows ? range(0, params.rows.length) : range(firstRowToRender, lastRowToRender);\n    let virtualRowIndex = -1;\n\n    if (!isPinnedSection && focusedCell.rowIndex !== -1) {\n      if (focusedCell.rowIndex < firstRowToRender) {\n        virtualRowIndex = focusedCell.rowIndex;\n        rowIndexes.unshift(virtualRowIndex);\n      }\n\n      if (focusedCell.rowIndex >= lastRowToRender) {\n        virtualRowIndex = focusedCell.rowIndex;\n        rowIndexes.push(virtualRowIndex);\n      }\n    }\n\n    const rows = [];\n    const rowProps = rootProps.slotProps?.row;\n    const columnPositions = gridColumnPositionsSelector(apiRef);\n    rowIndexes.forEach(rowIndexInPage => {\n      const {\n        id,\n        model\n      } = rowModels[rowIndexInPage]; // NOTE: This is an expensive feature, the colSpan code could be optimized.\n\n      if (hasColSpan) {\n        const minFirstColumn = pinnedColumns.left.length;\n        const maxLastColumn = visibleColumns.length - pinnedColumns.right.length;\n        apiRef.current.calculateColSpan({\n          rowId: id,\n          minFirstColumn,\n          maxLastColumn,\n          columns: visibleColumns\n        });\n\n        if (pinnedColumns.left.length > 0) {\n          apiRef.current.calculateColSpan({\n            rowId: id,\n            minFirstColumn: 0,\n            maxLastColumn: pinnedColumns.left.length,\n            columns: visibleColumns\n          });\n        }\n\n        if (pinnedColumns.right.length > 0) {\n          apiRef.current.calculateColSpan({\n            rowId: id,\n            minFirstColumn: visibleColumns.length - pinnedColumns.right.length,\n            maxLastColumn: visibleColumns.length,\n            columns: visibleColumns\n          });\n        }\n      }\n\n      const hasFocus = cellFocus?.id === id;\n      const baseRowHeight = !apiRef.current.rowHasAutoHeight(id) ? apiRef.current.unstable_getRowHeight(id) : 'auto';\n      let isSelected;\n\n      if (selectedRowsLookup[id] == null) {\n        isSelected = false;\n      } else {\n        isSelected = apiRef.current.isRowSelectable(id);\n      }\n\n      let isFirstVisible = false;\n\n      if (params.position === undefined) {\n        isFirstVisible = rowIndexInPage === 0;\n      }\n\n      let isLastVisible = false;\n\n      if (isLastSection) {\n        if (!isPinnedSection) {\n          const lastIndex = currentPage.rows.length - 1;\n          const isLastVisibleRowIndex = rowIndexInPage === lastIndex;\n\n          if (isLastVisibleRowIndex) {\n            isLastVisible = true;\n          }\n        } else {\n          isLastVisible = rowIndexInPage === rowModels.length - 1;\n        }\n      }\n\n      const isVirtualRow = rowIndexInPage === virtualRowIndex;\n      const isNotVisible = isVirtualRow;\n      let tabbableCell = null;\n\n      if (cellTabIndex !== null && cellTabIndex.id === id) {\n        const cellParams = apiRef.current.getCellParams(id, cellTabIndex.field);\n        tabbableCell = cellParams.cellMode === 'view' ? cellTabIndex.field : null;\n      }\n\n      let currentRenderContext = baseRenderContext;\n\n      if (!isPinnedSection && frozenContext.current && rowIndexInPage >= frozenContext.current.firstRowIndex && rowIndexInPage < frozenContext.current.lastRowIndex) {\n        currentRenderContext = frozenContext.current;\n      }\n\n      const offsetLeft = computeOffsetLeft(columnPositions, currentRenderContext, theme.direction, pinnedColumns.left.length);\n      const rowIndex = (currentPage?.range?.firstRowIndex || 0) + rowIndexOffset + rowIndexInPage;\n      rows.push( /*#__PURE__*/_jsx(rootProps.slots.row, _extends({\n        row: model,\n        rowId: id,\n        index: rowIndex,\n        selected: isSelected,\n        offsetTop: params.rows ? undefined : rowsMeta.positions[rowIndexInPage],\n        offsetLeft: offsetLeft,\n        dimensions: dimensions,\n        rowHeight: baseRowHeight,\n        tabbableCell: tabbableCell,\n        pinnedColumns: pinnedColumns,\n        visibleColumns: visibleColumns,\n        renderContext: currentRenderContext,\n        focusedColumnIndex: hasFocus ? focusedCell.columnIndex : undefined,\n        isFirstVisible: isFirstVisible,\n        isLastVisible: isLastVisible,\n        isNotVisible: isNotVisible\n      }, rowProps), id));\n\n      if (isNotVisible) {\n        return;\n      }\n\n      const panel = panels.get(id);\n\n      if (panel) {\n        rows.push(panel);\n      }\n\n      if (isLastVisible) {\n        rows.push(apiRef.current.getInfiniteLoadingTriggerElement?.({\n          lastRowId: id\n        }));\n      }\n    });\n    return rows;\n  };\n\n  const needsHorizontalScrollbar = outerSize.width && columnsTotalWidth >= outerSize.width;\n  const scrollerStyle = React.useMemo(() => ({\n    overflowX: !needsHorizontalScrollbar ? 'hidden' : undefined,\n    overflowY: rootProps.autoHeight ? 'hidden' : undefined\n  }), [needsHorizontalScrollbar, rootProps.autoHeight]);\n  const contentSize = React.useMemo(() => {\n    // In cases where the columns exceed the available width,\n    // the horizontal scrollbar should be shown even when there're no rows.\n    // Keeping 1px as minimum height ensures that the scrollbar will visible if necessary.\n    const height = Math.max(contentHeight, 1);\n    const size = {\n      width: needsHorizontalScrollbar ? columnsTotalWidth : 'auto',\n      height\n    };\n\n    if (rootProps.autoHeight) {\n      if (currentPage.rows.length === 0) {\n        size.height = getMinimalContentHeight(apiRef); // Give room to show the overlay when there no rows.\n      } else {\n        size.height = contentHeight;\n      }\n    }\n\n    return size;\n  }, [apiRef, columnsTotalWidth, contentHeight, needsHorizontalScrollbar, rootProps.autoHeight, currentPage.rows.length]);\n  React.useEffect(() => {\n    apiRef.current.publishEvent('virtualScrollerContentSizeChange');\n  }, [apiRef, contentSize]);\n  useEnhancedEffect(() => {\n    // FIXME: Is this really necessary?\n    apiRef.current.resize();\n  }, [apiRef, rowsMeta.currentPageTotalHeight]);\n  useEnhancedEffect(() => {\n    if (enabled) {\n      // TODO a scroll reset should not be necessary\n      scrollerRef.current.scrollLeft = 0;\n      scrollerRef.current.scrollTop = 0;\n    }\n  }, [enabled, gridRootRef, scrollerRef]);\n  useRunOnce(outerSize.width !== 0, () => {\n    const inputs = inputsSelector(apiRef, rootProps, enabled, enabledForColumns);\n    const initialRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache);\n    updateRenderContext(initialRenderContext);\n    apiRef.current.publishEvent('scrollPositionChange', {\n      top: scrollPosition.current.top,\n      left: scrollPosition.current.left,\n      renderContext: initialRenderContext\n    });\n  });\n  apiRef.current.register('private', {\n    updateRenderContext: forceUpdateRenderContext\n  });\n  useGridApiEventHandler(apiRef, 'columnsChange', forceUpdateRenderContext);\n  useGridApiEventHandler(apiRef, 'filteredRowsSet', forceUpdateRenderContext);\n  useGridApiEventHandler(apiRef, 'rowExpansionChange', forceUpdateRenderContext);\n  return {\n    renderContext,\n    setPanels,\n    getRows,\n    getContainerProps: () => ({\n      ref: mainRef\n    }),\n    getScrollerProps: () => ({\n      ref: scrollerRef,\n      tabIndex: -1,\n      onScroll: handleScroll,\n      onWheel: handleWheel,\n      onTouchMove: handleTouchMove,\n      style: scrollerStyle,\n      role: 'presentation'\n    }),\n    getContentProps: () => ({\n      style: contentSize,\n      role: 'presentation'\n    }),\n    getRenderZoneProps: () => ({\n      role: 'rowgroup'\n    }),\n    getScrollbarVerticalProps: () => ({\n      ref: scrollbarVerticalRef,\n      role: 'presentation'\n    }),\n    getScrollbarHorizontalProps: () => ({\n      ref: scrollbarHorizontalRef,\n      role: 'presentation'\n    })\n  };\n};\n\nfunction inputsSelector(apiRef, rootProps, enabled, enabledForColumns) {\n  const dimensions = gridDimensionsSelector(apiRef.current.state);\n  const currentPage = getVisibleRows(apiRef, rootProps);\n  const visibleColumns = gridVisibleColumnDefinitionsSelector(apiRef);\n  const lastRowId = apiRef.current.state.rows.dataRowIds.at(-1);\n  const lastColumn = visibleColumns.at(-1);\n  return {\n    enabled,\n    enabledForColumns,\n    apiRef,\n    autoHeight: rootProps.autoHeight,\n    rowBufferPx: rootProps.rowBufferPx,\n    columnBufferPx: rootProps.columnBufferPx,\n    leftPinnedWidth: dimensions.leftPinnedWidth,\n    columnsTotalWidth: dimensions.columnsTotalWidth,\n    viewportInnerWidth: dimensions.viewportInnerSize.width,\n    viewportInnerHeight: dimensions.viewportInnerSize.height,\n    lastRowHeight: lastRowId !== undefined ? apiRef.current.unstable_getRowHeight(lastRowId) : 0,\n    lastColumnWidth: lastColumn?.computedWidth ?? 0,\n    rowsMeta: gridRowsMetaSelector(apiRef.current.state),\n    columnPositions: gridColumnPositionsSelector(apiRef),\n    rows: currentPage.rows,\n    range: currentPage.range,\n    pinnedColumns: gridVisiblePinnedColumnDefinitionsSelector(apiRef),\n    visibleColumns\n  };\n}\n\nfunction computeRenderContext(inputs, scrollPosition, scrollCache) {\n  let renderContext;\n\n  if (!inputs.enabled) {\n    renderContext = {\n      firstRowIndex: 0,\n      lastRowIndex: inputs.rows.length,\n      firstColumnIndex: 0,\n      lastColumnIndex: inputs.visibleColumns.length\n    };\n  } else {\n    const {\n      top,\n      left\n    } = scrollPosition;\n    const realLeft = Math.abs(left) + inputs.leftPinnedWidth; // Clamp the value because the search may return an index out of bounds.\n    // In the last index, this is not needed because Array.slice doesn't include it.\n\n    const firstRowIndex = Math.min(getNearestIndexToRender(inputs, top, {\n      atStart: true,\n      lastPosition: inputs.rowsMeta.positions[inputs.rowsMeta.positions.length - 1] + inputs.lastRowHeight\n    }), inputs.rowsMeta.positions.length - 1);\n    const lastRowIndex = inputs.autoHeight ? firstRowIndex + inputs.rows.length : getNearestIndexToRender(inputs, top + inputs.viewportInnerHeight);\n    let firstColumnIndex = 0;\n    let lastColumnIndex = inputs.columnPositions.length;\n\n    if (inputs.enabledForColumns) {\n      let hasRowWithAutoHeight = false;\n      const [firstRowToRender, lastRowToRender] = getIndexesToRender({\n        firstIndex: firstRowIndex,\n        lastIndex: lastRowIndex,\n        minFirstIndex: 0,\n        maxLastIndex: inputs.rows.length,\n        bufferBefore: scrollCache.buffer.rowBefore,\n        bufferAfter: scrollCache.buffer.rowAfter,\n        positions: inputs.rowsMeta.positions,\n        lastSize: inputs.lastRowHeight\n      });\n\n      for (let i = firstRowToRender; i < lastRowToRender && !hasRowWithAutoHeight; i += 1) {\n        const row = inputs.rows[i];\n        hasRowWithAutoHeight = inputs.apiRef.current.rowHasAutoHeight(row.id);\n      }\n\n      if (!hasRowWithAutoHeight) {\n        firstColumnIndex = binarySearch(realLeft, inputs.columnPositions, {\n          atStart: true,\n          lastPosition: inputs.columnsTotalWidth\n        });\n        lastColumnIndex = binarySearch(realLeft + inputs.viewportInnerWidth, inputs.columnPositions);\n      }\n    }\n\n    renderContext = {\n      firstRowIndex,\n      lastRowIndex,\n      firstColumnIndex,\n      lastColumnIndex\n    };\n  }\n\n  const actualRenderContext = deriveRenderContext(inputs, renderContext, scrollCache);\n  return actualRenderContext;\n}\n\nfunction getNearestIndexToRender(inputs, offset, options) {\n  const lastMeasuredIndexRelativeToAllRows = inputs.apiRef.current.getLastMeasuredRowIndex();\n  let allRowsMeasured = lastMeasuredIndexRelativeToAllRows === Infinity;\n\n  if (inputs.range?.lastRowIndex && !allRowsMeasured) {\n    // Check if all rows in this page are already measured\n    allRowsMeasured = lastMeasuredIndexRelativeToAllRows >= inputs.range.lastRowIndex;\n  }\n\n  const lastMeasuredIndexRelativeToCurrentPage = clamp(lastMeasuredIndexRelativeToAllRows - (inputs.range?.firstRowIndex || 0), 0, inputs.rowsMeta.positions.length);\n\n  if (allRowsMeasured || inputs.rowsMeta.positions[lastMeasuredIndexRelativeToCurrentPage] >= offset) {\n    // If all rows were measured (when no row has \"auto\" as height) or all rows before the offset\n    // were measured, then use a binary search because it's faster.\n    return binarySearch(offset, inputs.rowsMeta.positions, options);\n  } // Otherwise, use an exponential search.\n  // If rows have \"auto\" as height, their positions will be based on estimated heights.\n  // In this case, we can skip several steps until we find a position higher than the offset.\n  // Inspired by https://github.com/bvaughn/react-virtualized/blob/master/source/Grid/utils/CellSizeAndPositionManager.js\n\n\n  return exponentialSearch(offset, inputs.rowsMeta.positions, lastMeasuredIndexRelativeToCurrentPage, options);\n}\n/**\n * Accepts as input a raw render context (the area visible in the viewport) and adds\n * computes the actual render context based on pinned elements, buffer dimensions and\n * spanning.\n */\n\n\nfunction deriveRenderContext(inputs, nextRenderContext, scrollCache) {\n  const [firstRowToRender, lastRowToRender] = getIndexesToRender({\n    firstIndex: nextRenderContext.firstRowIndex,\n    lastIndex: nextRenderContext.lastRowIndex,\n    minFirstIndex: 0,\n    maxLastIndex: inputs.rows.length,\n    bufferBefore: scrollCache.buffer.rowBefore,\n    bufferAfter: scrollCache.buffer.rowAfter,\n    positions: inputs.rowsMeta.positions,\n    lastSize: inputs.lastRowHeight\n  });\n  const [initialFirstColumnToRender, lastColumnToRender] = getIndexesToRender({\n    firstIndex: nextRenderContext.firstColumnIndex,\n    lastIndex: nextRenderContext.lastColumnIndex,\n    minFirstIndex: inputs.pinnedColumns.left.length,\n    maxLastIndex: inputs.visibleColumns.length - inputs.pinnedColumns.right.length,\n    bufferBefore: scrollCache.buffer.columnBefore,\n    bufferAfter: scrollCache.buffer.columnAfter,\n    positions: inputs.columnPositions,\n    lastSize: inputs.lastColumnWidth\n  });\n  const firstColumnToRender = getFirstNonSpannedColumnToRender({\n    firstColumnToRender: initialFirstColumnToRender,\n    apiRef: inputs.apiRef,\n    firstRowToRender,\n    lastRowToRender,\n    visibleRows: inputs.rows\n  });\n  return {\n    firstRowIndex: firstRowToRender,\n    lastRowIndex: lastRowToRender,\n    firstColumnIndex: firstColumnToRender,\n    lastColumnIndex: lastColumnToRender\n  };\n}\n/**\n * Use binary search to avoid looping through all possible positions.\n * The `options.atStart` provides the possibility to match for the first element that\n * intersects the screen, even if said element's start position is before `offset`. In\n * other words, we search for `offset + width`.\n */\n\n\nfunction binarySearch(offset, positions) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n  let sliceStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let sliceEnd = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : positions.length;\n\n  if (positions.length <= 0) {\n    return -1;\n  }\n\n  if (sliceStart >= sliceEnd) {\n    return sliceStart;\n  }\n\n  const pivot = sliceStart + Math.floor((sliceEnd - sliceStart) / 2);\n  const position = positions[pivot];\n  let isBefore;\n\n  if (options?.atStart) {\n    const width = (pivot === positions.length - 1 ? options.lastPosition : positions[pivot + 1]) - position;\n    isBefore = offset - width < position;\n  } else {\n    isBefore = offset <= position;\n  }\n\n  return isBefore ? binarySearch(offset, positions, options, sliceStart, pivot) : binarySearch(offset, positions, options, pivot + 1, sliceEnd);\n}\n\nfunction exponentialSearch(offset, positions, index) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n  let interval = 1;\n\n  while (index < positions.length && Math.abs(positions[index]) < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return binarySearch(offset, positions, options, Math.floor(index / 2), Math.min(index, positions.length));\n}\n\nfunction getIndexesToRender(_ref) {\n  let {\n    firstIndex,\n    lastIndex,\n    bufferBefore,\n    bufferAfter,\n    minFirstIndex,\n    maxLastIndex,\n    positions,\n    lastSize\n  } = _ref;\n  const firstPosition = positions[firstIndex] - bufferBefore;\n  const lastPosition = positions[lastIndex] + bufferAfter;\n  const firstIndexPadded = binarySearch(firstPosition, positions, {\n    atStart: true,\n    lastPosition: positions[positions.length - 1] + lastSize\n  });\n  const lastIndexPadded = binarySearch(lastPosition, positions);\n  return [clamp(firstIndexPadded, minFirstIndex, maxLastIndex), clamp(lastIndexPadded, minFirstIndex, maxLastIndex)];\n}\n\nexport function areRenderContextsEqual(context1, context2) {\n  if (context1 === context2) {\n    return true;\n  }\n\n  return context1.firstRowIndex === context2.firstRowIndex && context1.lastRowIndex === context2.lastRowIndex && context1.firstColumnIndex === context2.firstColumnIndex && context1.lastColumnIndex === context2.lastColumnIndex;\n}\nexport function computeOffsetLeft(columnPositions, renderContext, direction, pinnedLeftLength) {\n  const factor = direction === 'ltr' ? 1 : -1;\n  const left = factor * (columnPositions[renderContext.firstColumnIndex] ?? 0) - (columnPositions[pinnedLeftLength] ?? 0);\n  return Math.abs(left);\n}\n\nfunction directionForDelta(dx, dy) {\n  if (dx === 0 && dy === 0) {\n    return ScrollDirection.NONE;\n  }\n  /* eslint-disable */\n\n\n  if (Math.abs(dy) >= Math.abs(dx)) {\n    if (dy > 0) {\n      return ScrollDirection.DOWN;\n    } else {\n      return ScrollDirection.UP;\n    }\n  } else {\n    if (dx > 0) {\n      return ScrollDirection.RIGHT;\n    } else {\n      return ScrollDirection.LEFT;\n    }\n  }\n  /* eslint-enable */\n\n}\n\nfunction bufferForDirection(mode, direction, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer) {\n  if (mode === 'rtl') {\n    switch (direction) {\n      case ScrollDirection.LEFT:\n        direction = ScrollDirection.RIGHT;\n        break;\n\n      case ScrollDirection.RIGHT:\n        direction = ScrollDirection.LEFT;\n        break;\n\n      default:\n    }\n  }\n\n  switch (direction) {\n    case ScrollDirection.NONE:\n      return {\n        rowAfter: rowBufferPx,\n        rowBefore: rowBufferPx,\n        columnAfter: columnBufferPx,\n        columnBefore: columnBufferPx\n      };\n\n    case ScrollDirection.LEFT:\n      return {\n        rowAfter: 0,\n        rowBefore: 0,\n        columnAfter: 0,\n        columnBefore: horizontalBuffer\n      };\n\n    case ScrollDirection.RIGHT:\n      return {\n        rowAfter: 0,\n        rowBefore: 0,\n        columnAfter: horizontalBuffer,\n        columnBefore: 0\n      };\n\n    case ScrollDirection.UP:\n      return {\n        rowAfter: 0,\n        rowBefore: verticalBuffer,\n        columnAfter: 0,\n        columnBefore: 0\n      };\n\n    case ScrollDirection.DOWN:\n      return {\n        rowAfter: verticalBuffer,\n        rowBefore: 0,\n        columnAfter: 0,\n        columnBefore: 0\n      };\n\n    default:\n      // eslint unable to figure out enum exhaustiveness\n      throw new Error('unreachable');\n  }\n}","map":{"version":3,"names":["_extends","React","ReactDOM","unstable_useEnhancedEffect","useEnhancedEffect","unstable_useEventCallback","useEventCallback","useLazyRef","useTimeout","useTheme","useGridPrivateApiContext","useGridRootProps","useGridSelector","useResizeObserver","useRunOnce","gridVisibleColumnDefinitionsSelector","gridVisiblePinnedColumnDefinitionsSelector","gridColumnPositionsSelector","gridHasColSpanSelector","gridDimensionsSelector","gridPinnedRowsSelector","gridFocusCellSelector","gridTabIndexCellSelector","useGridVisibleRows","getVisibleRows","useGridApiEventHandler","clamp","range","selectedIdsLookupSelector","gridRowsMetaSelector","getFirstNonSpannedColumnToRender","getMinimalContentHeight","gridRenderContextSelector","gridVirtualizationEnabledSelector","gridVirtualizationColumnEnabledSelector","EMPTY_RENDER_CONTEXT","jsx","_jsx","MINIMUM_COLUMN_WIDTH","ScrollDirection","EMPTY_SCROLL_POSITION","top","left","EMPTY_DETAIL_PANELS","Object","freeze","Map","createScrollCache","mode","rowBufferPx","columnBufferPx","verticalBuffer","horizontalBuffer","direction","NONE","buffer","bufferForDirection","isJSDOM","window","test","navigator","userAgent","_","useGridVirtualScroller","apiRef","rootProps","visibleColumns","enabled","enabledForColumns","dimensions","outerSize","viewportOuterSize","pinnedRows","pinnedColumns","hasBottomPinnedRows","bottom","length","panels","setPanels","useState","theme","cellFocus","cellTabIndex","rowsMeta","selectedRowsLookup","currentPage","gridRootRef","current","rootElementRef","mainRef","mainElementRef","scrollerRef","virtualScrollerRef","scrollbarVerticalRef","useRef","scrollbarHorizontalRef","contentHeight","contentSize","height","columnsTotalWidth","hasColSpan","resize","scrollPosition","previousContextScrollPosition","previousRowContext","renderContext","scrollTimeout","frozenContext","undefined","scrollCache","rowHeight","focusedCell","rowIndex","useMemo","rows","findIndex","row","id","columnIndex","column","field","updateRenderContext","useCallback","nextRenderContext","areRenderContextsEqual","state","virtualization","didRowsIntervalChange","firstRowIndex","lastRowIndex","setState","isReady","publishEvent","triggerUpdateRenderContext","newScroll","scrollTop","scrollLeft","dx","dy","isScrolling","directionForDelta","rowScroll","Math","abs","columnScroll","didCrossThreshold","didChangeDirection","shouldUpdate","LEFT","RIGHT","inputs","inputsSelector","computeRenderContext","flushSync","start","forceUpdateRenderContext","handleScroll","event","currentTarget","handleWheel","handleTouchMove","getRows","params","baseRenderContext","isLastSection","position","isPinnedSection","rowIndexOffset","rowModels","firstRowToRender","lastRowToRender","min","rowIndexes","virtualRowIndex","unshift","push","rowProps","slotProps","columnPositions","forEach","rowIndexInPage","model","minFirstColumn","maxLastColumn","right","calculateColSpan","rowId","columns","hasFocus","baseRowHeight","rowHasAutoHeight","unstable_getRowHeight","isSelected","isRowSelectable","isFirstVisible","isLastVisible","lastIndex","isLastVisibleRowIndex","isVirtualRow","isNotVisible","tabbableCell","cellParams","getCellParams","cellMode","currentRenderContext","offsetLeft","computeOffsetLeft","slots","index","selected","offsetTop","positions","focusedColumnIndex","panel","get","getInfiniteLoadingTriggerElement","lastRowId","needsHorizontalScrollbar","width","scrollerStyle","overflowX","overflowY","autoHeight","max","size","useEffect","currentPageTotalHeight","initialRenderContext","register","getContainerProps","ref","getScrollerProps","tabIndex","onScroll","onWheel","onTouchMove","style","role","getContentProps","getRenderZoneProps","getScrollbarVerticalProps","getScrollbarHorizontalProps","dataRowIds","at","lastColumn","leftPinnedWidth","viewportInnerWidth","viewportInnerSize","viewportInnerHeight","lastRowHeight","lastColumnWidth","computedWidth","firstColumnIndex","lastColumnIndex","realLeft","getNearestIndexToRender","atStart","lastPosition","hasRowWithAutoHeight","getIndexesToRender","firstIndex","minFirstIndex","maxLastIndex","bufferBefore","rowBefore","bufferAfter","rowAfter","lastSize","i","binarySearch","actualRenderContext","deriveRenderContext","offset","options","lastMeasuredIndexRelativeToAllRows","getLastMeasuredRowIndex","allRowsMeasured","Infinity","lastMeasuredIndexRelativeToCurrentPage","exponentialSearch","initialFirstColumnToRender","lastColumnToRender","columnBefore","columnAfter","firstColumnToRender","visibleRows","sliceStart","sliceEnd","pivot","floor","isBefore","interval","firstPosition","firstIndexPadded","lastIndexPadded","context1","context2","pinnedLeftLength","factor","DOWN","UP","Error"],"sources":["C:/Users/kb/Downloads/billBoard/billboard/node_modules/@mui/x-data-grid/hooks/features/virtualization/useGridVirtualScroller.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { unstable_useEnhancedEffect as useEnhancedEffect, unstable_useEventCallback as useEventCallback } from '@mui/utils';\nimport useLazyRef from '@mui/utils/useLazyRef';\nimport useTimeout from '@mui/utils/useTimeout';\nimport { useTheme } from '@mui/material/styles';\nimport { useGridPrivateApiContext } from '../../utils/useGridPrivateApiContext';\nimport { useGridRootProps } from '../../utils/useGridRootProps';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { useResizeObserver } from '../../utils/useResizeObserver';\nimport { useRunOnce } from '../../utils/useRunOnce';\nimport { gridVisibleColumnDefinitionsSelector, gridVisiblePinnedColumnDefinitionsSelector, gridColumnPositionsSelector, gridHasColSpanSelector } from '../columns/gridColumnsSelector';\nimport { gridDimensionsSelector } from '../dimensions/gridDimensionsSelectors';\nimport { gridPinnedRowsSelector } from '../rows/gridRowsSelector';\nimport { gridFocusCellSelector, gridTabIndexCellSelector } from '../focus/gridFocusStateSelector';\nimport { useGridVisibleRows, getVisibleRows } from '../../utils/useGridVisibleRows';\nimport { useGridApiEventHandler } from '../../utils';\nimport { clamp, range } from '../../../utils/utils';\nimport { selectedIdsLookupSelector } from '../rowSelection/gridRowSelectionSelector';\nimport { gridRowsMetaSelector } from '../rows/gridRowsMetaSelector';\nimport { getFirstNonSpannedColumnToRender } from '../columns/gridColumnsUtils';\nimport { getMinimalContentHeight } from '../rows/gridRowsUtils';\nimport { gridRenderContextSelector, gridVirtualizationEnabledSelector, gridVirtualizationColumnEnabledSelector } from './gridVirtualizationSelectors';\nimport { EMPTY_RENDER_CONTEXT } from './useGridVirtualization';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst MINIMUM_COLUMN_WIDTH = 50;\nvar ScrollDirection = /*#__PURE__*/function (ScrollDirection) {\n  ScrollDirection[ScrollDirection[\"NONE\"] = 0] = \"NONE\";\n  ScrollDirection[ScrollDirection[\"UP\"] = 1] = \"UP\";\n  ScrollDirection[ScrollDirection[\"DOWN\"] = 2] = \"DOWN\";\n  ScrollDirection[ScrollDirection[\"LEFT\"] = 3] = \"LEFT\";\n  ScrollDirection[ScrollDirection[\"RIGHT\"] = 4] = \"RIGHT\";\n  return ScrollDirection;\n}(ScrollDirection || {});\nconst EMPTY_SCROLL_POSITION = {\n  top: 0,\n  left: 0\n};\nexport const EMPTY_DETAIL_PANELS = Object.freeze(new Map());\nconst createScrollCache = (mode, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer) => ({\n  direction: ScrollDirection.NONE,\n  buffer: bufferForDirection(mode, ScrollDirection.NONE, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer)\n});\nlet isJSDOM = false;\ntry {\n  if (typeof window !== 'undefined') {\n    isJSDOM = /jsdom/.test(window.navigator.userAgent);\n  }\n} catch (_) {\n  /* ignore */\n}\nexport const useGridVirtualScroller = () => {\n  const apiRef = useGridPrivateApiContext();\n  const rootProps = useGridRootProps();\n  const visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);\n  const enabled = useGridSelector(apiRef, gridVirtualizationEnabledSelector) && !isJSDOM;\n  const enabledForColumns = useGridSelector(apiRef, gridVirtualizationColumnEnabledSelector) && !isJSDOM;\n  const dimensions = useGridSelector(apiRef, gridDimensionsSelector);\n  const outerSize = dimensions.viewportOuterSize;\n  const pinnedRows = useGridSelector(apiRef, gridPinnedRowsSelector);\n  const pinnedColumns = useGridSelector(apiRef, gridVisiblePinnedColumnDefinitionsSelector);\n  const hasBottomPinnedRows = pinnedRows.bottom.length > 0;\n  const [panels, setPanels] = React.useState(EMPTY_DETAIL_PANELS);\n  const theme = useTheme();\n  const cellFocus = useGridSelector(apiRef, gridFocusCellSelector);\n  const cellTabIndex = useGridSelector(apiRef, gridTabIndexCellSelector);\n  const rowsMeta = useGridSelector(apiRef, gridRowsMetaSelector);\n  const selectedRowsLookup = useGridSelector(apiRef, selectedIdsLookupSelector);\n  const currentPage = useGridVisibleRows(apiRef, rootProps);\n  const gridRootRef = apiRef.current.rootElementRef;\n  const mainRef = apiRef.current.mainElementRef;\n  const scrollerRef = apiRef.current.virtualScrollerRef;\n  const scrollbarVerticalRef = React.useRef(null);\n  const scrollbarHorizontalRef = React.useRef(null);\n  const contentHeight = dimensions.contentSize.height;\n  const columnsTotalWidth = dimensions.columnsTotalWidth;\n  const hasColSpan = useGridSelector(apiRef, gridHasColSpanSelector);\n  useResizeObserver(mainRef, () => apiRef.current.resize());\n\n  /*\n   * Scroll context logic\n   * ====================\n   * We only render the cells contained in the `renderContext`. However, when the user starts scrolling the grid\n   * in a direction, we want to render as many cells as possible in that direction, as to avoid presenting white\n   * areas if the user scrolls too fast/far and the viewport ends up in a region we haven't rendered yet. To render\n   * more cells, we store some offsets to add to the viewport in `scrollCache.buffer`. Those offsets make the render\n   * context wider in the direction the user is going, but also makes the buffer around the viewport `0` for the\n   * dimension (horizontal or vertical) in which the user is not scrolling. So if the normal viewport is 8 columns\n   * wide, with a 1 column buffer (10 columns total), then we want it to be exactly 8 columns wide during vertical\n   * scroll.\n   * However, we don't want the rows in the old context to re-render from e.g. 10 columns to 8 columns, because that's\n   * work that's not necessary. Thus we store the context at the start of the scroll in `frozenContext`, and the rows\n   * that are part of this old context will keep their same render context as to avoid re-rendering.\n   */\n  const scrollPosition = React.useRef(EMPTY_SCROLL_POSITION);\n  const previousContextScrollPosition = React.useRef(EMPTY_SCROLL_POSITION);\n  const previousRowContext = React.useRef(EMPTY_RENDER_CONTEXT);\n  const renderContext = useGridSelector(apiRef, gridRenderContextSelector);\n  const scrollTimeout = useTimeout();\n  const frozenContext = React.useRef(undefined);\n  const scrollCache = useLazyRef(() => createScrollCache(theme.direction, rootProps.rowBufferPx, rootProps.columnBufferPx, dimensions.rowHeight * 15, MINIMUM_COLUMN_WIDTH * 6)).current;\n  const focusedCell = {\n    rowIndex: React.useMemo(() => cellFocus ? currentPage.rows.findIndex(row => row.id === cellFocus.id) : -1, [cellFocus, currentPage.rows]),\n    columnIndex: React.useMemo(() => cellFocus ? visibleColumns.findIndex(column => column.field === cellFocus.field) : -1, [cellFocus, visibleColumns])\n  };\n  const updateRenderContext = React.useCallback(nextRenderContext => {\n    if (areRenderContextsEqual(nextRenderContext, apiRef.current.state.virtualization.renderContext)) {\n      return;\n    }\n    const didRowsIntervalChange = nextRenderContext.firstRowIndex !== previousRowContext.current.firstRowIndex || nextRenderContext.lastRowIndex !== previousRowContext.current.lastRowIndex;\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        virtualization: _extends({}, state.virtualization, {\n          renderContext: nextRenderContext\n        })\n      });\n    });\n\n    // The lazy-loading hook is listening to `renderedRowsIntervalChange`,\n    // but only does something if the dimensions are also available.\n    // So we wait until we have valid dimensions before publishing the first event.\n    if (dimensions.isReady && didRowsIntervalChange) {\n      previousRowContext.current = nextRenderContext;\n      apiRef.current.publishEvent('renderedRowsIntervalChange', nextRenderContext);\n    }\n    previousContextScrollPosition.current = scrollPosition.current;\n  }, [apiRef, dimensions.isReady]);\n  const triggerUpdateRenderContext = () => {\n    const newScroll = {\n      top: scrollerRef.current.scrollTop,\n      left: scrollerRef.current.scrollLeft\n    };\n    const dx = newScroll.left - scrollPosition.current.left;\n    const dy = newScroll.top - scrollPosition.current.top;\n    const isScrolling = dx !== 0 || dy !== 0;\n    scrollPosition.current = newScroll;\n    const direction = isScrolling ? directionForDelta(dx, dy) : ScrollDirection.NONE;\n\n    // Since previous render, we have scrolled...\n    const rowScroll = Math.abs(scrollPosition.current.top - previousContextScrollPosition.current.top);\n    const columnScroll = Math.abs(scrollPosition.current.left - previousContextScrollPosition.current.left);\n\n    // PERF: use the computed minimum column width instead of a static one\n    const didCrossThreshold = rowScroll >= dimensions.rowHeight || columnScroll >= MINIMUM_COLUMN_WIDTH;\n    const didChangeDirection = scrollCache.direction !== direction;\n    const shouldUpdate = didCrossThreshold || didChangeDirection;\n    if (!shouldUpdate) {\n      return renderContext;\n    }\n\n    // Render a new context\n\n    if (didChangeDirection) {\n      switch (direction) {\n        case ScrollDirection.NONE:\n        case ScrollDirection.LEFT:\n        case ScrollDirection.RIGHT:\n          frozenContext.current = undefined;\n          break;\n        default:\n          frozenContext.current = renderContext;\n          break;\n      }\n    }\n    scrollCache.direction = direction;\n    scrollCache.buffer = bufferForDirection(theme.direction, direction, rootProps.rowBufferPx, rootProps.columnBufferPx, dimensions.rowHeight * 15, MINIMUM_COLUMN_WIDTH * 6);\n    const inputs = inputsSelector(apiRef, rootProps, enabled, enabledForColumns);\n    const nextRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache);\n\n    // Prevents batching render context changes\n    ReactDOM.flushSync(() => {\n      updateRenderContext(nextRenderContext);\n    });\n    scrollTimeout.start(1000, triggerUpdateRenderContext);\n    return nextRenderContext;\n  };\n  const forceUpdateRenderContext = () => {\n    const inputs = inputsSelector(apiRef, rootProps, enabled, enabledForColumns);\n    const nextRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache);\n    updateRenderContext(nextRenderContext);\n  };\n  const handleScroll = useEventCallback(event => {\n    const {\n      scrollTop,\n      scrollLeft\n    } = event.currentTarget;\n\n    // On iOS and macOS, negative offsets are possible when swiping past the start\n    if (scrollTop < 0) {\n      return;\n    }\n    if (theme.direction === 'ltr') {\n      if (scrollLeft < 0) {\n        return;\n      }\n    }\n    if (theme.direction === 'rtl') {\n      if (scrollLeft > 0) {\n        return;\n      }\n    }\n    const nextRenderContext = triggerUpdateRenderContext();\n    apiRef.current.publishEvent('scrollPositionChange', {\n      top: scrollTop,\n      left: scrollLeft,\n      renderContext: nextRenderContext\n    });\n  });\n  const handleWheel = useEventCallback(event => {\n    apiRef.current.publishEvent('virtualScrollerWheel', {}, event);\n  });\n  const handleTouchMove = useEventCallback(event => {\n    apiRef.current.publishEvent('virtualScrollerTouchMove', {}, event);\n  });\n  const getRows = (params = {}) => {\n    if (!params.rows && !currentPage.range) {\n      return [];\n    }\n    const baseRenderContext = params.renderContext ?? renderContext;\n    const isLastSection = !hasBottomPinnedRows && params.position === undefined || hasBottomPinnedRows && params.position === 'bottom';\n    const isPinnedSection = params.position !== undefined;\n    let rowIndexOffset;\n    // FIXME: Why is the switch check exhaustiveness not validated with typescript-eslint?\n    // eslint-disable-next-line default-case\n    switch (params.position) {\n      case 'top':\n        rowIndexOffset = 0;\n        break;\n      case 'bottom':\n        rowIndexOffset = pinnedRows.top.length + currentPage.rows.length;\n        break;\n      case undefined:\n        rowIndexOffset = pinnedRows.top.length;\n        break;\n    }\n    const rowModels = params.rows ?? currentPage.rows;\n    const firstRowToRender = baseRenderContext.firstRowIndex;\n    const lastRowToRender = Math.min(baseRenderContext.lastRowIndex, rowModels.length);\n    const rowIndexes = params.rows ? range(0, params.rows.length) : range(firstRowToRender, lastRowToRender);\n    let virtualRowIndex = -1;\n    if (!isPinnedSection && focusedCell.rowIndex !== -1) {\n      if (focusedCell.rowIndex < firstRowToRender) {\n        virtualRowIndex = focusedCell.rowIndex;\n        rowIndexes.unshift(virtualRowIndex);\n      }\n      if (focusedCell.rowIndex >= lastRowToRender) {\n        virtualRowIndex = focusedCell.rowIndex;\n        rowIndexes.push(virtualRowIndex);\n      }\n    }\n    const rows = [];\n    const rowProps = rootProps.slotProps?.row;\n    const columnPositions = gridColumnPositionsSelector(apiRef);\n    rowIndexes.forEach(rowIndexInPage => {\n      const {\n        id,\n        model\n      } = rowModels[rowIndexInPage];\n\n      // NOTE: This is an expensive feature, the colSpan code could be optimized.\n      if (hasColSpan) {\n        const minFirstColumn = pinnedColumns.left.length;\n        const maxLastColumn = visibleColumns.length - pinnedColumns.right.length;\n        apiRef.current.calculateColSpan({\n          rowId: id,\n          minFirstColumn,\n          maxLastColumn,\n          columns: visibleColumns\n        });\n        if (pinnedColumns.left.length > 0) {\n          apiRef.current.calculateColSpan({\n            rowId: id,\n            minFirstColumn: 0,\n            maxLastColumn: pinnedColumns.left.length,\n            columns: visibleColumns\n          });\n        }\n        if (pinnedColumns.right.length > 0) {\n          apiRef.current.calculateColSpan({\n            rowId: id,\n            minFirstColumn: visibleColumns.length - pinnedColumns.right.length,\n            maxLastColumn: visibleColumns.length,\n            columns: visibleColumns\n          });\n        }\n      }\n      const hasFocus = cellFocus?.id === id;\n      const baseRowHeight = !apiRef.current.rowHasAutoHeight(id) ? apiRef.current.unstable_getRowHeight(id) : 'auto';\n      let isSelected;\n      if (selectedRowsLookup[id] == null) {\n        isSelected = false;\n      } else {\n        isSelected = apiRef.current.isRowSelectable(id);\n      }\n      let isFirstVisible = false;\n      if (params.position === undefined) {\n        isFirstVisible = rowIndexInPage === 0;\n      }\n      let isLastVisible = false;\n      if (isLastSection) {\n        if (!isPinnedSection) {\n          const lastIndex = currentPage.rows.length - 1;\n          const isLastVisibleRowIndex = rowIndexInPage === lastIndex;\n          if (isLastVisibleRowIndex) {\n            isLastVisible = true;\n          }\n        } else {\n          isLastVisible = rowIndexInPage === rowModels.length - 1;\n        }\n      }\n      const isVirtualRow = rowIndexInPage === virtualRowIndex;\n      const isNotVisible = isVirtualRow;\n      let tabbableCell = null;\n      if (cellTabIndex !== null && cellTabIndex.id === id) {\n        const cellParams = apiRef.current.getCellParams(id, cellTabIndex.field);\n        tabbableCell = cellParams.cellMode === 'view' ? cellTabIndex.field : null;\n      }\n      let currentRenderContext = baseRenderContext;\n      if (!isPinnedSection && frozenContext.current && rowIndexInPage >= frozenContext.current.firstRowIndex && rowIndexInPage < frozenContext.current.lastRowIndex) {\n        currentRenderContext = frozenContext.current;\n      }\n      const offsetLeft = computeOffsetLeft(columnPositions, currentRenderContext, theme.direction, pinnedColumns.left.length);\n      const rowIndex = (currentPage?.range?.firstRowIndex || 0) + rowIndexOffset + rowIndexInPage;\n      rows.push( /*#__PURE__*/_jsx(rootProps.slots.row, _extends({\n        row: model,\n        rowId: id,\n        index: rowIndex,\n        selected: isSelected,\n        offsetTop: params.rows ? undefined : rowsMeta.positions[rowIndexInPage],\n        offsetLeft: offsetLeft,\n        dimensions: dimensions,\n        rowHeight: baseRowHeight,\n        tabbableCell: tabbableCell,\n        pinnedColumns: pinnedColumns,\n        visibleColumns: visibleColumns,\n        renderContext: currentRenderContext,\n        focusedColumnIndex: hasFocus ? focusedCell.columnIndex : undefined,\n        isFirstVisible: isFirstVisible,\n        isLastVisible: isLastVisible,\n        isNotVisible: isNotVisible\n      }, rowProps), id));\n      if (isNotVisible) {\n        return;\n      }\n      const panel = panels.get(id);\n      if (panel) {\n        rows.push(panel);\n      }\n      if (isLastVisible) {\n        rows.push(apiRef.current.getInfiniteLoadingTriggerElement?.({\n          lastRowId: id\n        }));\n      }\n    });\n    return rows;\n  };\n  const needsHorizontalScrollbar = outerSize.width && columnsTotalWidth >= outerSize.width;\n  const scrollerStyle = React.useMemo(() => ({\n    overflowX: !needsHorizontalScrollbar ? 'hidden' : undefined,\n    overflowY: rootProps.autoHeight ? 'hidden' : undefined\n  }), [needsHorizontalScrollbar, rootProps.autoHeight]);\n  const contentSize = React.useMemo(() => {\n    // In cases where the columns exceed the available width,\n    // the horizontal scrollbar should be shown even when there're no rows.\n    // Keeping 1px as minimum height ensures that the scrollbar will visible if necessary.\n    const height = Math.max(contentHeight, 1);\n    const size = {\n      width: needsHorizontalScrollbar ? columnsTotalWidth : 'auto',\n      height\n    };\n    if (rootProps.autoHeight) {\n      if (currentPage.rows.length === 0) {\n        size.height = getMinimalContentHeight(apiRef); // Give room to show the overlay when there no rows.\n      } else {\n        size.height = contentHeight;\n      }\n    }\n    return size;\n  }, [apiRef, columnsTotalWidth, contentHeight, needsHorizontalScrollbar, rootProps.autoHeight, currentPage.rows.length]);\n  React.useEffect(() => {\n    apiRef.current.publishEvent('virtualScrollerContentSizeChange');\n  }, [apiRef, contentSize]);\n  useEnhancedEffect(() => {\n    // FIXME: Is this really necessary?\n    apiRef.current.resize();\n  }, [apiRef, rowsMeta.currentPageTotalHeight]);\n  useEnhancedEffect(() => {\n    if (enabled) {\n      // TODO a scroll reset should not be necessary\n      scrollerRef.current.scrollLeft = 0;\n      scrollerRef.current.scrollTop = 0;\n    }\n  }, [enabled, gridRootRef, scrollerRef]);\n  useRunOnce(outerSize.width !== 0, () => {\n    const inputs = inputsSelector(apiRef, rootProps, enabled, enabledForColumns);\n    const initialRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache);\n    updateRenderContext(initialRenderContext);\n    apiRef.current.publishEvent('scrollPositionChange', {\n      top: scrollPosition.current.top,\n      left: scrollPosition.current.left,\n      renderContext: initialRenderContext\n    });\n  });\n  apiRef.current.register('private', {\n    updateRenderContext: forceUpdateRenderContext\n  });\n  useGridApiEventHandler(apiRef, 'columnsChange', forceUpdateRenderContext);\n  useGridApiEventHandler(apiRef, 'filteredRowsSet', forceUpdateRenderContext);\n  useGridApiEventHandler(apiRef, 'rowExpansionChange', forceUpdateRenderContext);\n  return {\n    renderContext,\n    setPanels,\n    getRows,\n    getContainerProps: () => ({\n      ref: mainRef\n    }),\n    getScrollerProps: () => ({\n      ref: scrollerRef,\n      tabIndex: -1,\n      onScroll: handleScroll,\n      onWheel: handleWheel,\n      onTouchMove: handleTouchMove,\n      style: scrollerStyle,\n      role: 'presentation'\n    }),\n    getContentProps: () => ({\n      style: contentSize,\n      role: 'presentation'\n    }),\n    getRenderZoneProps: () => ({\n      role: 'rowgroup'\n    }),\n    getScrollbarVerticalProps: () => ({\n      ref: scrollbarVerticalRef,\n      role: 'presentation'\n    }),\n    getScrollbarHorizontalProps: () => ({\n      ref: scrollbarHorizontalRef,\n      role: 'presentation'\n    })\n  };\n};\nfunction inputsSelector(apiRef, rootProps, enabled, enabledForColumns) {\n  const dimensions = gridDimensionsSelector(apiRef.current.state);\n  const currentPage = getVisibleRows(apiRef, rootProps);\n  const visibleColumns = gridVisibleColumnDefinitionsSelector(apiRef);\n  const lastRowId = apiRef.current.state.rows.dataRowIds.at(-1);\n  const lastColumn = visibleColumns.at(-1);\n  return {\n    enabled,\n    enabledForColumns,\n    apiRef,\n    autoHeight: rootProps.autoHeight,\n    rowBufferPx: rootProps.rowBufferPx,\n    columnBufferPx: rootProps.columnBufferPx,\n    leftPinnedWidth: dimensions.leftPinnedWidth,\n    columnsTotalWidth: dimensions.columnsTotalWidth,\n    viewportInnerWidth: dimensions.viewportInnerSize.width,\n    viewportInnerHeight: dimensions.viewportInnerSize.height,\n    lastRowHeight: lastRowId !== undefined ? apiRef.current.unstable_getRowHeight(lastRowId) : 0,\n    lastColumnWidth: lastColumn?.computedWidth ?? 0,\n    rowsMeta: gridRowsMetaSelector(apiRef.current.state),\n    columnPositions: gridColumnPositionsSelector(apiRef),\n    rows: currentPage.rows,\n    range: currentPage.range,\n    pinnedColumns: gridVisiblePinnedColumnDefinitionsSelector(apiRef),\n    visibleColumns\n  };\n}\nfunction computeRenderContext(inputs, scrollPosition, scrollCache) {\n  let renderContext;\n  if (!inputs.enabled) {\n    renderContext = {\n      firstRowIndex: 0,\n      lastRowIndex: inputs.rows.length,\n      firstColumnIndex: 0,\n      lastColumnIndex: inputs.visibleColumns.length\n    };\n  } else {\n    const {\n      top,\n      left\n    } = scrollPosition;\n    const realLeft = Math.abs(left) + inputs.leftPinnedWidth;\n\n    // Clamp the value because the search may return an index out of bounds.\n    // In the last index, this is not needed because Array.slice doesn't include it.\n    const firstRowIndex = Math.min(getNearestIndexToRender(inputs, top, {\n      atStart: true,\n      lastPosition: inputs.rowsMeta.positions[inputs.rowsMeta.positions.length - 1] + inputs.lastRowHeight\n    }), inputs.rowsMeta.positions.length - 1);\n    const lastRowIndex = inputs.autoHeight ? firstRowIndex + inputs.rows.length : getNearestIndexToRender(inputs, top + inputs.viewportInnerHeight);\n    let firstColumnIndex = 0;\n    let lastColumnIndex = inputs.columnPositions.length;\n    if (inputs.enabledForColumns) {\n      let hasRowWithAutoHeight = false;\n      const [firstRowToRender, lastRowToRender] = getIndexesToRender({\n        firstIndex: firstRowIndex,\n        lastIndex: lastRowIndex,\n        minFirstIndex: 0,\n        maxLastIndex: inputs.rows.length,\n        bufferBefore: scrollCache.buffer.rowBefore,\n        bufferAfter: scrollCache.buffer.rowAfter,\n        positions: inputs.rowsMeta.positions,\n        lastSize: inputs.lastRowHeight\n      });\n      for (let i = firstRowToRender; i < lastRowToRender && !hasRowWithAutoHeight; i += 1) {\n        const row = inputs.rows[i];\n        hasRowWithAutoHeight = inputs.apiRef.current.rowHasAutoHeight(row.id);\n      }\n      if (!hasRowWithAutoHeight) {\n        firstColumnIndex = binarySearch(realLeft, inputs.columnPositions, {\n          atStart: true,\n          lastPosition: inputs.columnsTotalWidth\n        });\n        lastColumnIndex = binarySearch(realLeft + inputs.viewportInnerWidth, inputs.columnPositions);\n      }\n    }\n    renderContext = {\n      firstRowIndex,\n      lastRowIndex,\n      firstColumnIndex,\n      lastColumnIndex\n    };\n  }\n  const actualRenderContext = deriveRenderContext(inputs, renderContext, scrollCache);\n  return actualRenderContext;\n}\nfunction getNearestIndexToRender(inputs, offset, options) {\n  const lastMeasuredIndexRelativeToAllRows = inputs.apiRef.current.getLastMeasuredRowIndex();\n  let allRowsMeasured = lastMeasuredIndexRelativeToAllRows === Infinity;\n  if (inputs.range?.lastRowIndex && !allRowsMeasured) {\n    // Check if all rows in this page are already measured\n    allRowsMeasured = lastMeasuredIndexRelativeToAllRows >= inputs.range.lastRowIndex;\n  }\n  const lastMeasuredIndexRelativeToCurrentPage = clamp(lastMeasuredIndexRelativeToAllRows - (inputs.range?.firstRowIndex || 0), 0, inputs.rowsMeta.positions.length);\n  if (allRowsMeasured || inputs.rowsMeta.positions[lastMeasuredIndexRelativeToCurrentPage] >= offset) {\n    // If all rows were measured (when no row has \"auto\" as height) or all rows before the offset\n    // were measured, then use a binary search because it's faster.\n    return binarySearch(offset, inputs.rowsMeta.positions, options);\n  }\n\n  // Otherwise, use an exponential search.\n  // If rows have \"auto\" as height, their positions will be based on estimated heights.\n  // In this case, we can skip several steps until we find a position higher than the offset.\n  // Inspired by https://github.com/bvaughn/react-virtualized/blob/master/source/Grid/utils/CellSizeAndPositionManager.js\n  return exponentialSearch(offset, inputs.rowsMeta.positions, lastMeasuredIndexRelativeToCurrentPage, options);\n}\n\n/**\n * Accepts as input a raw render context (the area visible in the viewport) and adds\n * computes the actual render context based on pinned elements, buffer dimensions and\n * spanning.\n */\nfunction deriveRenderContext(inputs, nextRenderContext, scrollCache) {\n  const [firstRowToRender, lastRowToRender] = getIndexesToRender({\n    firstIndex: nextRenderContext.firstRowIndex,\n    lastIndex: nextRenderContext.lastRowIndex,\n    minFirstIndex: 0,\n    maxLastIndex: inputs.rows.length,\n    bufferBefore: scrollCache.buffer.rowBefore,\n    bufferAfter: scrollCache.buffer.rowAfter,\n    positions: inputs.rowsMeta.positions,\n    lastSize: inputs.lastRowHeight\n  });\n  const [initialFirstColumnToRender, lastColumnToRender] = getIndexesToRender({\n    firstIndex: nextRenderContext.firstColumnIndex,\n    lastIndex: nextRenderContext.lastColumnIndex,\n    minFirstIndex: inputs.pinnedColumns.left.length,\n    maxLastIndex: inputs.visibleColumns.length - inputs.pinnedColumns.right.length,\n    bufferBefore: scrollCache.buffer.columnBefore,\n    bufferAfter: scrollCache.buffer.columnAfter,\n    positions: inputs.columnPositions,\n    lastSize: inputs.lastColumnWidth\n  });\n  const firstColumnToRender = getFirstNonSpannedColumnToRender({\n    firstColumnToRender: initialFirstColumnToRender,\n    apiRef: inputs.apiRef,\n    firstRowToRender,\n    lastRowToRender,\n    visibleRows: inputs.rows\n  });\n  return {\n    firstRowIndex: firstRowToRender,\n    lastRowIndex: lastRowToRender,\n    firstColumnIndex: firstColumnToRender,\n    lastColumnIndex: lastColumnToRender\n  };\n}\n/**\n * Use binary search to avoid looping through all possible positions.\n * The `options.atStart` provides the possibility to match for the first element that\n * intersects the screen, even if said element's start position is before `offset`. In\n * other words, we search for `offset + width`.\n */\nfunction binarySearch(offset, positions, options = undefined, sliceStart = 0, sliceEnd = positions.length) {\n  if (positions.length <= 0) {\n    return -1;\n  }\n  if (sliceStart >= sliceEnd) {\n    return sliceStart;\n  }\n  const pivot = sliceStart + Math.floor((sliceEnd - sliceStart) / 2);\n  const position = positions[pivot];\n  let isBefore;\n  if (options?.atStart) {\n    const width = (pivot === positions.length - 1 ? options.lastPosition : positions[pivot + 1]) - position;\n    isBefore = offset - width < position;\n  } else {\n    isBefore = offset <= position;\n  }\n  return isBefore ? binarySearch(offset, positions, options, sliceStart, pivot) : binarySearch(offset, positions, options, pivot + 1, sliceEnd);\n}\nfunction exponentialSearch(offset, positions, index, options = undefined) {\n  let interval = 1;\n  while (index < positions.length && Math.abs(positions[index]) < offset) {\n    index += interval;\n    interval *= 2;\n  }\n  return binarySearch(offset, positions, options, Math.floor(index / 2), Math.min(index, positions.length));\n}\nfunction getIndexesToRender({\n  firstIndex,\n  lastIndex,\n  bufferBefore,\n  bufferAfter,\n  minFirstIndex,\n  maxLastIndex,\n  positions,\n  lastSize\n}) {\n  const firstPosition = positions[firstIndex] - bufferBefore;\n  const lastPosition = positions[lastIndex] + bufferAfter;\n  const firstIndexPadded = binarySearch(firstPosition, positions, {\n    atStart: true,\n    lastPosition: positions[positions.length - 1] + lastSize\n  });\n  const lastIndexPadded = binarySearch(lastPosition, positions);\n  return [clamp(firstIndexPadded, minFirstIndex, maxLastIndex), clamp(lastIndexPadded, minFirstIndex, maxLastIndex)];\n}\nexport function areRenderContextsEqual(context1, context2) {\n  if (context1 === context2) {\n    return true;\n  }\n  return context1.firstRowIndex === context2.firstRowIndex && context1.lastRowIndex === context2.lastRowIndex && context1.firstColumnIndex === context2.firstColumnIndex && context1.lastColumnIndex === context2.lastColumnIndex;\n}\nexport function computeOffsetLeft(columnPositions, renderContext, direction, pinnedLeftLength) {\n  const factor = direction === 'ltr' ? 1 : -1;\n  const left = factor * (columnPositions[renderContext.firstColumnIndex] ?? 0) - (columnPositions[pinnedLeftLength] ?? 0);\n  return Math.abs(left);\n}\nfunction directionForDelta(dx, dy) {\n  if (dx === 0 && dy === 0) {\n    return ScrollDirection.NONE;\n  }\n  /* eslint-disable */\n  if (Math.abs(dy) >= Math.abs(dx)) {\n    if (dy > 0) {\n      return ScrollDirection.DOWN;\n    } else {\n      return ScrollDirection.UP;\n    }\n  } else {\n    if (dx > 0) {\n      return ScrollDirection.RIGHT;\n    } else {\n      return ScrollDirection.LEFT;\n    }\n  }\n  /* eslint-enable */\n}\nfunction bufferForDirection(mode, direction, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer) {\n  if (mode === 'rtl') {\n    switch (direction) {\n      case ScrollDirection.LEFT:\n        direction = ScrollDirection.RIGHT;\n        break;\n      case ScrollDirection.RIGHT:\n        direction = ScrollDirection.LEFT;\n        break;\n      default:\n    }\n  }\n  switch (direction) {\n    case ScrollDirection.NONE:\n      return {\n        rowAfter: rowBufferPx,\n        rowBefore: rowBufferPx,\n        columnAfter: columnBufferPx,\n        columnBefore: columnBufferPx\n      };\n    case ScrollDirection.LEFT:\n      return {\n        rowAfter: 0,\n        rowBefore: 0,\n        columnAfter: 0,\n        columnBefore: horizontalBuffer\n      };\n    case ScrollDirection.RIGHT:\n      return {\n        rowAfter: 0,\n        rowBefore: 0,\n        columnAfter: horizontalBuffer,\n        columnBefore: 0\n      };\n    case ScrollDirection.UP:\n      return {\n        rowAfter: 0,\n        rowBefore: verticalBuffer,\n        columnAfter: 0,\n        columnBefore: 0\n      };\n    case ScrollDirection.DOWN:\n      return {\n        rowAfter: verticalBuffer,\n        rowBefore: 0,\n        columnAfter: 0,\n        columnBefore: 0\n      };\n    default:\n      // eslint unable to figure out enum exhaustiveness\n      throw new Error('unreachable');\n  }\n}"],"mappings":"AAAA,OAAOA,QAAP,MAAqB,oCAArB;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AACA,OAAO,KAAKC,QAAZ,MAA0B,WAA1B;AACA,SAASC,0BAA0B,IAAIC,iBAAvC,EAA0DC,yBAAyB,IAAIC,gBAAvF,QAA+G,YAA/G;AACA,OAAOC,UAAP,MAAuB,uBAAvB;AACA,OAAOC,UAAP,MAAuB,uBAAvB;AACA,SAASC,QAAT,QAAyB,sBAAzB;AACA,SAASC,wBAAT,QAAyC,sCAAzC;AACA,SAASC,gBAAT,QAAiC,8BAAjC;AACA,SAASC,eAAT,QAAgC,6BAAhC;AACA,SAASC,iBAAT,QAAkC,+BAAlC;AACA,SAASC,UAAT,QAA2B,wBAA3B;AACA,SAASC,oCAAT,EAA+CC,0CAA/C,EAA2FC,2BAA3F,EAAwHC,sBAAxH,QAAsJ,gCAAtJ;AACA,SAASC,sBAAT,QAAuC,uCAAvC;AACA,SAASC,sBAAT,QAAuC,0BAAvC;AACA,SAASC,qBAAT,EAAgCC,wBAAhC,QAAgE,iCAAhE;AACA,SAASC,kBAAT,EAA6BC,cAA7B,QAAmD,gCAAnD;AACA,SAASC,sBAAT,QAAuC,aAAvC;AACA,SAASC,KAAT,EAAgBC,KAAhB,QAA6B,sBAA7B;AACA,SAASC,yBAAT,QAA0C,0CAA1C;AACA,SAASC,oBAAT,QAAqC,8BAArC;AACA,SAASC,gCAAT,QAAiD,6BAAjD;AACA,SAASC,uBAAT,QAAwC,uBAAxC;AACA,SAASC,yBAAT,EAAoCC,iCAApC,EAAuEC,uCAAvE,QAAsH,+BAAtH;AACA,SAASC,oBAAT,QAAqC,yBAArC;AACA,SAASC,GAAG,IAAIC,IAAhB,QAA4B,mBAA5B;AACA,MAAMC,oBAAoB,GAAG,EAA7B;;AACA,IAAIC,eAAe,GAAG,aAAa,UAAUA,eAAV,EAA2B;EAC5DA,eAAe,CAACA,eAAe,CAAC,MAAD,CAAf,GAA0B,CAA3B,CAAf,GAA+C,MAA/C;EACAA,eAAe,CAACA,eAAe,CAAC,IAAD,CAAf,GAAwB,CAAzB,CAAf,GAA6C,IAA7C;EACAA,eAAe,CAACA,eAAe,CAAC,MAAD,CAAf,GAA0B,CAA3B,CAAf,GAA+C,MAA/C;EACAA,eAAe,CAACA,eAAe,CAAC,MAAD,CAAf,GAA0B,CAA3B,CAAf,GAA+C,MAA/C;EACAA,eAAe,CAACA,eAAe,CAAC,OAAD,CAAf,GAA2B,CAA5B,CAAf,GAAgD,OAAhD;EACA,OAAOA,eAAP;AACD,CAPkC,CAOjCA,eAAe,IAAI,EAPc,CAAnC;;AAQA,MAAMC,qBAAqB,GAAG;EAC5BC,GAAG,EAAE,CADuB;EAE5BC,IAAI,EAAE;AAFsB,CAA9B;AAIA,OAAO,MAAMC,mBAAmB,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAIC,GAAJ,EAAd,CAA5B;;AACP,MAAMC,iBAAiB,GAAG,CAACC,IAAD,EAAOC,WAAP,EAAoBC,cAApB,EAAoCC,cAApC,EAAoDC,gBAApD,MAA0E;EAClGC,SAAS,EAAEd,eAAe,CAACe,IADuE;EAElGC,MAAM,EAAEC,kBAAkB,CAACR,IAAD,EAAOT,eAAe,CAACe,IAAvB,EAA6BL,WAA7B,EAA0CC,cAA1C,EAA0DC,cAA1D,EAA0EC,gBAA1E;AAFwE,CAA1E,CAA1B;;AAIA,IAAIK,OAAO,GAAG,KAAd;;AACA,IAAI;EACF,IAAI,OAAOC,MAAP,KAAkB,WAAtB,EAAmC;IACjCD,OAAO,GAAG,QAAQE,IAAR,CAAaD,MAAM,CAACE,SAAP,CAAiBC,SAA9B,CAAV;EACD;AACF,CAJD,CAIE,OAAOC,CAAP,EAAU;EACV;AACD;;AACD,OAAO,MAAMC,sBAAsB,GAAG,MAAM;EAC1C,MAAMC,MAAM,GAAGtD,wBAAwB,EAAvC;EACA,MAAMuD,SAAS,GAAGtD,gBAAgB,EAAlC;EACA,MAAMuD,cAAc,GAAGtD,eAAe,CAACoD,MAAD,EAASjD,oCAAT,CAAtC;EACA,MAAMoD,OAAO,GAAGvD,eAAe,CAACoD,MAAD,EAAS/B,iCAAT,CAAf,IAA8D,CAACwB,OAA/E;EACA,MAAMW,iBAAiB,GAAGxD,eAAe,CAACoD,MAAD,EAAS9B,uCAAT,CAAf,IAAoE,CAACuB,OAA/F;EACA,MAAMY,UAAU,GAAGzD,eAAe,CAACoD,MAAD,EAAS7C,sBAAT,CAAlC;EACA,MAAMmD,SAAS,GAAGD,UAAU,CAACE,iBAA7B;EACA,MAAMC,UAAU,GAAG5D,eAAe,CAACoD,MAAD,EAAS5C,sBAAT,CAAlC;EACA,MAAMqD,aAAa,GAAG7D,eAAe,CAACoD,MAAD,EAAShD,0CAAT,CAArC;EACA,MAAM0D,mBAAmB,GAAGF,UAAU,CAACG,MAAX,CAAkBC,MAAlB,GAA2B,CAAvD;EACA,MAAM,CAACC,MAAD,EAASC,SAAT,IAAsB7E,KAAK,CAAC8E,QAAN,CAAepC,mBAAf,CAA5B;EACA,MAAMqC,KAAK,GAAGvE,QAAQ,EAAtB;EACA,MAAMwE,SAAS,GAAGrE,eAAe,CAACoD,MAAD,EAAS3C,qBAAT,CAAjC;EACA,MAAM6D,YAAY,GAAGtE,eAAe,CAACoD,MAAD,EAAS1C,wBAAT,CAApC;EACA,MAAM6D,QAAQ,GAAGvE,eAAe,CAACoD,MAAD,EAASnC,oBAAT,CAAhC;EACA,MAAMuD,kBAAkB,GAAGxE,eAAe,CAACoD,MAAD,EAASpC,yBAAT,CAA1C;EACA,MAAMyD,WAAW,GAAG9D,kBAAkB,CAACyC,MAAD,EAASC,SAAT,CAAtC;EACA,MAAMqB,WAAW,GAAGtB,MAAM,CAACuB,OAAP,CAAeC,cAAnC;EACA,MAAMC,OAAO,GAAGzB,MAAM,CAACuB,OAAP,CAAeG,cAA/B;EACA,MAAMC,WAAW,GAAG3B,MAAM,CAACuB,OAAP,CAAeK,kBAAnC;EACA,MAAMC,oBAAoB,GAAG5F,KAAK,CAAC6F,MAAN,CAAa,IAAb,CAA7B;EACA,MAAMC,sBAAsB,GAAG9F,KAAK,CAAC6F,MAAN,CAAa,IAAb,CAA/B;EACA,MAAME,aAAa,GAAG3B,UAAU,CAAC4B,WAAX,CAAuBC,MAA7C;EACA,MAAMC,iBAAiB,GAAG9B,UAAU,CAAC8B,iBAArC;EACA,MAAMC,UAAU,GAAGxF,eAAe,CAACoD,MAAD,EAAS9C,sBAAT,CAAlC;EACAL,iBAAiB,CAAC4E,OAAD,EAAU,MAAMzB,MAAM,CAACuB,OAAP,CAAec,MAAf,EAAhB,CAAjB;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EACE,MAAMC,cAAc,GAAGrG,KAAK,CAAC6F,MAAN,CAAatD,qBAAb,CAAvB;EACA,MAAM+D,6BAA6B,GAAGtG,KAAK,CAAC6F,MAAN,CAAatD,qBAAb,CAAtC;EACA,MAAMgE,kBAAkB,GAAGvG,KAAK,CAAC6F,MAAN,CAAa3D,oBAAb,CAA3B;EACA,MAAMsE,aAAa,GAAG7F,eAAe,CAACoD,MAAD,EAAShC,yBAAT,CAArC;EACA,MAAM0E,aAAa,GAAGlG,UAAU,EAAhC;EACA,MAAMmG,aAAa,GAAG1G,KAAK,CAAC6F,MAAN,CAAac,SAAb,CAAtB;EACA,MAAMC,WAAW,GAAGtG,UAAU,CAAC,MAAMwC,iBAAiB,CAACiC,KAAK,CAAC3B,SAAP,EAAkBY,SAAS,CAAChB,WAA5B,EAAyCgB,SAAS,CAACf,cAAnD,EAAmEmB,UAAU,CAACyC,SAAX,GAAuB,EAA1F,EAA8FxE,oBAAoB,GAAG,CAArH,CAAxB,CAAV,CAA2JiD,OAA/K;EACA,MAAMwB,WAAW,GAAG;IAClBC,QAAQ,EAAE/G,KAAK,CAACgH,OAAN,CAAc,MAAMhC,SAAS,GAAGI,WAAW,CAAC6B,IAAZ,CAAiBC,SAAjB,CAA2BC,GAAG,IAAIA,GAAG,CAACC,EAAJ,KAAWpC,SAAS,CAACoC,EAAvD,CAAH,GAAgE,CAAC,CAA9F,EAAiG,CAACpC,SAAD,EAAYI,WAAW,CAAC6B,IAAxB,CAAjG,CADQ;IAElBI,WAAW,EAAErH,KAAK,CAACgH,OAAN,CAAc,MAAMhC,SAAS,GAAGf,cAAc,CAACiD,SAAf,CAAyBI,MAAM,IAAIA,MAAM,CAACC,KAAP,KAAiBvC,SAAS,CAACuC,KAA9D,CAAH,GAA0E,CAAC,CAAxG,EAA2G,CAACvC,SAAD,EAAYf,cAAZ,CAA3G;EAFK,CAApB;EAIA,MAAMuD,mBAAmB,GAAGxH,KAAK,CAACyH,WAAN,CAAkBC,iBAAiB,IAAI;IACjE,IAAIC,sBAAsB,CAACD,iBAAD,EAAoB3D,MAAM,CAACuB,OAAP,CAAesC,KAAf,CAAqBC,cAArB,CAAoCrB,aAAxD,CAA1B,EAAkG;MAChG;IACD;;IACD,MAAMsB,qBAAqB,GAAGJ,iBAAiB,CAACK,aAAlB,KAAoCxB,kBAAkB,CAACjB,OAAnB,CAA2ByC,aAA/D,IAAgFL,iBAAiB,CAACM,YAAlB,KAAmCzB,kBAAkB,CAACjB,OAAnB,CAA2B0C,YAA5K;IACAjE,MAAM,CAACuB,OAAP,CAAe2C,QAAf,CAAwBL,KAAK,IAAI;MAC/B,OAAO7H,QAAQ,CAAC,EAAD,EAAK6H,KAAL,EAAY;QACzBC,cAAc,EAAE9H,QAAQ,CAAC,EAAD,EAAK6H,KAAK,CAACC,cAAX,EAA2B;UACjDrB,aAAa,EAAEkB;QADkC,CAA3B;MADC,CAAZ,CAAf;IAKD,CAND,EALiE,CAajE;IACA;IACA;;IACA,IAAItD,UAAU,CAAC8D,OAAX,IAAsBJ,qBAA1B,EAAiD;MAC/CvB,kBAAkB,CAACjB,OAAnB,GAA6BoC,iBAA7B;MACA3D,MAAM,CAACuB,OAAP,CAAe6C,YAAf,CAA4B,4BAA5B,EAA0DT,iBAA1D;IACD;;IACDpB,6BAA6B,CAAChB,OAA9B,GAAwCe,cAAc,CAACf,OAAvD;EACD,CArB2B,EAqBzB,CAACvB,MAAD,EAASK,UAAU,CAAC8D,OAApB,CArByB,CAA5B;;EAsBA,MAAME,0BAA0B,GAAG,MAAM;IACvC,MAAMC,SAAS,GAAG;MAChB7F,GAAG,EAAEkD,WAAW,CAACJ,OAAZ,CAAoBgD,SADT;MAEhB7F,IAAI,EAAEiD,WAAW,CAACJ,OAAZ,CAAoBiD;IAFV,CAAlB;IAIA,MAAMC,EAAE,GAAGH,SAAS,CAAC5F,IAAV,GAAiB4D,cAAc,CAACf,OAAf,CAAuB7C,IAAnD;IACA,MAAMgG,EAAE,GAAGJ,SAAS,CAAC7F,GAAV,GAAgB6D,cAAc,CAACf,OAAf,CAAuB9C,GAAlD;IACA,MAAMkG,WAAW,GAAGF,EAAE,KAAK,CAAP,IAAYC,EAAE,KAAK,CAAvC;IACApC,cAAc,CAACf,OAAf,GAAyB+C,SAAzB;IACA,MAAMjF,SAAS,GAAGsF,WAAW,GAAGC,iBAAiB,CAACH,EAAD,EAAKC,EAAL,CAApB,GAA+BnG,eAAe,CAACe,IAA5E,CATuC,CAWvC;;IACA,MAAMuF,SAAS,GAAGC,IAAI,CAACC,GAAL,CAASzC,cAAc,CAACf,OAAf,CAAuB9C,GAAvB,GAA6B8D,6BAA6B,CAAChB,OAA9B,CAAsC9C,GAA5E,CAAlB;IACA,MAAMuG,YAAY,GAAGF,IAAI,CAACC,GAAL,CAASzC,cAAc,CAACf,OAAf,CAAuB7C,IAAvB,GAA8B6D,6BAA6B,CAAChB,OAA9B,CAAsC7C,IAA7E,CAArB,CAbuC,CAevC;;IACA,MAAMuG,iBAAiB,GAAGJ,SAAS,IAAIxE,UAAU,CAACyC,SAAxB,IAAqCkC,YAAY,IAAI1G,oBAA/E;IACA,MAAM4G,kBAAkB,GAAGrC,WAAW,CAACxD,SAAZ,KAA0BA,SAArD;IACA,MAAM8F,YAAY,GAAGF,iBAAiB,IAAIC,kBAA1C;;IACA,IAAI,CAACC,YAAL,EAAmB;MACjB,OAAO1C,aAAP;IACD,CArBsC,CAuBvC;;;IAEA,IAAIyC,kBAAJ,EAAwB;MACtB,QAAQ7F,SAAR;QACE,KAAKd,eAAe,CAACe,IAArB;QACA,KAAKf,eAAe,CAAC6G,IAArB;QACA,KAAK7G,eAAe,CAAC8G,KAArB;UACE1C,aAAa,CAACpB,OAAd,GAAwBqB,SAAxB;UACA;;QACF;UACED,aAAa,CAACpB,OAAd,GAAwBkB,aAAxB;UACA;MARJ;IAUD;;IACDI,WAAW,CAACxD,SAAZ,GAAwBA,SAAxB;IACAwD,WAAW,CAACtD,MAAZ,GAAqBC,kBAAkB,CAACwB,KAAK,CAAC3B,SAAP,EAAkBA,SAAlB,EAA6BY,SAAS,CAAChB,WAAvC,EAAoDgB,SAAS,CAACf,cAA9D,EAA8EmB,UAAU,CAACyC,SAAX,GAAuB,EAArG,EAAyGxE,oBAAoB,GAAG,CAAhI,CAAvC;IACA,MAAMgH,MAAM,GAAGC,cAAc,CAACvF,MAAD,EAASC,SAAT,EAAoBE,OAApB,EAA6BC,iBAA7B,CAA7B;IACA,MAAMuD,iBAAiB,GAAG6B,oBAAoB,CAACF,MAAD,EAAShD,cAAc,CAACf,OAAxB,EAAiCsB,WAAjC,CAA9C,CAxCuC,CA0CvC;;IACA3G,QAAQ,CAACuJ,SAAT,CAAmB,MAAM;MACvBhC,mBAAmB,CAACE,iBAAD,CAAnB;IACD,CAFD;IAGAjB,aAAa,CAACgD,KAAd,CAAoB,IAApB,EAA0BrB,0BAA1B;IACA,OAAOV,iBAAP;EACD,CAhDD;;EAiDA,MAAMgC,wBAAwB,GAAG,MAAM;IACrC,MAAML,MAAM,GAAGC,cAAc,CAACvF,MAAD,EAASC,SAAT,EAAoBE,OAApB,EAA6BC,iBAA7B,CAA7B;IACA,MAAMuD,iBAAiB,GAAG6B,oBAAoB,CAACF,MAAD,EAAShD,cAAc,CAACf,OAAxB,EAAiCsB,WAAjC,CAA9C;IACAY,mBAAmB,CAACE,iBAAD,CAAnB;EACD,CAJD;;EAKA,MAAMiC,YAAY,GAAGtJ,gBAAgB,CAACuJ,KAAK,IAAI;IAC7C,MAAM;MACJtB,SADI;MAEJC;IAFI,IAGFqB,KAAK,CAACC,aAHV,CAD6C,CAM7C;;IACA,IAAIvB,SAAS,GAAG,CAAhB,EAAmB;MACjB;IACD;;IACD,IAAIvD,KAAK,CAAC3B,SAAN,KAAoB,KAAxB,EAA+B;MAC7B,IAAImF,UAAU,GAAG,CAAjB,EAAoB;QAClB;MACD;IACF;;IACD,IAAIxD,KAAK,CAAC3B,SAAN,KAAoB,KAAxB,EAA+B;MAC7B,IAAImF,UAAU,GAAG,CAAjB,EAAoB;QAClB;MACD;IACF;;IACD,MAAMb,iBAAiB,GAAGU,0BAA0B,EAApD;IACArE,MAAM,CAACuB,OAAP,CAAe6C,YAAf,CAA4B,sBAA5B,EAAoD;MAClD3F,GAAG,EAAE8F,SAD6C;MAElD7F,IAAI,EAAE8F,UAF4C;MAGlD/B,aAAa,EAAEkB;IAHmC,CAApD;EAKD,CA1BoC,CAArC;EA2BA,MAAMoC,WAAW,GAAGzJ,gBAAgB,CAACuJ,KAAK,IAAI;IAC5C7F,MAAM,CAACuB,OAAP,CAAe6C,YAAf,CAA4B,sBAA5B,EAAoD,EAApD,EAAwDyB,KAAxD;EACD,CAFmC,CAApC;EAGA,MAAMG,eAAe,GAAG1J,gBAAgB,CAACuJ,KAAK,IAAI;IAChD7F,MAAM,CAACuB,OAAP,CAAe6C,YAAf,CAA4B,0BAA5B,EAAwD,EAAxD,EAA4DyB,KAA5D;EACD,CAFuC,CAAxC;;EAGA,MAAMI,OAAO,GAAG,YAAiB;IAAA,IAAhBC,MAAgB,uEAAP,EAAO;;IAC/B,IAAI,CAACA,MAAM,CAAChD,IAAR,IAAgB,CAAC7B,WAAW,CAAC1D,KAAjC,EAAwC;MACtC,OAAO,EAAP;IACD;;IACD,MAAMwI,iBAAiB,GAAGD,MAAM,CAACzD,aAAP,IAAwBA,aAAlD;IACA,MAAM2D,aAAa,GAAG,CAAC1F,mBAAD,IAAwBwF,MAAM,CAACG,QAAP,KAAoBzD,SAA5C,IAAyDlC,mBAAmB,IAAIwF,MAAM,CAACG,QAAP,KAAoB,QAA1H;IACA,MAAMC,eAAe,GAAGJ,MAAM,CAACG,QAAP,KAAoBzD,SAA5C;IACA,IAAI2D,cAAJ,CAP+B,CAQ/B;IACA;;IACA,QAAQL,MAAM,CAACG,QAAf;MACE,KAAK,KAAL;QACEE,cAAc,GAAG,CAAjB;QACA;;MACF,KAAK,QAAL;QACEA,cAAc,GAAG/F,UAAU,CAAC/B,GAAX,CAAemC,MAAf,GAAwBS,WAAW,CAAC6B,IAAZ,CAAiBtC,MAA1D;QACA;;MACF,KAAKgC,SAAL;QACE2D,cAAc,GAAG/F,UAAU,CAAC/B,GAAX,CAAemC,MAAhC;QACA;IATJ;;IAWA,MAAM4F,SAAS,GAAGN,MAAM,CAAChD,IAAP,IAAe7B,WAAW,CAAC6B,IAA7C;IACA,MAAMuD,gBAAgB,GAAGN,iBAAiB,CAACnC,aAA3C;IACA,MAAM0C,eAAe,GAAG5B,IAAI,CAAC6B,GAAL,CAASR,iBAAiB,CAAClC,YAA3B,EAAyCuC,SAAS,CAAC5F,MAAnD,CAAxB;IACA,MAAMgG,UAAU,GAAGV,MAAM,CAAChD,IAAP,GAAcvF,KAAK,CAAC,CAAD,EAAIuI,MAAM,CAAChD,IAAP,CAAYtC,MAAhB,CAAnB,GAA6CjD,KAAK,CAAC8I,gBAAD,EAAmBC,eAAnB,CAArE;IACA,IAAIG,eAAe,GAAG,CAAC,CAAvB;;IACA,IAAI,CAACP,eAAD,IAAoBvD,WAAW,CAACC,QAAZ,KAAyB,CAAC,CAAlD,EAAqD;MACnD,IAAID,WAAW,CAACC,QAAZ,GAAuByD,gBAA3B,EAA6C;QAC3CI,eAAe,GAAG9D,WAAW,CAACC,QAA9B;QACA4D,UAAU,CAACE,OAAX,CAAmBD,eAAnB;MACD;;MACD,IAAI9D,WAAW,CAACC,QAAZ,IAAwB0D,eAA5B,EAA6C;QAC3CG,eAAe,GAAG9D,WAAW,CAACC,QAA9B;QACA4D,UAAU,CAACG,IAAX,CAAgBF,eAAhB;MACD;IACF;;IACD,MAAM3D,IAAI,GAAG,EAAb;IACA,MAAM8D,QAAQ,GAAG/G,SAAS,CAACgH,SAAV,EAAqB7D,GAAtC;IACA,MAAM8D,eAAe,GAAGjK,2BAA2B,CAAC+C,MAAD,CAAnD;IACA4G,UAAU,CAACO,OAAX,CAAmBC,cAAc,IAAI;MACnC,MAAM;QACJ/D,EADI;QAEJgE;MAFI,IAGFb,SAAS,CAACY,cAAD,CAHb,CADmC,CAMnC;;MACA,IAAIhF,UAAJ,EAAgB;QACd,MAAMkF,cAAc,GAAG7G,aAAa,CAAC/B,IAAd,CAAmBkC,MAA1C;QACA,MAAM2G,aAAa,GAAGrH,cAAc,CAACU,MAAf,GAAwBH,aAAa,CAAC+G,KAAd,CAAoB5G,MAAlE;QACAZ,MAAM,CAACuB,OAAP,CAAekG,gBAAf,CAAgC;UAC9BC,KAAK,EAAErE,EADuB;UAE9BiE,cAF8B;UAG9BC,aAH8B;UAI9BI,OAAO,EAAEzH;QAJqB,CAAhC;;QAMA,IAAIO,aAAa,CAAC/B,IAAd,CAAmBkC,MAAnB,GAA4B,CAAhC,EAAmC;UACjCZ,MAAM,CAACuB,OAAP,CAAekG,gBAAf,CAAgC;YAC9BC,KAAK,EAAErE,EADuB;YAE9BiE,cAAc,EAAE,CAFc;YAG9BC,aAAa,EAAE9G,aAAa,CAAC/B,IAAd,CAAmBkC,MAHJ;YAI9B+G,OAAO,EAAEzH;UAJqB,CAAhC;QAMD;;QACD,IAAIO,aAAa,CAAC+G,KAAd,CAAoB5G,MAApB,GAA6B,CAAjC,EAAoC;UAClCZ,MAAM,CAACuB,OAAP,CAAekG,gBAAf,CAAgC;YAC9BC,KAAK,EAAErE,EADuB;YAE9BiE,cAAc,EAAEpH,cAAc,CAACU,MAAf,GAAwBH,aAAa,CAAC+G,KAAd,CAAoB5G,MAF9B;YAG9B2G,aAAa,EAAErH,cAAc,CAACU,MAHA;YAI9B+G,OAAO,EAAEzH;UAJqB,CAAhC;QAMD;MACF;;MACD,MAAM0H,QAAQ,GAAG3G,SAAS,EAAEoC,EAAX,KAAkBA,EAAnC;MACA,MAAMwE,aAAa,GAAG,CAAC7H,MAAM,CAACuB,OAAP,CAAeuG,gBAAf,CAAgCzE,EAAhC,CAAD,GAAuCrD,MAAM,CAACuB,OAAP,CAAewG,qBAAf,CAAqC1E,EAArC,CAAvC,GAAkF,MAAxG;MACA,IAAI2E,UAAJ;;MACA,IAAI5G,kBAAkB,CAACiC,EAAD,CAAlB,IAA0B,IAA9B,EAAoC;QAClC2E,UAAU,GAAG,KAAb;MACD,CAFD,MAEO;QACLA,UAAU,GAAGhI,MAAM,CAACuB,OAAP,CAAe0G,eAAf,CAA+B5E,EAA/B,CAAb;MACD;;MACD,IAAI6E,cAAc,GAAG,KAArB;;MACA,IAAIhC,MAAM,CAACG,QAAP,KAAoBzD,SAAxB,EAAmC;QACjCsF,cAAc,GAAGd,cAAc,KAAK,CAApC;MACD;;MACD,IAAIe,aAAa,GAAG,KAApB;;MACA,IAAI/B,aAAJ,EAAmB;QACjB,IAAI,CAACE,eAAL,EAAsB;UACpB,MAAM8B,SAAS,GAAG/G,WAAW,CAAC6B,IAAZ,CAAiBtC,MAAjB,GAA0B,CAA5C;UACA,MAAMyH,qBAAqB,GAAGjB,cAAc,KAAKgB,SAAjD;;UACA,IAAIC,qBAAJ,EAA2B;YACzBF,aAAa,GAAG,IAAhB;UACD;QACF,CAND,MAMO;UACLA,aAAa,GAAGf,cAAc,KAAKZ,SAAS,CAAC5F,MAAV,GAAmB,CAAtD;QACD;MACF;;MACD,MAAM0H,YAAY,GAAGlB,cAAc,KAAKP,eAAxC;MACA,MAAM0B,YAAY,GAAGD,YAArB;MACA,IAAIE,YAAY,GAAG,IAAnB;;MACA,IAAItH,YAAY,KAAK,IAAjB,IAAyBA,YAAY,CAACmC,EAAb,KAAoBA,EAAjD,EAAqD;QACnD,MAAMoF,UAAU,GAAGzI,MAAM,CAACuB,OAAP,CAAemH,aAAf,CAA6BrF,EAA7B,EAAiCnC,YAAY,CAACsC,KAA9C,CAAnB;QACAgF,YAAY,GAAGC,UAAU,CAACE,QAAX,KAAwB,MAAxB,GAAiCzH,YAAY,CAACsC,KAA9C,GAAsD,IAArE;MACD;;MACD,IAAIoF,oBAAoB,GAAGzC,iBAA3B;;MACA,IAAI,CAACG,eAAD,IAAoB3D,aAAa,CAACpB,OAAlC,IAA6C6F,cAAc,IAAIzE,aAAa,CAACpB,OAAd,CAAsByC,aAArF,IAAsGoD,cAAc,GAAGzE,aAAa,CAACpB,OAAd,CAAsB0C,YAAjJ,EAA+J;QAC7J2E,oBAAoB,GAAGjG,aAAa,CAACpB,OAArC;MACD;;MACD,MAAMsH,UAAU,GAAGC,iBAAiB,CAAC5B,eAAD,EAAkB0B,oBAAlB,EAAwC5H,KAAK,CAAC3B,SAA9C,EAAyDoB,aAAa,CAAC/B,IAAd,CAAmBkC,MAA5E,CAApC;MACA,MAAMoC,QAAQ,GAAG,CAAC3B,WAAW,EAAE1D,KAAb,EAAoBqG,aAApB,IAAqC,CAAtC,IAA2CuC,cAA3C,GAA4Da,cAA7E;MACAlE,IAAI,CAAC6D,IAAL,EAAW,aAAa1I,IAAI,CAAC4B,SAAS,CAAC8I,KAAV,CAAgB3F,GAAjB,EAAsBpH,QAAQ,CAAC;QACzDoH,GAAG,EAAEiE,KADoD;QAEzDK,KAAK,EAAErE,EAFkD;QAGzD2F,KAAK,EAAEhG,QAHkD;QAIzDiG,QAAQ,EAAEjB,UAJ+C;QAKzDkB,SAAS,EAAEhD,MAAM,CAAChD,IAAP,GAAcN,SAAd,GAA0BzB,QAAQ,CAACgI,SAAT,CAAmB/B,cAAnB,CALoB;QAMzDyB,UAAU,EAAEA,UAN6C;QAOzDxI,UAAU,EAAEA,UAP6C;QAQzDyC,SAAS,EAAE+E,aAR8C;QASzDW,YAAY,EAAEA,YAT2C;QAUzD/H,aAAa,EAAEA,aAV0C;QAWzDP,cAAc,EAAEA,cAXyC;QAYzDuC,aAAa,EAAEmG,oBAZ0C;QAazDQ,kBAAkB,EAAExB,QAAQ,GAAG7E,WAAW,CAACO,WAAf,GAA6BV,SAbA;QAczDsF,cAAc,EAAEA,cAdyC;QAezDC,aAAa,EAAEA,aAf0C;QAgBzDI,YAAY,EAAEA;MAhB2C,CAAD,EAiBvDvB,QAjBuD,CAA9B,EAiBd3D,EAjBc,CAA5B;;MAkBA,IAAIkF,YAAJ,EAAkB;QAChB;MACD;;MACD,MAAMc,KAAK,GAAGxI,MAAM,CAACyI,GAAP,CAAWjG,EAAX,CAAd;;MACA,IAAIgG,KAAJ,EAAW;QACTnG,IAAI,CAAC6D,IAAL,CAAUsC,KAAV;MACD;;MACD,IAAIlB,aAAJ,EAAmB;QACjBjF,IAAI,CAAC6D,IAAL,CAAU/G,MAAM,CAACuB,OAAP,CAAegI,gCAAf,GAAkD;UAC1DC,SAAS,EAAEnG;QAD+C,CAAlD,CAAV;MAGD;IACF,CApGD;IAqGA,OAAOH,IAAP;EACD,CA7ID;;EA8IA,MAAMuG,wBAAwB,GAAGnJ,SAAS,CAACoJ,KAAV,IAAmBvH,iBAAiB,IAAI7B,SAAS,CAACoJ,KAAnF;EACA,MAAMC,aAAa,GAAG1N,KAAK,CAACgH,OAAN,CAAc,OAAO;IACzC2G,SAAS,EAAE,CAACH,wBAAD,GAA4B,QAA5B,GAAuC7G,SADT;IAEzCiH,SAAS,EAAE5J,SAAS,CAAC6J,UAAV,GAAuB,QAAvB,GAAkClH;EAFJ,CAAP,CAAd,EAGlB,CAAC6G,wBAAD,EAA2BxJ,SAAS,CAAC6J,UAArC,CAHkB,CAAtB;EAIA,MAAM7H,WAAW,GAAGhG,KAAK,CAACgH,OAAN,CAAc,MAAM;IACtC;IACA;IACA;IACA,MAAMf,MAAM,GAAG4C,IAAI,CAACiF,GAAL,CAAS/H,aAAT,EAAwB,CAAxB,CAAf;IACA,MAAMgI,IAAI,GAAG;MACXN,KAAK,EAAED,wBAAwB,GAAGtH,iBAAH,GAAuB,MAD3C;MAEXD;IAFW,CAAb;;IAIA,IAAIjC,SAAS,CAAC6J,UAAd,EAA0B;MACxB,IAAIzI,WAAW,CAAC6B,IAAZ,CAAiBtC,MAAjB,KAA4B,CAAhC,EAAmC;QACjCoJ,IAAI,CAAC9H,MAAL,GAAcnE,uBAAuB,CAACiC,MAAD,CAArC,CADiC,CACc;MAChD,CAFD,MAEO;QACLgK,IAAI,CAAC9H,MAAL,GAAcF,aAAd;MACD;IACF;;IACD,OAAOgI,IAAP;EACD,CAjBmB,EAiBjB,CAAChK,MAAD,EAASmC,iBAAT,EAA4BH,aAA5B,EAA2CyH,wBAA3C,EAAqExJ,SAAS,CAAC6J,UAA/E,EAA2FzI,WAAW,CAAC6B,IAAZ,CAAiBtC,MAA5G,CAjBiB,CAApB;EAkBA3E,KAAK,CAACgO,SAAN,CAAgB,MAAM;IACpBjK,MAAM,CAACuB,OAAP,CAAe6C,YAAf,CAA4B,kCAA5B;EACD,CAFD,EAEG,CAACpE,MAAD,EAASiC,WAAT,CAFH;EAGA7F,iBAAiB,CAAC,MAAM;IACtB;IACA4D,MAAM,CAACuB,OAAP,CAAec,MAAf;EACD,CAHgB,EAGd,CAACrC,MAAD,EAASmB,QAAQ,CAAC+I,sBAAlB,CAHc,CAAjB;EAIA9N,iBAAiB,CAAC,MAAM;IACtB,IAAI+D,OAAJ,EAAa;MACX;MACAwB,WAAW,CAACJ,OAAZ,CAAoBiD,UAApB,GAAiC,CAAjC;MACA7C,WAAW,CAACJ,OAAZ,CAAoBgD,SAApB,GAAgC,CAAhC;IACD;EACF,CANgB,EAMd,CAACpE,OAAD,EAAUmB,WAAV,EAAuBK,WAAvB,CANc,CAAjB;EAOA7E,UAAU,CAACwD,SAAS,CAACoJ,KAAV,KAAoB,CAArB,EAAwB,MAAM;IACtC,MAAMpE,MAAM,GAAGC,cAAc,CAACvF,MAAD,EAASC,SAAT,EAAoBE,OAApB,EAA6BC,iBAA7B,CAA7B;IACA,MAAM+J,oBAAoB,GAAG3E,oBAAoB,CAACF,MAAD,EAAShD,cAAc,CAACf,OAAxB,EAAiCsB,WAAjC,CAAjD;IACAY,mBAAmB,CAAC0G,oBAAD,CAAnB;IACAnK,MAAM,CAACuB,OAAP,CAAe6C,YAAf,CAA4B,sBAA5B,EAAoD;MAClD3F,GAAG,EAAE6D,cAAc,CAACf,OAAf,CAAuB9C,GADsB;MAElDC,IAAI,EAAE4D,cAAc,CAACf,OAAf,CAAuB7C,IAFqB;MAGlD+D,aAAa,EAAE0H;IAHmC,CAApD;EAKD,CATS,CAAV;EAUAnK,MAAM,CAACuB,OAAP,CAAe6I,QAAf,CAAwB,SAAxB,EAAmC;IACjC3G,mBAAmB,EAAEkC;EADY,CAAnC;EAGAlI,sBAAsB,CAACuC,MAAD,EAAS,eAAT,EAA0B2F,wBAA1B,CAAtB;EACAlI,sBAAsB,CAACuC,MAAD,EAAS,iBAAT,EAA4B2F,wBAA5B,CAAtB;EACAlI,sBAAsB,CAACuC,MAAD,EAAS,oBAAT,EAA+B2F,wBAA/B,CAAtB;EACA,OAAO;IACLlD,aADK;IAEL3B,SAFK;IAGLmF,OAHK;IAILoE,iBAAiB,EAAE,OAAO;MACxBC,GAAG,EAAE7I;IADmB,CAAP,CAJd;IAOL8I,gBAAgB,EAAE,OAAO;MACvBD,GAAG,EAAE3I,WADkB;MAEvB6I,QAAQ,EAAE,CAAC,CAFY;MAGvBC,QAAQ,EAAE7E,YAHa;MAIvB8E,OAAO,EAAE3E,WAJc;MAKvB4E,WAAW,EAAE3E,eALU;MAMvB4E,KAAK,EAAEjB,aANgB;MAOvBkB,IAAI,EAAE;IAPiB,CAAP,CAPb;IAgBLC,eAAe,EAAE,OAAO;MACtBF,KAAK,EAAE3I,WADe;MAEtB4I,IAAI,EAAE;IAFgB,CAAP,CAhBZ;IAoBLE,kBAAkB,EAAE,OAAO;MACzBF,IAAI,EAAE;IADmB,CAAP,CApBf;IAuBLG,yBAAyB,EAAE,OAAO;MAChCV,GAAG,EAAEzI,oBAD2B;MAEhCgJ,IAAI,EAAE;IAF0B,CAAP,CAvBtB;IA2BLI,2BAA2B,EAAE,OAAO;MAClCX,GAAG,EAAEvI,sBAD6B;MAElC8I,IAAI,EAAE;IAF4B,CAAP;EA3BxB,CAAP;AAgCD,CAtYM;;AAuYP,SAAStF,cAAT,CAAwBvF,MAAxB,EAAgCC,SAAhC,EAA2CE,OAA3C,EAAoDC,iBAApD,EAAuE;EACrE,MAAMC,UAAU,GAAGlD,sBAAsB,CAAC6C,MAAM,CAACuB,OAAP,CAAesC,KAAhB,CAAzC;EACA,MAAMxC,WAAW,GAAG7D,cAAc,CAACwC,MAAD,EAASC,SAAT,CAAlC;EACA,MAAMC,cAAc,GAAGnD,oCAAoC,CAACiD,MAAD,CAA3D;EACA,MAAMwJ,SAAS,GAAGxJ,MAAM,CAACuB,OAAP,CAAesC,KAAf,CAAqBX,IAArB,CAA0BgI,UAA1B,CAAqCC,EAArC,CAAwC,CAAC,CAAzC,CAAlB;EACA,MAAMC,UAAU,GAAGlL,cAAc,CAACiL,EAAf,CAAkB,CAAC,CAAnB,CAAnB;EACA,OAAO;IACLhL,OADK;IAELC,iBAFK;IAGLJ,MAHK;IAIL8J,UAAU,EAAE7J,SAAS,CAAC6J,UAJjB;IAKL7K,WAAW,EAAEgB,SAAS,CAAChB,WALlB;IAMLC,cAAc,EAAEe,SAAS,CAACf,cANrB;IAOLmM,eAAe,EAAEhL,UAAU,CAACgL,eAPvB;IAQLlJ,iBAAiB,EAAE9B,UAAU,CAAC8B,iBARzB;IASLmJ,kBAAkB,EAAEjL,UAAU,CAACkL,iBAAX,CAA6B7B,KAT5C;IAUL8B,mBAAmB,EAAEnL,UAAU,CAACkL,iBAAX,CAA6BrJ,MAV7C;IAWLuJ,aAAa,EAAEjC,SAAS,KAAK5G,SAAd,GAA0B5C,MAAM,CAACuB,OAAP,CAAewG,qBAAf,CAAqCyB,SAArC,CAA1B,GAA4E,CAXtF;IAYLkC,eAAe,EAAEN,UAAU,EAAEO,aAAZ,IAA6B,CAZzC;IAaLxK,QAAQ,EAAEtD,oBAAoB,CAACmC,MAAM,CAACuB,OAAP,CAAesC,KAAhB,CAbzB;IAcLqD,eAAe,EAAEjK,2BAA2B,CAAC+C,MAAD,CAdvC;IAeLkD,IAAI,EAAE7B,WAAW,CAAC6B,IAfb;IAgBLvF,KAAK,EAAE0D,WAAW,CAAC1D,KAhBd;IAiBL8C,aAAa,EAAEzD,0CAA0C,CAACgD,MAAD,CAjBpD;IAkBLE;EAlBK,CAAP;AAoBD;;AACD,SAASsF,oBAAT,CAA8BF,MAA9B,EAAsChD,cAAtC,EAAsDO,WAAtD,EAAmE;EACjE,IAAIJ,aAAJ;;EACA,IAAI,CAAC6C,MAAM,CAACnF,OAAZ,EAAqB;IACnBsC,aAAa,GAAG;MACduB,aAAa,EAAE,CADD;MAEdC,YAAY,EAAEqB,MAAM,CAACpC,IAAP,CAAYtC,MAFZ;MAGdgL,gBAAgB,EAAE,CAHJ;MAIdC,eAAe,EAAEvG,MAAM,CAACpF,cAAP,CAAsBU;IAJzB,CAAhB;EAMD,CAPD,MAOO;IACL,MAAM;MACJnC,GADI;MAEJC;IAFI,IAGF4D,cAHJ;IAIA,MAAMwJ,QAAQ,GAAGhH,IAAI,CAACC,GAAL,CAASrG,IAAT,IAAiB4G,MAAM,CAAC+F,eAAzC,CALK,CAOL;IACA;;IACA,MAAMrH,aAAa,GAAGc,IAAI,CAAC6B,GAAL,CAASoF,uBAAuB,CAACzG,MAAD,EAAS7G,GAAT,EAAc;MAClEuN,OAAO,EAAE,IADyD;MAElEC,YAAY,EAAE3G,MAAM,CAACnE,QAAP,CAAgBgI,SAAhB,CAA0B7D,MAAM,CAACnE,QAAP,CAAgBgI,SAAhB,CAA0BvI,MAA1B,GAAmC,CAA7D,IAAkE0E,MAAM,CAACmG;IAFrB,CAAd,CAAhC,EAGlBnG,MAAM,CAACnE,QAAP,CAAgBgI,SAAhB,CAA0BvI,MAA1B,GAAmC,CAHjB,CAAtB;IAIA,MAAMqD,YAAY,GAAGqB,MAAM,CAACwE,UAAP,GAAoB9F,aAAa,GAAGsB,MAAM,CAACpC,IAAP,CAAYtC,MAAhD,GAAyDmL,uBAAuB,CAACzG,MAAD,EAAS7G,GAAG,GAAG6G,MAAM,CAACkG,mBAAtB,CAArG;IACA,IAAII,gBAAgB,GAAG,CAAvB;IACA,IAAIC,eAAe,GAAGvG,MAAM,CAAC4B,eAAP,CAAuBtG,MAA7C;;IACA,IAAI0E,MAAM,CAAClF,iBAAX,EAA8B;MAC5B,IAAI8L,oBAAoB,GAAG,KAA3B;MACA,MAAM,CAACzF,gBAAD,EAAmBC,eAAnB,IAAsCyF,kBAAkB,CAAC;QAC7DC,UAAU,EAAEpI,aADiD;QAE7DoE,SAAS,EAAEnE,YAFkD;QAG7DoI,aAAa,EAAE,CAH8C;QAI7DC,YAAY,EAAEhH,MAAM,CAACpC,IAAP,CAAYtC,MAJmC;QAK7D2L,YAAY,EAAE1J,WAAW,CAACtD,MAAZ,CAAmBiN,SAL4B;QAM7DC,WAAW,EAAE5J,WAAW,CAACtD,MAAZ,CAAmBmN,QAN6B;QAO7DvD,SAAS,EAAE7D,MAAM,CAACnE,QAAP,CAAgBgI,SAPkC;QAQ7DwD,QAAQ,EAAErH,MAAM,CAACmG;MAR4C,CAAD,CAA9D;;MAUA,KAAK,IAAImB,CAAC,GAAGnG,gBAAb,EAA+BmG,CAAC,GAAGlG,eAAJ,IAAuB,CAACwF,oBAAvD,EAA6EU,CAAC,IAAI,CAAlF,EAAqF;QACnF,MAAMxJ,GAAG,GAAGkC,MAAM,CAACpC,IAAP,CAAY0J,CAAZ,CAAZ;QACAV,oBAAoB,GAAG5G,MAAM,CAACtF,MAAP,CAAcuB,OAAd,CAAsBuG,gBAAtB,CAAuC1E,GAAG,CAACC,EAA3C,CAAvB;MACD;;MACD,IAAI,CAAC6I,oBAAL,EAA2B;QACzBN,gBAAgB,GAAGiB,YAAY,CAACf,QAAD,EAAWxG,MAAM,CAAC4B,eAAlB,EAAmC;UAChE8E,OAAO,EAAE,IADuD;UAEhEC,YAAY,EAAE3G,MAAM,CAACnD;QAF2C,CAAnC,CAA/B;QAIA0J,eAAe,GAAGgB,YAAY,CAACf,QAAQ,GAAGxG,MAAM,CAACgG,kBAAnB,EAAuChG,MAAM,CAAC4B,eAA9C,CAA9B;MACD;IACF;;IACDzE,aAAa,GAAG;MACduB,aADc;MAEdC,YAFc;MAGd2H,gBAHc;MAIdC;IAJc,CAAhB;EAMD;;EACD,MAAMiB,mBAAmB,GAAGC,mBAAmB,CAACzH,MAAD,EAAS7C,aAAT,EAAwBI,WAAxB,CAA/C;EACA,OAAOiK,mBAAP;AACD;;AACD,SAASf,uBAAT,CAAiCzG,MAAjC,EAAyC0H,MAAzC,EAAiDC,OAAjD,EAA0D;EACxD,MAAMC,kCAAkC,GAAG5H,MAAM,CAACtF,MAAP,CAAcuB,OAAd,CAAsB4L,uBAAtB,EAA3C;EACA,IAAIC,eAAe,GAAGF,kCAAkC,KAAKG,QAA7D;;EACA,IAAI/H,MAAM,CAAC3H,KAAP,EAAcsG,YAAd,IAA8B,CAACmJ,eAAnC,EAAoD;IAClD;IACAA,eAAe,GAAGF,kCAAkC,IAAI5H,MAAM,CAAC3H,KAAP,CAAasG,YAArE;EACD;;EACD,MAAMqJ,sCAAsC,GAAG5P,KAAK,CAACwP,kCAAkC,IAAI5H,MAAM,CAAC3H,KAAP,EAAcqG,aAAd,IAA+B,CAAnC,CAAnC,EAA0E,CAA1E,EAA6EsB,MAAM,CAACnE,QAAP,CAAgBgI,SAAhB,CAA0BvI,MAAvG,CAApD;;EACA,IAAIwM,eAAe,IAAI9H,MAAM,CAACnE,QAAP,CAAgBgI,SAAhB,CAA0BmE,sCAA1B,KAAqEN,MAA5F,EAAoG;IAClG;IACA;IACA,OAAOH,YAAY,CAACG,MAAD,EAAS1H,MAAM,CAACnE,QAAP,CAAgBgI,SAAzB,EAAoC8D,OAApC,CAAnB;EACD,CAZuD,CAcxD;EACA;EACA;EACA;;;EACA,OAAOM,iBAAiB,CAACP,MAAD,EAAS1H,MAAM,CAACnE,QAAP,CAAgBgI,SAAzB,EAAoCmE,sCAApC,EAA4EL,OAA5E,CAAxB;AACD;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASF,mBAAT,CAA6BzH,MAA7B,EAAqC3B,iBAArC,EAAwDd,WAAxD,EAAqE;EACnE,MAAM,CAAC4D,gBAAD,EAAmBC,eAAnB,IAAsCyF,kBAAkB,CAAC;IAC7DC,UAAU,EAAEzI,iBAAiB,CAACK,aAD+B;IAE7DoE,SAAS,EAAEzE,iBAAiB,CAACM,YAFgC;IAG7DoI,aAAa,EAAE,CAH8C;IAI7DC,YAAY,EAAEhH,MAAM,CAACpC,IAAP,CAAYtC,MAJmC;IAK7D2L,YAAY,EAAE1J,WAAW,CAACtD,MAAZ,CAAmBiN,SAL4B;IAM7DC,WAAW,EAAE5J,WAAW,CAACtD,MAAZ,CAAmBmN,QAN6B;IAO7DvD,SAAS,EAAE7D,MAAM,CAACnE,QAAP,CAAgBgI,SAPkC;IAQ7DwD,QAAQ,EAAErH,MAAM,CAACmG;EAR4C,CAAD,CAA9D;EAUA,MAAM,CAAC+B,0BAAD,EAA6BC,kBAA7B,IAAmDtB,kBAAkB,CAAC;IAC1EC,UAAU,EAAEzI,iBAAiB,CAACiI,gBAD4C;IAE1ExD,SAAS,EAAEzE,iBAAiB,CAACkI,eAF6C;IAG1EQ,aAAa,EAAE/G,MAAM,CAAC7E,aAAP,CAAqB/B,IAArB,CAA0BkC,MAHiC;IAI1E0L,YAAY,EAAEhH,MAAM,CAACpF,cAAP,CAAsBU,MAAtB,GAA+B0E,MAAM,CAAC7E,aAAP,CAAqB+G,KAArB,CAA2B5G,MAJE;IAK1E2L,YAAY,EAAE1J,WAAW,CAACtD,MAAZ,CAAmBmO,YALyC;IAM1EjB,WAAW,EAAE5J,WAAW,CAACtD,MAAZ,CAAmBoO,WAN0C;IAO1ExE,SAAS,EAAE7D,MAAM,CAAC4B,eAPwD;IAQ1EyF,QAAQ,EAAErH,MAAM,CAACoG;EARyD,CAAD,CAA3E;EAUA,MAAMkC,mBAAmB,GAAG9P,gCAAgC,CAAC;IAC3D8P,mBAAmB,EAAEJ,0BADsC;IAE3DxN,MAAM,EAAEsF,MAAM,CAACtF,MAF4C;IAG3DyG,gBAH2D;IAI3DC,eAJ2D;IAK3DmH,WAAW,EAAEvI,MAAM,CAACpC;EALuC,CAAD,CAA5D;EAOA,OAAO;IACLc,aAAa,EAAEyC,gBADV;IAELxC,YAAY,EAAEyC,eAFT;IAGLkF,gBAAgB,EAAEgC,mBAHb;IAIL/B,eAAe,EAAE4B;EAJZ,CAAP;AAMD;AACD;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASZ,YAAT,CAAsBG,MAAtB,EAA8B7D,SAA9B,EAA2G;EAAA,IAAlE8D,OAAkE,uEAAxDrK,SAAwD;EAAA,IAA7CkL,UAA6C,uEAAhC,CAAgC;EAAA,IAA7BC,QAA6B,uEAAlB5E,SAAS,CAACvI,MAAQ;;EACzG,IAAIuI,SAAS,CAACvI,MAAV,IAAoB,CAAxB,EAA2B;IACzB,OAAO,CAAC,CAAR;EACD;;EACD,IAAIkN,UAAU,IAAIC,QAAlB,EAA4B;IAC1B,OAAOD,UAAP;EACD;;EACD,MAAME,KAAK,GAAGF,UAAU,GAAGhJ,IAAI,CAACmJ,KAAL,CAAW,CAACF,QAAQ,GAAGD,UAAZ,IAA0B,CAArC,CAA3B;EACA,MAAMzH,QAAQ,GAAG8C,SAAS,CAAC6E,KAAD,CAA1B;EACA,IAAIE,QAAJ;;EACA,IAAIjB,OAAO,EAAEjB,OAAb,EAAsB;IACpB,MAAMtC,KAAK,GAAG,CAACsE,KAAK,KAAK7E,SAAS,CAACvI,MAAV,GAAmB,CAA7B,GAAiCqM,OAAO,CAAChB,YAAzC,GAAwD9C,SAAS,CAAC6E,KAAK,GAAG,CAAT,CAAlE,IAAiF3H,QAA/F;IACA6H,QAAQ,GAAGlB,MAAM,GAAGtD,KAAT,GAAiBrD,QAA5B;EACD,CAHD,MAGO;IACL6H,QAAQ,GAAGlB,MAAM,IAAI3G,QAArB;EACD;;EACD,OAAO6H,QAAQ,GAAGrB,YAAY,CAACG,MAAD,EAAS7D,SAAT,EAAoB8D,OAApB,EAA6Ba,UAA7B,EAAyCE,KAAzC,CAAf,GAAiEnB,YAAY,CAACG,MAAD,EAAS7D,SAAT,EAAoB8D,OAApB,EAA6Be,KAAK,GAAG,CAArC,EAAwCD,QAAxC,CAA5F;AACD;;AACD,SAASR,iBAAT,CAA2BP,MAA3B,EAAmC7D,SAAnC,EAA8CH,KAA9C,EAA0E;EAAA,IAArBiE,OAAqB,uEAAXrK,SAAW;EACxE,IAAIuL,QAAQ,GAAG,CAAf;;EACA,OAAOnF,KAAK,GAAGG,SAAS,CAACvI,MAAlB,IAA4BkE,IAAI,CAACC,GAAL,CAASoE,SAAS,CAACH,KAAD,CAAlB,IAA6BgE,MAAhE,EAAwE;IACtEhE,KAAK,IAAImF,QAAT;IACAA,QAAQ,IAAI,CAAZ;EACD;;EACD,OAAOtB,YAAY,CAACG,MAAD,EAAS7D,SAAT,EAAoB8D,OAApB,EAA6BnI,IAAI,CAACmJ,KAAL,CAAWjF,KAAK,GAAG,CAAnB,CAA7B,EAAoDlE,IAAI,CAAC6B,GAAL,CAASqC,KAAT,EAAgBG,SAAS,CAACvI,MAA1B,CAApD,CAAnB;AACD;;AACD,SAASuL,kBAAT,OASG;EAAA,IATyB;IAC1BC,UAD0B;IAE1BhE,SAF0B;IAG1BmE,YAH0B;IAI1BE,WAJ0B;IAK1BJ,aAL0B;IAM1BC,YAN0B;IAO1BnD,SAP0B;IAQ1BwD;EAR0B,CASzB;EACD,MAAMyB,aAAa,GAAGjF,SAAS,CAACiD,UAAD,CAAT,GAAwBG,YAA9C;EACA,MAAMN,YAAY,GAAG9C,SAAS,CAACf,SAAD,CAAT,GAAuBqE,WAA5C;EACA,MAAM4B,gBAAgB,GAAGxB,YAAY,CAACuB,aAAD,EAAgBjF,SAAhB,EAA2B;IAC9D6C,OAAO,EAAE,IADqD;IAE9DC,YAAY,EAAE9C,SAAS,CAACA,SAAS,CAACvI,MAAV,GAAmB,CAApB,CAAT,GAAkC+L;EAFc,CAA3B,CAArC;EAIA,MAAM2B,eAAe,GAAGzB,YAAY,CAACZ,YAAD,EAAe9C,SAAf,CAApC;EACA,OAAO,CAACzL,KAAK,CAAC2Q,gBAAD,EAAmBhC,aAAnB,EAAkCC,YAAlC,CAAN,EAAuD5O,KAAK,CAAC4Q,eAAD,EAAkBjC,aAAlB,EAAiCC,YAAjC,CAA5D,CAAP;AACD;;AACD,OAAO,SAAS1I,sBAAT,CAAgC2K,QAAhC,EAA0CC,QAA1C,EAAoD;EACzD,IAAID,QAAQ,KAAKC,QAAjB,EAA2B;IACzB,OAAO,IAAP;EACD;;EACD,OAAOD,QAAQ,CAACvK,aAAT,KAA2BwK,QAAQ,CAACxK,aAApC,IAAqDuK,QAAQ,CAACtK,YAAT,KAA0BuK,QAAQ,CAACvK,YAAxF,IAAwGsK,QAAQ,CAAC3C,gBAAT,KAA8B4C,QAAQ,CAAC5C,gBAA/I,IAAmK2C,QAAQ,CAAC1C,eAAT,KAA6B2C,QAAQ,CAAC3C,eAAhN;AACD;AACD,OAAO,SAAS/C,iBAAT,CAA2B5B,eAA3B,EAA4CzE,aAA5C,EAA2DpD,SAA3D,EAAsEoP,gBAAtE,EAAwF;EAC7F,MAAMC,MAAM,GAAGrP,SAAS,KAAK,KAAd,GAAsB,CAAtB,GAA0B,CAAC,CAA1C;EACA,MAAMX,IAAI,GAAGgQ,MAAM,IAAIxH,eAAe,CAACzE,aAAa,CAACmJ,gBAAf,CAAf,IAAmD,CAAvD,CAAN,IAAmE1E,eAAe,CAACuH,gBAAD,CAAf,IAAqC,CAAxG,CAAb;EACA,OAAO3J,IAAI,CAACC,GAAL,CAASrG,IAAT,CAAP;AACD;;AACD,SAASkG,iBAAT,CAA2BH,EAA3B,EAA+BC,EAA/B,EAAmC;EACjC,IAAID,EAAE,KAAK,CAAP,IAAYC,EAAE,KAAK,CAAvB,EAA0B;IACxB,OAAOnG,eAAe,CAACe,IAAvB;EACD;EACD;;;EACA,IAAIwF,IAAI,CAACC,GAAL,CAASL,EAAT,KAAgBI,IAAI,CAACC,GAAL,CAASN,EAAT,CAApB,EAAkC;IAChC,IAAIC,EAAE,GAAG,CAAT,EAAY;MACV,OAAOnG,eAAe,CAACoQ,IAAvB;IACD,CAFD,MAEO;MACL,OAAOpQ,eAAe,CAACqQ,EAAvB;IACD;EACF,CAND,MAMO;IACL,IAAInK,EAAE,GAAG,CAAT,EAAY;MACV,OAAOlG,eAAe,CAAC8G,KAAvB;IACD,CAFD,MAEO;MACL,OAAO9G,eAAe,CAAC6G,IAAvB;IACD;EACF;EACD;;AACD;;AACD,SAAS5F,kBAAT,CAA4BR,IAA5B,EAAkCK,SAAlC,EAA6CJ,WAA7C,EAA0DC,cAA1D,EAA0EC,cAA1E,EAA0FC,gBAA1F,EAA4G;EAC1G,IAAIJ,IAAI,KAAK,KAAb,EAAoB;IAClB,QAAQK,SAAR;MACE,KAAKd,eAAe,CAAC6G,IAArB;QACE/F,SAAS,GAAGd,eAAe,CAAC8G,KAA5B;QACA;;MACF,KAAK9G,eAAe,CAAC8G,KAArB;QACEhG,SAAS,GAAGd,eAAe,CAAC6G,IAA5B;QACA;;MACF;IAPF;EASD;;EACD,QAAQ/F,SAAR;IACE,KAAKd,eAAe,CAACe,IAArB;MACE,OAAO;QACLoN,QAAQ,EAAEzN,WADL;QAELuN,SAAS,EAAEvN,WAFN;QAGL0O,WAAW,EAAEzO,cAHR;QAILwO,YAAY,EAAExO;MAJT,CAAP;;IAMF,KAAKX,eAAe,CAAC6G,IAArB;MACE,OAAO;QACLsH,QAAQ,EAAE,CADL;QAELF,SAAS,EAAE,CAFN;QAGLmB,WAAW,EAAE,CAHR;QAILD,YAAY,EAAEtO;MAJT,CAAP;;IAMF,KAAKb,eAAe,CAAC8G,KAArB;MACE,OAAO;QACLqH,QAAQ,EAAE,CADL;QAELF,SAAS,EAAE,CAFN;QAGLmB,WAAW,EAAEvO,gBAHR;QAILsO,YAAY,EAAE;MAJT,CAAP;;IAMF,KAAKnP,eAAe,CAACqQ,EAArB;MACE,OAAO;QACLlC,QAAQ,EAAE,CADL;QAELF,SAAS,EAAErN,cAFN;QAGLwO,WAAW,EAAE,CAHR;QAILD,YAAY,EAAE;MAJT,CAAP;;IAMF,KAAKnP,eAAe,CAACoQ,IAArB;MACE,OAAO;QACLjC,QAAQ,EAAEvN,cADL;QAELqN,SAAS,EAAE,CAFN;QAGLmB,WAAW,EAAE,CAHR;QAILD,YAAY,EAAE;MAJT,CAAP;;IAMF;MACE;MACA,MAAM,IAAImB,KAAJ,CAAU,aAAV,CAAN;EAtCJ;AAwCD"},"metadata":{},"sourceType":"module"}