{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport { useUtils } from '../useUtils';\nimport { changeSectionValueFormat, cleanDigitSectionValue, doesSectionFormatHaveLeadingZeros, getDateSectionConfigFromFormatToken, getDaysInWeekStr, getLetterEditingOptions, applyLocalizedDigits, removeLocalizedDigits, isStringNumber } from './useField.utils';\n/**\n * The letter editing and the numeric editing each define a `CharacterEditingApplier`.\n * This function decides what the new section value should be and if the focus should switch to the next section.\n *\n * If it returns `null`, then the section value is not updated and the focus does not move.\n */\n\n/**\n * Function called by `applyQuery` which decides:\n * - what is the new section value ?\n * - should the query used to get this value be stored for the next key press ?\n *\n * If it returns `{ sectionValue: string; shouldGoToNextSection: boolean }`,\n * Then we store the query and update the section with the new value.\n *\n * If it returns `{ saveQuery: true` },\n * Then we store the query and don't update the section.\n *\n * If it returns `{ saveQuery: false },\n * Then we do nothing.\n */\n\nconst QUERY_LIFE_DURATION_MS = 5000;\n\nconst isQueryResponseWithoutValue = response => response.saveQuery != null;\n/**\n * Update the active section value when the user pressed a key that is not a navigation key (arrow key for example).\n * This hook has two main editing behaviors\n *\n * 1. The numeric editing when the user presses a digit\n * 2. The letter editing when the user presses another key\n */\n\n\nexport const useFieldCharacterEditing = _ref => {\n  let {\n    sections,\n    updateSectionValue,\n    sectionsValueBoundaries,\n    localizedDigits,\n    setTempAndroidValueStr,\n    timezone\n  } = _ref;\n  const utils = useUtils();\n  const [query, setQuery] = React.useState(null);\n  const resetQuery = useEventCallback(() => setQuery(null));\n  React.useEffect(() => {\n    if (query != null && sections[query.sectionIndex]?.type !== query.sectionType) {\n      resetQuery();\n    }\n  }, [sections, query, resetQuery]);\n  React.useEffect(() => {\n    if (query != null) {\n      const timeout = setTimeout(() => resetQuery(), QUERY_LIFE_DURATION_MS);\n      return () => {\n        clearTimeout(timeout);\n      };\n    }\n\n    return () => {};\n  }, [query, resetQuery]);\n\n  const applyQuery = (_ref2, getFirstSectionValueMatchingWithQuery, isValidQueryValue) => {\n    let {\n      keyPressed,\n      sectionIndex\n    } = _ref2;\n    const cleanKeyPressed = keyPressed.toLowerCase();\n    const activeSection = sections[sectionIndex]; // The current query targets the section being editing\n    // We can try to concatenate the value\n\n    if (query != null && (!isValidQueryValue || isValidQueryValue(query.value)) && query.sectionIndex === sectionIndex) {\n      const concatenatedQueryValue = `${query.value}${cleanKeyPressed}`;\n      const queryResponse = getFirstSectionValueMatchingWithQuery(concatenatedQueryValue, activeSection);\n\n      if (!isQueryResponseWithoutValue(queryResponse)) {\n        setQuery({\n          sectionIndex,\n          value: concatenatedQueryValue,\n          sectionType: activeSection.type\n        });\n        return queryResponse;\n      }\n    }\n\n    const queryResponse = getFirstSectionValueMatchingWithQuery(cleanKeyPressed, activeSection);\n\n    if (isQueryResponseWithoutValue(queryResponse) && !queryResponse.saveQuery) {\n      resetQuery();\n      return null;\n    }\n\n    setQuery({\n      sectionIndex,\n      value: cleanKeyPressed,\n      sectionType: activeSection.type\n    });\n\n    if (isQueryResponseWithoutValue(queryResponse)) {\n      return null;\n    }\n\n    return queryResponse;\n  };\n\n  const applyLetterEditing = params => {\n    const findMatchingOptions = (format, options, queryValue) => {\n      const matchingValues = options.filter(option => option.toLowerCase().startsWith(queryValue));\n\n      if (matchingValues.length === 0) {\n        return {\n          saveQuery: false\n        };\n      }\n\n      return {\n        sectionValue: matchingValues[0],\n        shouldGoToNextSection: matchingValues.length === 1\n      };\n    };\n\n    const testQueryOnFormatAndFallbackFormat = (queryValue, activeSection, fallbackFormat, formatFallbackValue) => {\n      const getOptions = format => getLetterEditingOptions(utils, timezone, activeSection.type, format);\n\n      if (activeSection.contentType === 'letter') {\n        return findMatchingOptions(activeSection.format, getOptions(activeSection.format), queryValue);\n      } // When editing a digit-format month / weekDay and the user presses a letter,\n      // We can support the letter editing by using the letter-format month / weekDay and re-formatting the result.\n      // We just have to make sure that the default month / weekDay format is a letter format,\n\n\n      if (fallbackFormat && formatFallbackValue != null && getDateSectionConfigFromFormatToken(utils, fallbackFormat).contentType === 'letter') {\n        const fallbackOptions = getOptions(fallbackFormat);\n        const response = findMatchingOptions(fallbackFormat, fallbackOptions, queryValue);\n\n        if (isQueryResponseWithoutValue(response)) {\n          return {\n            saveQuery: false\n          };\n        }\n\n        return _extends({}, response, {\n          sectionValue: formatFallbackValue(response.sectionValue, fallbackOptions)\n        });\n      }\n\n      return {\n        saveQuery: false\n      };\n    };\n\n    const getFirstSectionValueMatchingWithQuery = (queryValue, activeSection) => {\n      switch (activeSection.type) {\n        case 'month':\n          {\n            const formatFallbackValue = fallbackValue => changeSectionValueFormat(utils, fallbackValue, utils.formats.month, activeSection.format);\n\n            return testQueryOnFormatAndFallbackFormat(queryValue, activeSection, utils.formats.month, formatFallbackValue);\n          }\n\n        case 'weekDay':\n          {\n            const formatFallbackValue = (fallbackValue, fallbackOptions) => fallbackOptions.indexOf(fallbackValue).toString();\n\n            return testQueryOnFormatAndFallbackFormat(queryValue, activeSection, utils.formats.weekday, formatFallbackValue);\n          }\n\n        case 'meridiem':\n          {\n            return testQueryOnFormatAndFallbackFormat(queryValue, activeSection);\n          }\n\n        default:\n          {\n            return {\n              saveQuery: false\n            };\n          }\n      }\n    };\n\n    return applyQuery(params, getFirstSectionValueMatchingWithQuery);\n  };\n\n  const applyNumericEditing = params => {\n    const getNewSectionValue = (queryValue, section) => {\n      const cleanQueryValue = removeLocalizedDigits(queryValue, localizedDigits);\n      const queryValueNumber = Number(cleanQueryValue);\n      const sectionBoundaries = sectionsValueBoundaries[section.type]({\n        currentDate: null,\n        format: section.format,\n        contentType: section.contentType\n      });\n\n      if (queryValueNumber > sectionBoundaries.maximum) {\n        return {\n          saveQuery: false\n        };\n      } // If the user types `0` on a month section,\n      // It is below the minimum, but we want to store the `0` in the query,\n      // So that when he pressed `1`, it will store `01` and move to the next section.\n\n\n      if (queryValueNumber < sectionBoundaries.minimum) {\n        return {\n          saveQuery: true\n        };\n      }\n\n      const shouldGoToNextSection = queryValueNumber * 10 > sectionBoundaries.maximum || cleanQueryValue.length === sectionBoundaries.maximum.toString().length;\n      const newSectionValue = cleanDigitSectionValue(utils, queryValueNumber, sectionBoundaries, localizedDigits, section);\n      return {\n        sectionValue: newSectionValue,\n        shouldGoToNextSection\n      };\n    };\n\n    const getFirstSectionValueMatchingWithQuery = (queryValue, activeSection) => {\n      if (activeSection.contentType === 'digit' || activeSection.contentType === 'digit-with-letter') {\n        return getNewSectionValue(queryValue, activeSection);\n      } // When editing a letter-format month and the user presses a digit,\n      // We can support the numeric editing by using the digit-format month and re-formatting the result.\n\n\n      if (activeSection.type === 'month') {\n        const hasLeadingZerosInFormat = doesSectionFormatHaveLeadingZeros(utils, timezone, 'digit', 'month', 'MM');\n        const response = getNewSectionValue(queryValue, {\n          type: activeSection.type,\n          format: 'MM',\n          hasLeadingZerosInFormat,\n          hasLeadingZerosInInput: true,\n          contentType: 'digit',\n          maxLength: 2\n        });\n\n        if (isQueryResponseWithoutValue(response)) {\n          return response;\n        }\n\n        const formattedValue = changeSectionValueFormat(utils, response.sectionValue, 'MM', activeSection.format);\n        return _extends({}, response, {\n          sectionValue: formattedValue\n        });\n      } // When editing a letter-format weekDay and the user presses a digit,\n      // We can support the numeric editing by returning the nth day in the week day array.\n\n\n      if (activeSection.type === 'weekDay') {\n        const response = getNewSectionValue(queryValue, activeSection);\n\n        if (isQueryResponseWithoutValue(response)) {\n          return response;\n        }\n\n        const formattedValue = getDaysInWeekStr(utils, timezone, activeSection.format)[Number(response.sectionValue) - 1];\n        return _extends({}, response, {\n          sectionValue: formattedValue\n        });\n      }\n\n      return {\n        saveQuery: false\n      };\n    };\n\n    return applyQuery(params, getFirstSectionValueMatchingWithQuery, queryValue => isStringNumber(queryValue, localizedDigits));\n  };\n\n  const applyCharacterEditing = useEventCallback(params => {\n    const activeSection = sections[params.sectionIndex];\n    const isNumericEditing = isStringNumber(params.keyPressed, localizedDigits);\n    const response = isNumericEditing ? applyNumericEditing(_extends({}, params, {\n      keyPressed: applyLocalizedDigits(params.keyPressed, localizedDigits)\n    })) : applyLetterEditing(params);\n\n    if (response == null) {\n      setTempAndroidValueStr(null);\n      return;\n    }\n\n    updateSectionValue({\n      activeSection,\n      newSectionValue: response.sectionValue,\n      shouldGoToNextSection: response.shouldGoToNextSection\n    });\n  });\n  return {\n    applyCharacterEditing,\n    resetCharacterQuery: resetQuery\n  };\n};","map":{"version":3,"names":["_extends","React","useEventCallback","useUtils","changeSectionValueFormat","cleanDigitSectionValue","doesSectionFormatHaveLeadingZeros","getDateSectionConfigFromFormatToken","getDaysInWeekStr","getLetterEditingOptions","applyLocalizedDigits","removeLocalizedDigits","isStringNumber","QUERY_LIFE_DURATION_MS","isQueryResponseWithoutValue","response","saveQuery","useFieldCharacterEditing","sections","updateSectionValue","sectionsValueBoundaries","localizedDigits","setTempAndroidValueStr","timezone","utils","query","setQuery","useState","resetQuery","useEffect","sectionIndex","type","sectionType","timeout","setTimeout","clearTimeout","applyQuery","getFirstSectionValueMatchingWithQuery","isValidQueryValue","keyPressed","cleanKeyPressed","toLowerCase","activeSection","value","concatenatedQueryValue","queryResponse","applyLetterEditing","params","findMatchingOptions","format","options","queryValue","matchingValues","filter","option","startsWith","length","sectionValue","shouldGoToNextSection","testQueryOnFormatAndFallbackFormat","fallbackFormat","formatFallbackValue","getOptions","contentType","fallbackOptions","fallbackValue","formats","month","indexOf","toString","weekday","applyNumericEditing","getNewSectionValue","section","cleanQueryValue","queryValueNumber","Number","sectionBoundaries","currentDate","maximum","minimum","newSectionValue","hasLeadingZerosInFormat","hasLeadingZerosInInput","maxLength","formattedValue","applyCharacterEditing","isNumericEditing","resetCharacterQuery"],"sources":["C:/Users/kb/Downloads/billBoard/billboard/node_modules/@mui/x-date-pickers/internals/hooks/useField/useFieldCharacterEditing.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport { useUtils } from '../useUtils';\nimport { changeSectionValueFormat, cleanDigitSectionValue, doesSectionFormatHaveLeadingZeros, getDateSectionConfigFromFormatToken, getDaysInWeekStr, getLetterEditingOptions, applyLocalizedDigits, removeLocalizedDigits, isStringNumber } from './useField.utils';\n\n/**\n * The letter editing and the numeric editing each define a `CharacterEditingApplier`.\n * This function decides what the new section value should be and if the focus should switch to the next section.\n *\n * If it returns `null`, then the section value is not updated and the focus does not move.\n */\n\n/**\n * Function called by `applyQuery` which decides:\n * - what is the new section value ?\n * - should the query used to get this value be stored for the next key press ?\n *\n * If it returns `{ sectionValue: string; shouldGoToNextSection: boolean }`,\n * Then we store the query and update the section with the new value.\n *\n * If it returns `{ saveQuery: true` },\n * Then we store the query and don't update the section.\n *\n * If it returns `{ saveQuery: false },\n * Then we do nothing.\n */\n\nconst QUERY_LIFE_DURATION_MS = 5000;\nconst isQueryResponseWithoutValue = response => response.saveQuery != null;\n\n/**\n * Update the active section value when the user pressed a key that is not a navigation key (arrow key for example).\n * This hook has two main editing behaviors\n *\n * 1. The numeric editing when the user presses a digit\n * 2. The letter editing when the user presses another key\n */\nexport const useFieldCharacterEditing = ({\n  sections,\n  updateSectionValue,\n  sectionsValueBoundaries,\n  localizedDigits,\n  setTempAndroidValueStr,\n  timezone\n}) => {\n  const utils = useUtils();\n  const [query, setQuery] = React.useState(null);\n  const resetQuery = useEventCallback(() => setQuery(null));\n  React.useEffect(() => {\n    if (query != null && sections[query.sectionIndex]?.type !== query.sectionType) {\n      resetQuery();\n    }\n  }, [sections, query, resetQuery]);\n  React.useEffect(() => {\n    if (query != null) {\n      const timeout = setTimeout(() => resetQuery(), QUERY_LIFE_DURATION_MS);\n      return () => {\n        clearTimeout(timeout);\n      };\n    }\n    return () => {};\n  }, [query, resetQuery]);\n  const applyQuery = ({\n    keyPressed,\n    sectionIndex\n  }, getFirstSectionValueMatchingWithQuery, isValidQueryValue) => {\n    const cleanKeyPressed = keyPressed.toLowerCase();\n    const activeSection = sections[sectionIndex];\n\n    // The current query targets the section being editing\n    // We can try to concatenate the value\n    if (query != null && (!isValidQueryValue || isValidQueryValue(query.value)) && query.sectionIndex === sectionIndex) {\n      const concatenatedQueryValue = `${query.value}${cleanKeyPressed}`;\n      const queryResponse = getFirstSectionValueMatchingWithQuery(concatenatedQueryValue, activeSection);\n      if (!isQueryResponseWithoutValue(queryResponse)) {\n        setQuery({\n          sectionIndex,\n          value: concatenatedQueryValue,\n          sectionType: activeSection.type\n        });\n        return queryResponse;\n      }\n    }\n    const queryResponse = getFirstSectionValueMatchingWithQuery(cleanKeyPressed, activeSection);\n    if (isQueryResponseWithoutValue(queryResponse) && !queryResponse.saveQuery) {\n      resetQuery();\n      return null;\n    }\n    setQuery({\n      sectionIndex,\n      value: cleanKeyPressed,\n      sectionType: activeSection.type\n    });\n    if (isQueryResponseWithoutValue(queryResponse)) {\n      return null;\n    }\n    return queryResponse;\n  };\n  const applyLetterEditing = params => {\n    const findMatchingOptions = (format, options, queryValue) => {\n      const matchingValues = options.filter(option => option.toLowerCase().startsWith(queryValue));\n      if (matchingValues.length === 0) {\n        return {\n          saveQuery: false\n        };\n      }\n      return {\n        sectionValue: matchingValues[0],\n        shouldGoToNextSection: matchingValues.length === 1\n      };\n    };\n    const testQueryOnFormatAndFallbackFormat = (queryValue, activeSection, fallbackFormat, formatFallbackValue) => {\n      const getOptions = format => getLetterEditingOptions(utils, timezone, activeSection.type, format);\n      if (activeSection.contentType === 'letter') {\n        return findMatchingOptions(activeSection.format, getOptions(activeSection.format), queryValue);\n      }\n\n      // When editing a digit-format month / weekDay and the user presses a letter,\n      // We can support the letter editing by using the letter-format month / weekDay and re-formatting the result.\n      // We just have to make sure that the default month / weekDay format is a letter format,\n      if (fallbackFormat && formatFallbackValue != null && getDateSectionConfigFromFormatToken(utils, fallbackFormat).contentType === 'letter') {\n        const fallbackOptions = getOptions(fallbackFormat);\n        const response = findMatchingOptions(fallbackFormat, fallbackOptions, queryValue);\n        if (isQueryResponseWithoutValue(response)) {\n          return {\n            saveQuery: false\n          };\n        }\n        return _extends({}, response, {\n          sectionValue: formatFallbackValue(response.sectionValue, fallbackOptions)\n        });\n      }\n      return {\n        saveQuery: false\n      };\n    };\n    const getFirstSectionValueMatchingWithQuery = (queryValue, activeSection) => {\n      switch (activeSection.type) {\n        case 'month':\n          {\n            const formatFallbackValue = fallbackValue => changeSectionValueFormat(utils, fallbackValue, utils.formats.month, activeSection.format);\n            return testQueryOnFormatAndFallbackFormat(queryValue, activeSection, utils.formats.month, formatFallbackValue);\n          }\n        case 'weekDay':\n          {\n            const formatFallbackValue = (fallbackValue, fallbackOptions) => fallbackOptions.indexOf(fallbackValue).toString();\n            return testQueryOnFormatAndFallbackFormat(queryValue, activeSection, utils.formats.weekday, formatFallbackValue);\n          }\n        case 'meridiem':\n          {\n            return testQueryOnFormatAndFallbackFormat(queryValue, activeSection);\n          }\n        default:\n          {\n            return {\n              saveQuery: false\n            };\n          }\n      }\n    };\n    return applyQuery(params, getFirstSectionValueMatchingWithQuery);\n  };\n  const applyNumericEditing = params => {\n    const getNewSectionValue = (queryValue, section) => {\n      const cleanQueryValue = removeLocalizedDigits(queryValue, localizedDigits);\n      const queryValueNumber = Number(cleanQueryValue);\n      const sectionBoundaries = sectionsValueBoundaries[section.type]({\n        currentDate: null,\n        format: section.format,\n        contentType: section.contentType\n      });\n      if (queryValueNumber > sectionBoundaries.maximum) {\n        return {\n          saveQuery: false\n        };\n      }\n\n      // If the user types `0` on a month section,\n      // It is below the minimum, but we want to store the `0` in the query,\n      // So that when he pressed `1`, it will store `01` and move to the next section.\n      if (queryValueNumber < sectionBoundaries.minimum) {\n        return {\n          saveQuery: true\n        };\n      }\n      const shouldGoToNextSection = queryValueNumber * 10 > sectionBoundaries.maximum || cleanQueryValue.length === sectionBoundaries.maximum.toString().length;\n      const newSectionValue = cleanDigitSectionValue(utils, queryValueNumber, sectionBoundaries, localizedDigits, section);\n      return {\n        sectionValue: newSectionValue,\n        shouldGoToNextSection\n      };\n    };\n    const getFirstSectionValueMatchingWithQuery = (queryValue, activeSection) => {\n      if (activeSection.contentType === 'digit' || activeSection.contentType === 'digit-with-letter') {\n        return getNewSectionValue(queryValue, activeSection);\n      }\n\n      // When editing a letter-format month and the user presses a digit,\n      // We can support the numeric editing by using the digit-format month and re-formatting the result.\n      if (activeSection.type === 'month') {\n        const hasLeadingZerosInFormat = doesSectionFormatHaveLeadingZeros(utils, timezone, 'digit', 'month', 'MM');\n        const response = getNewSectionValue(queryValue, {\n          type: activeSection.type,\n          format: 'MM',\n          hasLeadingZerosInFormat,\n          hasLeadingZerosInInput: true,\n          contentType: 'digit',\n          maxLength: 2\n        });\n        if (isQueryResponseWithoutValue(response)) {\n          return response;\n        }\n        const formattedValue = changeSectionValueFormat(utils, response.sectionValue, 'MM', activeSection.format);\n        return _extends({}, response, {\n          sectionValue: formattedValue\n        });\n      }\n\n      // When editing a letter-format weekDay and the user presses a digit,\n      // We can support the numeric editing by returning the nth day in the week day array.\n      if (activeSection.type === 'weekDay') {\n        const response = getNewSectionValue(queryValue, activeSection);\n        if (isQueryResponseWithoutValue(response)) {\n          return response;\n        }\n        const formattedValue = getDaysInWeekStr(utils, timezone, activeSection.format)[Number(response.sectionValue) - 1];\n        return _extends({}, response, {\n          sectionValue: formattedValue\n        });\n      }\n      return {\n        saveQuery: false\n      };\n    };\n    return applyQuery(params, getFirstSectionValueMatchingWithQuery, queryValue => isStringNumber(queryValue, localizedDigits));\n  };\n  const applyCharacterEditing = useEventCallback(params => {\n    const activeSection = sections[params.sectionIndex];\n    const isNumericEditing = isStringNumber(params.keyPressed, localizedDigits);\n    const response = isNumericEditing ? applyNumericEditing(_extends({}, params, {\n      keyPressed: applyLocalizedDigits(params.keyPressed, localizedDigits)\n    })) : applyLetterEditing(params);\n    if (response == null) {\n      setTempAndroidValueStr(null);\n      return;\n    }\n    updateSectionValue({\n      activeSection,\n      newSectionValue: response.sectionValue,\n      shouldGoToNextSection: response.shouldGoToNextSection\n    });\n  });\n  return {\n    applyCharacterEditing,\n    resetCharacterQuery: resetQuery\n  };\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}