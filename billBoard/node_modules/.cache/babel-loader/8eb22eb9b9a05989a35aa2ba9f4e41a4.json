{"ast":null,"code":"import { mergeDateAndTime } from '@mui/x-date-pickers/internals';\nexport function calculateRangeChange(_ref) {\n  let {\n    utils,\n    range,\n    newDate: selectedDate,\n    rangePosition,\n    allowRangeFlip = false,\n    shouldMergeDateAndTime = false\n  } = _ref;\n  const [start, end] = range;\n\n  if (shouldMergeDateAndTime && selectedDate) {\n    // If there is a date already selected, then we want to keep its time\n    if (start && rangePosition === 'start') {\n      selectedDate = mergeDateAndTime(utils, selectedDate, start);\n    }\n\n    if (end && rangePosition === 'end') {\n      selectedDate = mergeDateAndTime(utils, selectedDate, end);\n    }\n  }\n\n  if (rangePosition === 'start') {\n    const truthyResult = allowRangeFlip ? {\n      nextSelection: 'start',\n      newRange: [end, selectedDate]\n    } : {\n      nextSelection: 'end',\n      newRange: [selectedDate, null]\n    };\n    return Boolean(end) && utils.isAfter(selectedDate, end) ? truthyResult : {\n      nextSelection: 'end',\n      newRange: [selectedDate, end]\n    };\n  }\n\n  const truthyResult = allowRangeFlip ? {\n    nextSelection: 'end',\n    newRange: [selectedDate, start]\n  } : {\n    nextSelection: 'end',\n    newRange: [selectedDate, null]\n  };\n  return Boolean(start) && utils.isBeforeDay(selectedDate, start) ? truthyResult : {\n    nextSelection: 'start',\n    newRange: [start, selectedDate]\n  };\n}\nexport function calculateRangePreview(options) {\n  if (options.newDate == null) {\n    return [null, null];\n  }\n\n  const [start, end] = options.range;\n  const {\n    newRange\n  } = calculateRangeChange(options);\n\n  if (!start || !end) {\n    return newRange;\n  }\n\n  const [previewStart, previewEnd] = newRange;\n  return options.rangePosition === 'end' ? [end, previewEnd] : [previewStart, start];\n}","map":{"version":3,"names":["mergeDateAndTime","calculateRangeChange","utils","range","newDate","selectedDate","rangePosition","allowRangeFlip","shouldMergeDateAndTime","start","end","truthyResult","nextSelection","newRange","Boolean","isAfter","isBeforeDay","calculateRangePreview","options","previewStart","previewEnd"],"sources":["C:/Users/kb/Downloads/billBoard/billboard/node_modules/@mui/x-date-pickers-pro/internals/utils/date-range-manager.js"],"sourcesContent":["import { mergeDateAndTime } from '@mui/x-date-pickers/internals';\nexport function calculateRangeChange({\n  utils,\n  range,\n  newDate: selectedDate,\n  rangePosition,\n  allowRangeFlip = false,\n  shouldMergeDateAndTime = false\n}) {\n  const [start, end] = range;\n  if (shouldMergeDateAndTime && selectedDate) {\n    // If there is a date already selected, then we want to keep its time\n    if (start && rangePosition === 'start') {\n      selectedDate = mergeDateAndTime(utils, selectedDate, start);\n    }\n    if (end && rangePosition === 'end') {\n      selectedDate = mergeDateAndTime(utils, selectedDate, end);\n    }\n  }\n  if (rangePosition === 'start') {\n    const truthyResult = allowRangeFlip ? {\n      nextSelection: 'start',\n      newRange: [end, selectedDate]\n    } : {\n      nextSelection: 'end',\n      newRange: [selectedDate, null]\n    };\n    return Boolean(end) && utils.isAfter(selectedDate, end) ? truthyResult : {\n      nextSelection: 'end',\n      newRange: [selectedDate, end]\n    };\n  }\n  const truthyResult = allowRangeFlip ? {\n    nextSelection: 'end',\n    newRange: [selectedDate, start]\n  } : {\n    nextSelection: 'end',\n    newRange: [selectedDate, null]\n  };\n  return Boolean(start) && utils.isBeforeDay(selectedDate, start) ? truthyResult : {\n    nextSelection: 'start',\n    newRange: [start, selectedDate]\n  };\n}\nexport function calculateRangePreview(options) {\n  if (options.newDate == null) {\n    return [null, null];\n  }\n  const [start, end] = options.range;\n  const {\n    newRange\n  } = calculateRangeChange(options);\n  if (!start || !end) {\n    return newRange;\n  }\n  const [previewStart, previewEnd] = newRange;\n  return options.rangePosition === 'end' ? [end, previewEnd] : [previewStart, start];\n}"],"mappings":"AAAA,SAASA,gBAAT,QAAiC,+BAAjC;AACA,OAAO,SAASC,oBAAT,OAOJ;EAAA,IAPkC;IACnCC,KADmC;IAEnCC,KAFmC;IAGnCC,OAAO,EAAEC,YAH0B;IAInCC,aAJmC;IAKnCC,cAAc,GAAG,KALkB;IAMnCC,sBAAsB,GAAG;EANU,CAOlC;EACD,MAAM,CAACC,KAAD,EAAQC,GAAR,IAAeP,KAArB;;EACA,IAAIK,sBAAsB,IAAIH,YAA9B,EAA4C;IAC1C;IACA,IAAII,KAAK,IAAIH,aAAa,KAAK,OAA/B,EAAwC;MACtCD,YAAY,GAAGL,gBAAgB,CAACE,KAAD,EAAQG,YAAR,EAAsBI,KAAtB,CAA/B;IACD;;IACD,IAAIC,GAAG,IAAIJ,aAAa,KAAK,KAA7B,EAAoC;MAClCD,YAAY,GAAGL,gBAAgB,CAACE,KAAD,EAAQG,YAAR,EAAsBK,GAAtB,CAA/B;IACD;EACF;;EACD,IAAIJ,aAAa,KAAK,OAAtB,EAA+B;IAC7B,MAAMK,YAAY,GAAGJ,cAAc,GAAG;MACpCK,aAAa,EAAE,OADqB;MAEpCC,QAAQ,EAAE,CAACH,GAAD,EAAML,YAAN;IAF0B,CAAH,GAG/B;MACFO,aAAa,EAAE,KADb;MAEFC,QAAQ,EAAE,CAACR,YAAD,EAAe,IAAf;IAFR,CAHJ;IAOA,OAAOS,OAAO,CAACJ,GAAD,CAAP,IAAgBR,KAAK,CAACa,OAAN,CAAcV,YAAd,EAA4BK,GAA5B,CAAhB,GAAmDC,YAAnD,GAAkE;MACvEC,aAAa,EAAE,KADwD;MAEvEC,QAAQ,EAAE,CAACR,YAAD,EAAeK,GAAf;IAF6D,CAAzE;EAID;;EACD,MAAMC,YAAY,GAAGJ,cAAc,GAAG;IACpCK,aAAa,EAAE,KADqB;IAEpCC,QAAQ,EAAE,CAACR,YAAD,EAAeI,KAAf;EAF0B,CAAH,GAG/B;IACFG,aAAa,EAAE,KADb;IAEFC,QAAQ,EAAE,CAACR,YAAD,EAAe,IAAf;EAFR,CAHJ;EAOA,OAAOS,OAAO,CAACL,KAAD,CAAP,IAAkBP,KAAK,CAACc,WAAN,CAAkBX,YAAlB,EAAgCI,KAAhC,CAAlB,GAA2DE,YAA3D,GAA0E;IAC/EC,aAAa,EAAE,OADgE;IAE/EC,QAAQ,EAAE,CAACJ,KAAD,EAAQJ,YAAR;EAFqE,CAAjF;AAID;AACD,OAAO,SAASY,qBAAT,CAA+BC,OAA/B,EAAwC;EAC7C,IAAIA,OAAO,CAACd,OAAR,IAAmB,IAAvB,EAA6B;IAC3B,OAAO,CAAC,IAAD,EAAO,IAAP,CAAP;EACD;;EACD,MAAM,CAACK,KAAD,EAAQC,GAAR,IAAeQ,OAAO,CAACf,KAA7B;EACA,MAAM;IACJU;EADI,IAEFZ,oBAAoB,CAACiB,OAAD,CAFxB;;EAGA,IAAI,CAACT,KAAD,IAAU,CAACC,GAAf,EAAoB;IAClB,OAAOG,QAAP;EACD;;EACD,MAAM,CAACM,YAAD,EAAeC,UAAf,IAA6BP,QAAnC;EACA,OAAOK,OAAO,CAACZ,aAAR,KAA0B,KAA1B,GAAkC,CAACI,GAAD,EAAMU,UAAN,CAAlC,GAAsD,CAACD,YAAD,EAAeV,KAAf,CAA7D;AACD"},"metadata":{},"sourceType":"module"}