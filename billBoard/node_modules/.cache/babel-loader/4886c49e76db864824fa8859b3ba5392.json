{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useGridClipboardImport = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _xDataGrid = require(\"@mui/x-data-grid\");\n\nvar _internals = require(\"@mui/x-data-grid/internals\");\n\nvar _xDataGridPro = require(\"@mui/x-data-grid-pro\");\n\nvar _utils = require(\"@mui/utils\");\n\nfunction _getRequireWildcardCache(e) {\n  if (\"function\" != typeof WeakMap) return null;\n  var r = new WeakMap(),\n      t = new WeakMap();\n  return (_getRequireWildcardCache = function (e) {\n    return e ? t : r;\n  })(e);\n}\n\nfunction _interopRequireWildcard(e, r) {\n  if (!r && e && e.__esModule) return e;\n  if (null === e || \"object\" != typeof e && \"function\" != typeof e) return {\n    default: e\n  };\n\n  var t = _getRequireWildcardCache(r);\n\n  if (t && t.has(e)) return t.get(e);\n  var n = {\n    __proto__: null\n  },\n      a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) {\n    var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n    i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n  }\n\n  return n.default = e, t && t.set(e, n), n;\n}\n\nconst missingOnProcessRowUpdateErrorWarning = (0, _internals.buildWarning)(['MUI X: A call to `processRowUpdate` threw an error which was not handled because `onProcessRowUpdateError` is missing.', 'To handle the error pass a callback to the `onProcessRowUpdateError` prop, for example `<DataGrid onProcessRowUpdateError={(error) => ...} />`.', 'For more detail, see https://mui.com/x/react-data-grid/editing/#server-side-persistence.'], 'error');\nconst columnFieldsToExcludeFromPaste = [_xDataGrid.GRID_CHECKBOX_SELECTION_FIELD, _xDataGridPro.GRID_REORDER_COL_DEF.field, _xDataGridPro.GRID_DETAIL_PANEL_TOGGLE_FIELD]; // Batches rows that are updated during clipboard paste to reduce `updateRows` calls\n\nfunction batchRowUpdates(func, wait) {\n  let rows = [];\n  const debounced = (0, _utils.unstable_debounce)(() => {\n    func(rows);\n    rows = [];\n  }, wait);\n  return row => {\n    rows.push(row);\n    debounced();\n  };\n}\n\nasync function getTextFromClipboard(rootEl) {\n  return new Promise(resolve => {\n    const focusedCell = (0, _internals.getActiveElement)(document);\n    const el = document.createElement('input');\n    el.style.width = '0px';\n    el.style.height = '0px';\n    el.style.border = 'none';\n    el.style.margin = '0';\n    el.style.padding = '0';\n    el.style.outline = 'none';\n    el.style.position = 'absolute';\n    el.style.top = '0';\n    el.style.left = '0';\n\n    const handlePasteEvent = event => {\n      el.removeEventListener('paste', handlePasteEvent);\n      const text = event.clipboardData?.getData('text/plain');\n\n      if (focusedCell instanceof HTMLElement) {\n        focusedCell.focus({\n          preventScroll: true\n        });\n      }\n\n      el.remove();\n      resolve(text || '');\n    };\n\n    el.addEventListener('paste', handlePasteEvent);\n    rootEl.appendChild(el);\n    el.focus({\n      preventScroll: true\n    });\n  });\n} // Keeps track of updated rows during clipboard paste\n\n\nclass CellValueUpdater {\n  constructor(options) {\n    this.rowsToUpdate = {};\n    this.updateRow = void 0;\n    this.options = void 0;\n    this.options = options;\n    this.updateRow = batchRowUpdates(options.apiRef.current.updateRows, 50);\n  }\n\n  updateCell(_ref) {\n    let {\n      rowId,\n      field,\n      pastedCellValue\n    } = _ref;\n\n    if (pastedCellValue === undefined) {\n      return;\n    }\n\n    const {\n      apiRef,\n      getRowId\n    } = this.options;\n    const colDef = apiRef.current.getColumn(field);\n\n    if (!colDef || !colDef.editable) {\n      return;\n    }\n\n    const row = this.rowsToUpdate[rowId] || (0, _extends2.default)({}, apiRef.current.getRow(rowId));\n\n    if (!row) {\n      return;\n    }\n\n    let parsedValue = pastedCellValue;\n\n    if (colDef.pastedValueParser) {\n      parsedValue = colDef.pastedValueParser(pastedCellValue, row, colDef, apiRef);\n    } else if (colDef.valueParser) {\n      parsedValue = colDef.valueParser(parsedValue, row, colDef, apiRef);\n    }\n\n    if (parsedValue === undefined) {\n      return;\n    }\n\n    let rowCopy = (0, _extends2.default)({}, row);\n\n    if (typeof colDef.valueSetter === 'function') {\n      rowCopy = colDef.valueSetter(parsedValue, rowCopy, colDef, apiRef);\n    } else {\n      rowCopy[field] = parsedValue;\n    }\n\n    const newRowId = (0, _internals.getRowIdFromRowModel)(rowCopy, getRowId);\n\n    if (String(newRowId) !== String(rowId)) {\n      // We cannot update row id, so this cell value update should be ignored\n      return;\n    }\n\n    this.rowsToUpdate[rowId] = rowCopy;\n  }\n\n  applyUpdates() {\n    const {\n      apiRef,\n      processRowUpdate,\n      onProcessRowUpdateError\n    } = this.options;\n    const rowsToUpdate = this.rowsToUpdate;\n    const rowIdsToUpdate = Object.keys(rowsToUpdate);\n\n    if (rowIdsToUpdate.length === 0) {\n      apiRef.current.publishEvent('clipboardPasteEnd');\n      return;\n    }\n\n    const handleRowUpdate = async rowId => {\n      const newRow = rowsToUpdate[rowId];\n\n      if (typeof processRowUpdate === 'function') {\n        const handleError = errorThrown => {\n          if (onProcessRowUpdateError) {\n            onProcessRowUpdateError(errorThrown);\n          } else if (process.env.NODE_ENV !== 'production') {\n            missingOnProcessRowUpdateErrorWarning();\n          }\n        };\n\n        try {\n          const oldRow = apiRef.current.getRow(rowId);\n          const finalRowUpdate = await processRowUpdate(newRow, oldRow);\n          this.updateRow(finalRowUpdate);\n        } catch (error) {\n          handleError(error);\n        }\n      } else {\n        this.updateRow(newRow);\n      }\n    };\n\n    const promises = rowIdsToUpdate.map(rowId => {\n      // Wrap in promise that always resolves to avoid Promise.all from stopping on first error.\n      // This is to avoid using `Promise.allSettled` that has worse browser support.\n      return new Promise(resolve => {\n        handleRowUpdate(rowId).then(resolve).catch(resolve);\n      });\n    });\n    Promise.all(promises).then(() => {\n      this.rowsToUpdate = {};\n      apiRef.current.publishEvent('clipboardPasteEnd');\n    });\n  }\n\n}\n\nfunction defaultPasteResolver(_ref2) {\n  let {\n    pastedData,\n    apiRef,\n    updateCell,\n    pagination\n  } = _ref2;\n  const isSingleValuePasted = pastedData.length === 1 && pastedData[0].length === 1;\n  const cellSelectionModel = apiRef.current.getCellSelectionModel();\n  const selectedCellsArray = apiRef.current.getSelectedCellsAsArray();\n\n  if (cellSelectionModel && selectedCellsArray.length > 1) {\n    Object.keys(cellSelectionModel).forEach((rowId, rowIndex) => {\n      const rowDataArr = pastedData[isSingleValuePasted ? 0 : rowIndex];\n      const hasRowData = isSingleValuePasted ? true : rowDataArr !== undefined;\n\n      if (!hasRowData) {\n        return;\n      }\n\n      Object.keys(cellSelectionModel[rowId]).forEach((field, colIndex) => {\n        const cellValue = isSingleValuePasted ? rowDataArr[0] : rowDataArr[colIndex];\n        updateCell({\n          rowId,\n          field,\n          pastedCellValue: cellValue\n        });\n      });\n    });\n    return;\n  }\n\n  const visibleColumnFields = (0, _xDataGrid.gridVisibleColumnFieldsSelector)(apiRef).filter(field => {\n    if (columnFieldsToExcludeFromPaste.includes(field)) {\n      return false;\n    }\n\n    return true;\n  });\n  const selectedRows = apiRef.current.getSelectedRows();\n\n  if (selectedRows.size > 0 && !isSingleValuePasted) {\n    // Multiple values are pasted starting from the first and top-most cell\n    const pastedRowsDataCount = pastedData.length; // There's no guarantee that the selected rows are in the same order as the pasted rows\n\n    selectedRows.forEach((row, rowId) => {\n      let rowData;\n\n      if (pastedRowsDataCount === 1) {\n        // If only one row is pasted - paste it to all selected rows\n        rowData = pastedData[0];\n      } else {\n        rowData = pastedData.shift();\n      }\n\n      if (rowData === undefined) {\n        return;\n      }\n\n      rowData.forEach((newCellValue, cellIndex) => {\n        updateCell({\n          rowId,\n          field: visibleColumnFields[cellIndex],\n          pastedCellValue: newCellValue\n        });\n      });\n    });\n    return;\n  }\n\n  let selectedCell = (0, _xDataGrid.gridFocusCellSelector)(apiRef);\n\n  if (!selectedCell && selectedCellsArray.length === 1) {\n    selectedCell = selectedCellsArray[0];\n  }\n\n  if (!selectedCell) {\n    return;\n  }\n\n  if (columnFieldsToExcludeFromPaste.includes(selectedCell.field)) {\n    return;\n  }\n\n  const selectedRowId = selectedCell.id;\n  const selectedRowIndex = apiRef.current.getRowIndexRelativeToVisibleRows(selectedRowId);\n  const visibleRowIds = pagination ? (0, _xDataGrid.gridPaginatedVisibleSortedGridRowIdsSelector)(apiRef) : (0, _xDataGrid.gridExpandedSortedRowIdsSelector)(apiRef);\n  const selectedFieldIndex = visibleColumnFields.indexOf(selectedCell.field);\n  pastedData.forEach((rowData, index) => {\n    const rowId = visibleRowIds[selectedRowIndex + index];\n\n    if (typeof rowId === 'undefined') {\n      return;\n    }\n\n    for (let i = selectedFieldIndex; i < visibleColumnFields.length; i += 1) {\n      const field = visibleColumnFields[i];\n      const stringValue = rowData[i - selectedFieldIndex];\n      updateCell({\n        rowId,\n        field,\n        pastedCellValue: stringValue\n      });\n    }\n  });\n}\n\nconst useGridClipboardImport = (apiRef, props) => {\n  const processRowUpdate = props.processRowUpdate;\n  const onProcessRowUpdateError = props.onProcessRowUpdateError;\n  const getRowId = props.getRowId;\n  const enableClipboardPaste = !props.disableClipboardPaste;\n  const rootEl = apiRef.current.rootElementRef?.current;\n  const logger = (0, _internals.useGridLogger)(apiRef, 'useGridClipboardImport');\n  const splitClipboardPastedText = props.splitClipboardPastedText;\n  const {\n    pagination,\n    onBeforeClipboardPasteStart\n  } = props;\n  const handlePaste = React.useCallback(async (params, event) => {\n    if (!enableClipboardPaste) {\n      return;\n    }\n\n    if (!(0, _internals.isPasteShortcut)(event)) {\n      return;\n    }\n\n    const focusedCell = (0, _xDataGrid.gridFocusCellSelector)(apiRef);\n\n    if (focusedCell !== null) {\n      const cellMode = apiRef.current.getCellMode(focusedCell.id, focusedCell.field);\n\n      if (cellMode === 'edit') {\n        // Do not paste data when the cell is in edit mode\n        return;\n      }\n    }\n\n    if (!rootEl) {\n      return;\n    }\n\n    const text = await getTextFromClipboard(rootEl);\n\n    if (!text) {\n      return;\n    }\n\n    const pastedData = splitClipboardPastedText(text);\n\n    if (!pastedData) {\n      return;\n    }\n\n    if (onBeforeClipboardPasteStart) {\n      try {\n        await onBeforeClipboardPasteStart({\n          data: pastedData\n        });\n      } catch (error) {\n        logger.debug('Clipboard paste operation cancelled');\n        return;\n      }\n    }\n\n    const cellUpdater = new CellValueUpdater({\n      apiRef,\n      processRowUpdate,\n      onProcessRowUpdateError,\n      getRowId\n    });\n    apiRef.current.publishEvent('clipboardPasteStart', {\n      data: pastedData\n    });\n    defaultPasteResolver({\n      pastedData,\n      apiRef: (0, _internals.getPublicApiRef)(apiRef),\n      updateCell: function () {\n        cellUpdater.updateCell(...arguments);\n      },\n      pagination\n    });\n    cellUpdater.applyUpdates();\n  }, [apiRef, processRowUpdate, onProcessRowUpdateError, getRowId, enableClipboardPaste, rootEl, splitClipboardPastedText, pagination, onBeforeClipboardPasteStart, logger]);\n  const checkIfCanStartEditing = React.useCallback((initialValue, _ref3) => {\n    let {\n      event\n    } = _ref3;\n\n    if ((0, _internals.isPasteShortcut)(event) && enableClipboardPaste) {\n      // Do not enter cell edit mode on paste\n      return false;\n    }\n\n    return initialValue;\n  }, [enableClipboardPaste]);\n  (0, _xDataGrid.useGridApiEventHandler)(apiRef, 'cellKeyDown', handlePaste);\n  (0, _xDataGrid.useGridApiOptionHandler)(apiRef, 'clipboardPasteStart', props.onClipboardPasteStart);\n  (0, _xDataGrid.useGridApiOptionHandler)(apiRef, 'clipboardPasteEnd', props.onClipboardPasteEnd);\n  (0, _internals.useGridRegisterPipeProcessor)(apiRef, 'canStartEditing', checkIfCanStartEditing);\n};\n\nexports.useGridClipboardImport = useGridClipboardImport;","map":{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","useGridClipboardImport","_extends2","React","_interopRequireWildcard","_xDataGrid","_internals","_xDataGridPro","_utils","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","missingOnProcessRowUpdateErrorWarning","buildWarning","columnFieldsToExcludeFromPaste","GRID_CHECKBOX_SELECTION_FIELD","GRID_REORDER_COL_DEF","field","GRID_DETAIL_PANEL_TOGGLE_FIELD","batchRowUpdates","func","wait","rows","debounced","unstable_debounce","row","push","getTextFromClipboard","rootEl","Promise","resolve","focusedCell","getActiveElement","document","el","createElement","style","width","height","border","margin","padding","outline","position","top","left","handlePasteEvent","event","removeEventListener","text","clipboardData","getData","HTMLElement","focus","preventScroll","remove","addEventListener","appendChild","CellValueUpdater","constructor","options","rowsToUpdate","updateRow","apiRef","current","updateRows","updateCell","rowId","pastedCellValue","undefined","getRowId","colDef","getColumn","editable","getRow","parsedValue","pastedValueParser","valueParser","rowCopy","valueSetter","newRowId","getRowIdFromRowModel","String","applyUpdates","processRowUpdate","onProcessRowUpdateError","rowIdsToUpdate","keys","length","publishEvent","handleRowUpdate","newRow","handleError","errorThrown","process","env","NODE_ENV","oldRow","finalRowUpdate","error","promises","map","then","catch","all","defaultPasteResolver","pastedData","pagination","isSingleValuePasted","cellSelectionModel","getCellSelectionModel","selectedCellsArray","getSelectedCellsAsArray","forEach","rowIndex","rowDataArr","hasRowData","colIndex","cellValue","visibleColumnFields","gridVisibleColumnFieldsSelector","filter","includes","selectedRows","getSelectedRows","size","pastedRowsDataCount","rowData","shift","newCellValue","cellIndex","selectedCell","gridFocusCellSelector","selectedRowId","id","selectedRowIndex","getRowIndexRelativeToVisibleRows","visibleRowIds","gridPaginatedVisibleSortedGridRowIdsSelector","gridExpandedSortedRowIdsSelector","selectedFieldIndex","indexOf","index","stringValue","props","enableClipboardPaste","disableClipboardPaste","rootElementRef","logger","useGridLogger","splitClipboardPastedText","onBeforeClipboardPasteStart","handlePaste","useCallback","params","isPasteShortcut","cellMode","getCellMode","data","debug","cellUpdater","getPublicApiRef","checkIfCanStartEditing","initialValue","useGridApiEventHandler","useGridApiOptionHandler","onClipboardPasteStart","onClipboardPasteEnd","useGridRegisterPipeProcessor"],"sources":["C:/Users/kb/node_modules/@mui/x-data-grid-premium/hooks/features/clipboard/useGridClipboardImport.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useGridClipboardImport = void 0;\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _xDataGrid = require(\"@mui/x-data-grid\");\nvar _internals = require(\"@mui/x-data-grid/internals\");\nvar _xDataGridPro = require(\"@mui/x-data-grid-pro\");\nvar _utils = require(\"@mui/utils\");\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\nconst missingOnProcessRowUpdateErrorWarning = (0, _internals.buildWarning)(['MUI X: A call to `processRowUpdate` threw an error which was not handled because `onProcessRowUpdateError` is missing.', 'To handle the error pass a callback to the `onProcessRowUpdateError` prop, for example `<DataGrid onProcessRowUpdateError={(error) => ...} />`.', 'For more detail, see https://mui.com/x/react-data-grid/editing/#server-side-persistence.'], 'error');\nconst columnFieldsToExcludeFromPaste = [_xDataGrid.GRID_CHECKBOX_SELECTION_FIELD, _xDataGridPro.GRID_REORDER_COL_DEF.field, _xDataGridPro.GRID_DETAIL_PANEL_TOGGLE_FIELD];\n\n// Batches rows that are updated during clipboard paste to reduce `updateRows` calls\nfunction batchRowUpdates(func, wait) {\n  let rows = [];\n  const debounced = (0, _utils.unstable_debounce)(() => {\n    func(rows);\n    rows = [];\n  }, wait);\n  return row => {\n    rows.push(row);\n    debounced();\n  };\n}\nasync function getTextFromClipboard(rootEl) {\n  return new Promise(resolve => {\n    const focusedCell = (0, _internals.getActiveElement)(document);\n    const el = document.createElement('input');\n    el.style.width = '0px';\n    el.style.height = '0px';\n    el.style.border = 'none';\n    el.style.margin = '0';\n    el.style.padding = '0';\n    el.style.outline = 'none';\n    el.style.position = 'absolute';\n    el.style.top = '0';\n    el.style.left = '0';\n    const handlePasteEvent = event => {\n      el.removeEventListener('paste', handlePasteEvent);\n      const text = event.clipboardData?.getData('text/plain');\n      if (focusedCell instanceof HTMLElement) {\n        focusedCell.focus({\n          preventScroll: true\n        });\n      }\n      el.remove();\n      resolve(text || '');\n    };\n    el.addEventListener('paste', handlePasteEvent);\n    rootEl.appendChild(el);\n    el.focus({\n      preventScroll: true\n    });\n  });\n}\n\n// Keeps track of updated rows during clipboard paste\nclass CellValueUpdater {\n  constructor(options) {\n    this.rowsToUpdate = {};\n    this.updateRow = void 0;\n    this.options = void 0;\n    this.options = options;\n    this.updateRow = batchRowUpdates(options.apiRef.current.updateRows, 50);\n  }\n  updateCell({\n    rowId,\n    field,\n    pastedCellValue\n  }) {\n    if (pastedCellValue === undefined) {\n      return;\n    }\n    const {\n      apiRef,\n      getRowId\n    } = this.options;\n    const colDef = apiRef.current.getColumn(field);\n    if (!colDef || !colDef.editable) {\n      return;\n    }\n    const row = this.rowsToUpdate[rowId] || (0, _extends2.default)({}, apiRef.current.getRow(rowId));\n    if (!row) {\n      return;\n    }\n    let parsedValue = pastedCellValue;\n    if (colDef.pastedValueParser) {\n      parsedValue = colDef.pastedValueParser(pastedCellValue, row, colDef, apiRef);\n    } else if (colDef.valueParser) {\n      parsedValue = colDef.valueParser(parsedValue, row, colDef, apiRef);\n    }\n    if (parsedValue === undefined) {\n      return;\n    }\n    let rowCopy = (0, _extends2.default)({}, row);\n    if (typeof colDef.valueSetter === 'function') {\n      rowCopy = colDef.valueSetter(parsedValue, rowCopy, colDef, apiRef);\n    } else {\n      rowCopy[field] = parsedValue;\n    }\n    const newRowId = (0, _internals.getRowIdFromRowModel)(rowCopy, getRowId);\n    if (String(newRowId) !== String(rowId)) {\n      // We cannot update row id, so this cell value update should be ignored\n      return;\n    }\n    this.rowsToUpdate[rowId] = rowCopy;\n  }\n  applyUpdates() {\n    const {\n      apiRef,\n      processRowUpdate,\n      onProcessRowUpdateError\n    } = this.options;\n    const rowsToUpdate = this.rowsToUpdate;\n    const rowIdsToUpdate = Object.keys(rowsToUpdate);\n    if (rowIdsToUpdate.length === 0) {\n      apiRef.current.publishEvent('clipboardPasteEnd');\n      return;\n    }\n    const handleRowUpdate = async rowId => {\n      const newRow = rowsToUpdate[rowId];\n      if (typeof processRowUpdate === 'function') {\n        const handleError = errorThrown => {\n          if (onProcessRowUpdateError) {\n            onProcessRowUpdateError(errorThrown);\n          } else if (process.env.NODE_ENV !== 'production') {\n            missingOnProcessRowUpdateErrorWarning();\n          }\n        };\n        try {\n          const oldRow = apiRef.current.getRow(rowId);\n          const finalRowUpdate = await processRowUpdate(newRow, oldRow);\n          this.updateRow(finalRowUpdate);\n        } catch (error) {\n          handleError(error);\n        }\n      } else {\n        this.updateRow(newRow);\n      }\n    };\n    const promises = rowIdsToUpdate.map(rowId => {\n      // Wrap in promise that always resolves to avoid Promise.all from stopping on first error.\n      // This is to avoid using `Promise.allSettled` that has worse browser support.\n      return new Promise(resolve => {\n        handleRowUpdate(rowId).then(resolve).catch(resolve);\n      });\n    });\n    Promise.all(promises).then(() => {\n      this.rowsToUpdate = {};\n      apiRef.current.publishEvent('clipboardPasteEnd');\n    });\n  }\n}\nfunction defaultPasteResolver({\n  pastedData,\n  apiRef,\n  updateCell,\n  pagination\n}) {\n  const isSingleValuePasted = pastedData.length === 1 && pastedData[0].length === 1;\n  const cellSelectionModel = apiRef.current.getCellSelectionModel();\n  const selectedCellsArray = apiRef.current.getSelectedCellsAsArray();\n  if (cellSelectionModel && selectedCellsArray.length > 1) {\n    Object.keys(cellSelectionModel).forEach((rowId, rowIndex) => {\n      const rowDataArr = pastedData[isSingleValuePasted ? 0 : rowIndex];\n      const hasRowData = isSingleValuePasted ? true : rowDataArr !== undefined;\n      if (!hasRowData) {\n        return;\n      }\n      Object.keys(cellSelectionModel[rowId]).forEach((field, colIndex) => {\n        const cellValue = isSingleValuePasted ? rowDataArr[0] : rowDataArr[colIndex];\n        updateCell({\n          rowId,\n          field,\n          pastedCellValue: cellValue\n        });\n      });\n    });\n    return;\n  }\n  const visibleColumnFields = (0, _xDataGrid.gridVisibleColumnFieldsSelector)(apiRef).filter(field => {\n    if (columnFieldsToExcludeFromPaste.includes(field)) {\n      return false;\n    }\n    return true;\n  });\n  const selectedRows = apiRef.current.getSelectedRows();\n  if (selectedRows.size > 0 && !isSingleValuePasted) {\n    // Multiple values are pasted starting from the first and top-most cell\n    const pastedRowsDataCount = pastedData.length;\n\n    // There's no guarantee that the selected rows are in the same order as the pasted rows\n    selectedRows.forEach((row, rowId) => {\n      let rowData;\n      if (pastedRowsDataCount === 1) {\n        // If only one row is pasted - paste it to all selected rows\n        rowData = pastedData[0];\n      } else {\n        rowData = pastedData.shift();\n      }\n      if (rowData === undefined) {\n        return;\n      }\n      rowData.forEach((newCellValue, cellIndex) => {\n        updateCell({\n          rowId,\n          field: visibleColumnFields[cellIndex],\n          pastedCellValue: newCellValue\n        });\n      });\n    });\n    return;\n  }\n  let selectedCell = (0, _xDataGrid.gridFocusCellSelector)(apiRef);\n  if (!selectedCell && selectedCellsArray.length === 1) {\n    selectedCell = selectedCellsArray[0];\n  }\n  if (!selectedCell) {\n    return;\n  }\n  if (columnFieldsToExcludeFromPaste.includes(selectedCell.field)) {\n    return;\n  }\n  const selectedRowId = selectedCell.id;\n  const selectedRowIndex = apiRef.current.getRowIndexRelativeToVisibleRows(selectedRowId);\n  const visibleRowIds = pagination ? (0, _xDataGrid.gridPaginatedVisibleSortedGridRowIdsSelector)(apiRef) : (0, _xDataGrid.gridExpandedSortedRowIdsSelector)(apiRef);\n  const selectedFieldIndex = visibleColumnFields.indexOf(selectedCell.field);\n  pastedData.forEach((rowData, index) => {\n    const rowId = visibleRowIds[selectedRowIndex + index];\n    if (typeof rowId === 'undefined') {\n      return;\n    }\n    for (let i = selectedFieldIndex; i < visibleColumnFields.length; i += 1) {\n      const field = visibleColumnFields[i];\n      const stringValue = rowData[i - selectedFieldIndex];\n      updateCell({\n        rowId,\n        field,\n        pastedCellValue: stringValue\n      });\n    }\n  });\n}\nconst useGridClipboardImport = (apiRef, props) => {\n  const processRowUpdate = props.processRowUpdate;\n  const onProcessRowUpdateError = props.onProcessRowUpdateError;\n  const getRowId = props.getRowId;\n  const enableClipboardPaste = !props.disableClipboardPaste;\n  const rootEl = apiRef.current.rootElementRef?.current;\n  const logger = (0, _internals.useGridLogger)(apiRef, 'useGridClipboardImport');\n  const splitClipboardPastedText = props.splitClipboardPastedText;\n  const {\n    pagination,\n    onBeforeClipboardPasteStart\n  } = props;\n  const handlePaste = React.useCallback(async (params, event) => {\n    if (!enableClipboardPaste) {\n      return;\n    }\n    if (!(0, _internals.isPasteShortcut)(event)) {\n      return;\n    }\n    const focusedCell = (0, _xDataGrid.gridFocusCellSelector)(apiRef);\n    if (focusedCell !== null) {\n      const cellMode = apiRef.current.getCellMode(focusedCell.id, focusedCell.field);\n      if (cellMode === 'edit') {\n        // Do not paste data when the cell is in edit mode\n        return;\n      }\n    }\n    if (!rootEl) {\n      return;\n    }\n    const text = await getTextFromClipboard(rootEl);\n    if (!text) {\n      return;\n    }\n    const pastedData = splitClipboardPastedText(text);\n    if (!pastedData) {\n      return;\n    }\n    if (onBeforeClipboardPasteStart) {\n      try {\n        await onBeforeClipboardPasteStart({\n          data: pastedData\n        });\n      } catch (error) {\n        logger.debug('Clipboard paste operation cancelled');\n        return;\n      }\n    }\n    const cellUpdater = new CellValueUpdater({\n      apiRef,\n      processRowUpdate,\n      onProcessRowUpdateError,\n      getRowId\n    });\n    apiRef.current.publishEvent('clipboardPasteStart', {\n      data: pastedData\n    });\n    defaultPasteResolver({\n      pastedData,\n      apiRef: (0, _internals.getPublicApiRef)(apiRef),\n      updateCell: (...args) => {\n        cellUpdater.updateCell(...args);\n      },\n      pagination\n    });\n    cellUpdater.applyUpdates();\n  }, [apiRef, processRowUpdate, onProcessRowUpdateError, getRowId, enableClipboardPaste, rootEl, splitClipboardPastedText, pagination, onBeforeClipboardPasteStart, logger]);\n  const checkIfCanStartEditing = React.useCallback((initialValue, {\n    event\n  }) => {\n    if ((0, _internals.isPasteShortcut)(event) && enableClipboardPaste) {\n      // Do not enter cell edit mode on paste\n      return false;\n    }\n    return initialValue;\n  }, [enableClipboardPaste]);\n  (0, _xDataGrid.useGridApiEventHandler)(apiRef, 'cellKeyDown', handlePaste);\n  (0, _xDataGrid.useGridApiOptionHandler)(apiRef, 'clipboardPasteStart', props.onClipboardPasteStart);\n  (0, _xDataGrid.useGridApiOptionHandler)(apiRef, 'clipboardPasteEnd', props.onClipboardPasteEnd);\n  (0, _internals.useGridRegisterPipeProcessor)(apiRef, 'canStartEditing', checkIfCanStartEditing);\n};\nexports.useGridClipboardImport = useGridClipboardImport;"],"mappings":"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"},"metadata":{},"sourceType":"script"}