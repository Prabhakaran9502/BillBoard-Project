{"ast":null,"code":"import { getMonthsInYear } from '../../utils/date-utils';\nexport const getDateSectionConfigFromFormatToken = (utils, formatToken) => {\n  const config = utils.formatTokenMap[formatToken];\n\n  if (config == null) {\n    throw new Error([`MUI X: The token \"${formatToken}\" is not supported by the Date and Time Pickers.`, 'Please try using another token or open an issue on https://github.com/mui/mui-x/issues/new/choose if you think it should be supported.'].join('\\n'));\n  }\n\n  if (typeof config === 'string') {\n    return {\n      type: config,\n      contentType: config === 'meridiem' ? 'letter' : 'digit',\n      maxLength: undefined\n    };\n  }\n\n  return {\n    type: config.sectionType,\n    contentType: config.contentType,\n    maxLength: config.maxLength\n  };\n};\n\nconst getDeltaFromKeyCode = keyCode => {\n  switch (keyCode) {\n    case 'ArrowUp':\n      return 1;\n\n    case 'ArrowDown':\n      return -1;\n\n    case 'PageUp':\n      return 5;\n\n    case 'PageDown':\n      return -5;\n\n    default:\n      return 0;\n  }\n};\n\nexport const getDaysInWeekStr = (utils, timezone, format) => {\n  const elements = [];\n  const now = utils.date(undefined, timezone);\n  const startDate = utils.startOfWeek(now);\n  const endDate = utils.endOfWeek(now);\n  let current = startDate;\n\n  while (utils.isBefore(current, endDate)) {\n    elements.push(current);\n    current = utils.addDays(current, 1);\n  }\n\n  return elements.map(weekDay => utils.formatByString(weekDay, format));\n};\nexport const getLetterEditingOptions = (utils, timezone, sectionType, format) => {\n  switch (sectionType) {\n    case 'month':\n      {\n        return getMonthsInYear(utils, utils.date(undefined, timezone)).map(month => utils.formatByString(month, format));\n      }\n\n    case 'weekDay':\n      {\n        return getDaysInWeekStr(utils, timezone, format);\n      }\n\n    case 'meridiem':\n      {\n        const now = utils.date(undefined, timezone);\n        return [utils.startOfDay(now), utils.endOfDay(now)].map(date => utils.formatByString(date, format));\n      }\n\n    default:\n      {\n        return [];\n      }\n  }\n}; // This format should be the same on all the adapters\n// If some adapter does not respect this convention, then we will need to hardcode the format on each adapter.\n\nexport const FORMAT_SECONDS_NO_LEADING_ZEROS = 's';\nconst NON_LOCALIZED_DIGITS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\nexport const getLocalizedDigits = utils => {\n  const today = utils.date(undefined);\n  const formattedZero = utils.formatByString(utils.setSeconds(today, 0), FORMAT_SECONDS_NO_LEADING_ZEROS);\n\n  if (formattedZero === '0') {\n    return NON_LOCALIZED_DIGITS;\n  }\n\n  return Array.from({\n    length: 10\n  }).map((_, index) => utils.formatByString(utils.setSeconds(today, index), FORMAT_SECONDS_NO_LEADING_ZEROS));\n};\nexport const removeLocalizedDigits = (valueStr, localizedDigits) => {\n  if (localizedDigits[0] === '0') {\n    return valueStr;\n  }\n\n  const digits = [];\n  let currentFormattedDigit = '';\n\n  for (let i = 0; i < valueStr.length; i += 1) {\n    currentFormattedDigit += valueStr[i];\n    const matchingDigitIndex = localizedDigits.indexOf(currentFormattedDigit);\n\n    if (matchingDigitIndex > -1) {\n      digits.push(matchingDigitIndex.toString());\n      currentFormattedDigit = '';\n    }\n  }\n\n  return digits.join('');\n};\nexport const applyLocalizedDigits = (valueStr, localizedDigits) => {\n  if (localizedDigits[0] === '0') {\n    return valueStr;\n  }\n\n  return valueStr.split('').map(char => localizedDigits[Number(char)]).join('');\n};\nexport const isStringNumber = (valueStr, localizedDigits) => {\n  const nonLocalizedValueStr = removeLocalizedDigits(valueStr, localizedDigits); // `Number(' ')` returns `0` even if ' ' is not a valid number.\n\n  return nonLocalizedValueStr !== ' ' && !Number.isNaN(Number(nonLocalizedValueStr));\n};\n/**\n * Remove the leading zeroes to a digit section value.\n * E.g.: `03` => `3`\n * Warning: Should only be called with non-localized digits. Call `removeLocalizedDigits` with your value if needed.\n */\n\nexport const cleanLeadingZeros = (valueStr, size) => {\n  let cleanValueStr = valueStr; // Remove the leading zeros\n\n  cleanValueStr = Number(cleanValueStr).toString(); // Add enough leading zeros to fill the section\n\n  while (cleanValueStr.length < size) {\n    cleanValueStr = `0${cleanValueStr}`;\n  }\n\n  return cleanValueStr;\n};\nexport const cleanDigitSectionValue = (utils, value, sectionBoundaries, localizedDigits, section) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (section.type !== 'day' && section.contentType === 'digit-with-letter') {\n      throw new Error([`MUI X: The token \"${section.format}\" is a digit format with letter in it.'\n             This type of format is only supported for 'day' sections`].join('\\n'));\n    }\n  }\n\n  if (section.type === 'day' && section.contentType === 'digit-with-letter') {\n    const date = utils.setDate(sectionBoundaries.longestMonth, value);\n    return utils.formatByString(date, section.format);\n  } // queryValue without leading `0` (`01` => `1`)\n\n\n  let valueStr = value.toString();\n\n  if (section.hasLeadingZerosInInput) {\n    valueStr = cleanLeadingZeros(valueStr, section.maxLength);\n  }\n\n  return applyLocalizedDigits(valueStr, localizedDigits);\n};\nexport const adjustSectionValue = (utils, timezone, section, keyCode, sectionsValueBoundaries, localizedDigits, activeDate, stepsAttributes) => {\n  const delta = getDeltaFromKeyCode(keyCode);\n  const isStart = keyCode === 'Home';\n  const isEnd = keyCode === 'End';\n  const shouldSetAbsolute = section.value === '' || isStart || isEnd;\n\n  const adjustDigitSection = () => {\n    const sectionBoundaries = sectionsValueBoundaries[section.type]({\n      currentDate: activeDate,\n      format: section.format,\n      contentType: section.contentType\n    });\n\n    const getCleanValue = value => cleanDigitSectionValue(utils, value, sectionBoundaries, localizedDigits, section);\n\n    const step = section.type === 'minutes' && stepsAttributes?.minutesStep ? stepsAttributes.minutesStep : 1;\n    const currentSectionValue = parseInt(removeLocalizedDigits(section.value, localizedDigits), 10);\n    let newSectionValueNumber = currentSectionValue + delta * step;\n\n    if (shouldSetAbsolute) {\n      if (section.type === 'year' && !isEnd && !isStart) {\n        return utils.formatByString(utils.date(undefined, timezone), section.format);\n      }\n\n      if (delta > 0 || isStart) {\n        newSectionValueNumber = sectionBoundaries.minimum;\n      } else {\n        newSectionValueNumber = sectionBoundaries.maximum;\n      }\n    }\n\n    if (newSectionValueNumber % step !== 0) {\n      if (delta < 0 || isStart) {\n        newSectionValueNumber += step - (step + newSectionValueNumber) % step; // for JS -3 % 5 = -3 (should be 2)\n      }\n\n      if (delta > 0 || isEnd) {\n        newSectionValueNumber -= newSectionValueNumber % step;\n      }\n    }\n\n    if (newSectionValueNumber > sectionBoundaries.maximum) {\n      return getCleanValue(sectionBoundaries.minimum + (newSectionValueNumber - sectionBoundaries.maximum - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1));\n    }\n\n    if (newSectionValueNumber < sectionBoundaries.minimum) {\n      return getCleanValue(sectionBoundaries.maximum - (sectionBoundaries.minimum - newSectionValueNumber - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1));\n    }\n\n    return getCleanValue(newSectionValueNumber);\n  };\n\n  const adjustLetterSection = () => {\n    const options = getLetterEditingOptions(utils, timezone, section.type, section.format);\n\n    if (options.length === 0) {\n      return section.value;\n    }\n\n    if (shouldSetAbsolute) {\n      if (delta > 0 || isStart) {\n        return options[0];\n      }\n\n      return options[options.length - 1];\n    }\n\n    const currentOptionIndex = options.indexOf(section.value);\n    const newOptionIndex = (currentOptionIndex + delta) % options.length;\n    const clampedIndex = (newOptionIndex + options.length) % options.length;\n    return options[clampedIndex];\n  };\n\n  if (section.contentType === 'digit' || section.contentType === 'digit-with-letter') {\n    return adjustDigitSection();\n  }\n\n  return adjustLetterSection();\n};\nexport const getSectionVisibleValue = (section, target, localizedDigits) => {\n  let value = section.value || section.placeholder;\n  const hasLeadingZeros = target === 'non-input' ? section.hasLeadingZerosInFormat : section.hasLeadingZerosInInput;\n\n  if (target === 'non-input' && section.hasLeadingZerosInInput && !section.hasLeadingZerosInFormat) {\n    value = Number(removeLocalizedDigits(value, localizedDigits)).toString();\n  } // In the input, we add an empty character at the end of each section without leading zeros.\n  // This makes sure that `onChange` will always be fired.\n  // Otherwise, when your input value equals `1/dd/yyyy` (format `M/DD/YYYY` on DayJs),\n  // If you press `1`, on the first section, the new value is also `1/dd/yyyy`,\n  // So the browser will not fire the input `onChange`.\n\n\n  const shouldAddInvisibleSpace = ['input-rtl', 'input-ltr'].includes(target) && section.contentType === 'digit' && !hasLeadingZeros && value.length === 1;\n\n  if (shouldAddInvisibleSpace) {\n    value = `${value}\\u200e`;\n  }\n\n  if (target === 'input-rtl') {\n    value = `\\u2068${value}\\u2069`;\n  }\n\n  return value;\n};\nexport const changeSectionValueFormat = (utils, valueStr, currentFormat, newFormat) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (getDateSectionConfigFromFormatToken(utils, currentFormat).type === 'weekDay') {\n      throw new Error(\"changeSectionValueFormat doesn't support week day formats\");\n    }\n  }\n\n  return utils.formatByString(utils.parse(valueStr, currentFormat), newFormat);\n};\n\nconst isFourDigitYearFormat = (utils, timezone, format) => utils.formatByString(utils.date(undefined, timezone), format).length === 4;\n\nexport const doesSectionFormatHaveLeadingZeros = (utils, timezone, contentType, sectionType, format) => {\n  if (contentType !== 'digit') {\n    return false;\n  }\n\n  const now = utils.date(undefined, timezone);\n\n  switch (sectionType) {\n    // We can't use `changeSectionValueFormat`, because  `utils.parse('1', 'YYYY')` returns `1971` instead of `1`.\n    case 'year':\n      {\n        if (isFourDigitYearFormat(utils, timezone, format)) {\n          const formatted0001 = utils.formatByString(utils.setYear(now, 1), format);\n          return formatted0001 === '0001';\n        }\n\n        const formatted2001 = utils.formatByString(utils.setYear(now, 2001), format);\n        return formatted2001 === '01';\n      }\n\n    case 'month':\n      {\n        return utils.formatByString(utils.startOfYear(now), format).length > 1;\n      }\n\n    case 'day':\n      {\n        return utils.formatByString(utils.startOfMonth(now), format).length > 1;\n      }\n\n    case 'weekDay':\n      {\n        return utils.formatByString(utils.startOfWeek(now), format).length > 1;\n      }\n\n    case 'hours':\n      {\n        return utils.formatByString(utils.setHours(now, 1), format).length > 1;\n      }\n\n    case 'minutes':\n      {\n        return utils.formatByString(utils.setMinutes(now, 1), format).length > 1;\n      }\n\n    case 'seconds':\n      {\n        return utils.formatByString(utils.setSeconds(now, 1), format).length > 1;\n      }\n\n    default:\n      {\n        throw new Error('Invalid section type');\n      }\n  }\n};\n/**\n * Some date libraries like `dayjs` don't support parsing from date with escaped characters.\n * To make sure that the parsing works, we are building a format and a date without any separator.\n */\n\nexport const getDateFromDateSections = (utils, sections, localizedDigits) => {\n  // If we have both a day and a weekDay section,\n  // Then we skip the weekDay in the parsing because libraries like dayjs can't parse complicated formats containing a weekDay.\n  // dayjs(dayjs().format('dddd MMMM D YYYY'), 'dddd MMMM D YYYY')) // returns `Invalid Date` even if the format is valid.\n  const shouldSkipWeekDays = sections.some(section => section.type === 'day');\n  const sectionFormats = [];\n  const sectionValues = [];\n\n  for (let i = 0; i < sections.length; i += 1) {\n    const section = sections[i];\n    const shouldSkip = shouldSkipWeekDays && section.type === 'weekDay';\n\n    if (!shouldSkip) {\n      sectionFormats.push(section.format);\n      sectionValues.push(getSectionVisibleValue(section, 'non-input', localizedDigits));\n    }\n  }\n\n  const formatWithoutSeparator = sectionFormats.join(' ');\n  const dateWithoutSeparatorStr = sectionValues.join(' ');\n  return utils.parse(dateWithoutSeparatorStr, formatWithoutSeparator);\n};\nexport const createDateStrForV7HiddenInputFromSections = sections => sections.map(section => {\n  return `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`;\n}).join('');\nexport const createDateStrForV6InputFromSections = (sections, localizedDigits, isRtl) => {\n  const formattedSections = sections.map(section => {\n    const dateValue = getSectionVisibleValue(section, isRtl ? 'input-rtl' : 'input-ltr', localizedDigits);\n    return `${section.startSeparator}${dateValue}${section.endSeparator}`;\n  });\n  const dateStr = formattedSections.join('');\n\n  if (!isRtl) {\n    return dateStr;\n  } // \\u2066: start left-to-right isolation\n  // \\u2067: start right-to-left isolation\n  // \\u2068: start first strong character isolation\n  // \\u2069: pop isolation\n  // wrap into an isolated group such that separators can split the string in smaller ones by adding \\u2069\\u2068\n\n\n  return `\\u2066${dateStr}\\u2069`;\n};\nexport const getSectionsBoundaries = (utils, localizedDigits, timezone) => {\n  const today = utils.date(undefined, timezone);\n  const endOfYear = utils.endOfYear(today);\n  const endOfDay = utils.endOfDay(today);\n  const {\n    maxDaysInMonth,\n    longestMonth\n  } = getMonthsInYear(utils, today).reduce((acc, month) => {\n    const daysInMonth = utils.getDaysInMonth(month);\n\n    if (daysInMonth > acc.maxDaysInMonth) {\n      return {\n        maxDaysInMonth: daysInMonth,\n        longestMonth: month\n      };\n    }\n\n    return acc;\n  }, {\n    maxDaysInMonth: 0,\n    longestMonth: null\n  });\n  return {\n    year: _ref => {\n      let {\n        format\n      } = _ref;\n      return {\n        minimum: 0,\n        maximum: isFourDigitYearFormat(utils, timezone, format) ? 9999 : 99\n      };\n    },\n    month: () => ({\n      minimum: 1,\n      // Assumption: All years have the same amount of months\n      maximum: utils.getMonth(endOfYear) + 1\n    }),\n    day: _ref2 => {\n      let {\n        currentDate\n      } = _ref2;\n      return {\n        minimum: 1,\n        maximum: currentDate != null && utils.isValid(currentDate) ? utils.getDaysInMonth(currentDate) : maxDaysInMonth,\n        longestMonth: longestMonth\n      };\n    },\n    weekDay: _ref3 => {\n      let {\n        format,\n        contentType\n      } = _ref3;\n\n      if (contentType === 'digit') {\n        const daysInWeek = getDaysInWeekStr(utils, timezone, format).map(Number);\n        return {\n          minimum: Math.min(...daysInWeek),\n          maximum: Math.max(...daysInWeek)\n        };\n      }\n\n      return {\n        minimum: 1,\n        maximum: 7\n      };\n    },\n    hours: _ref4 => {\n      let {\n        format\n      } = _ref4;\n      const lastHourInDay = utils.getHours(endOfDay);\n      const hasMeridiem = removeLocalizedDigits(utils.formatByString(utils.endOfDay(today), format), localizedDigits) !== lastHourInDay.toString();\n\n      if (hasMeridiem) {\n        return {\n          minimum: 1,\n          maximum: Number(removeLocalizedDigits(utils.formatByString(utils.startOfDay(today), format), localizedDigits))\n        };\n      }\n\n      return {\n        minimum: 0,\n        maximum: lastHourInDay\n      };\n    },\n    minutes: () => ({\n      minimum: 0,\n      // Assumption: All years have the same amount of minutes\n      maximum: utils.getMinutes(endOfDay)\n    }),\n    seconds: () => ({\n      minimum: 0,\n      // Assumption: All years have the same amount of seconds\n      maximum: utils.getSeconds(endOfDay)\n    }),\n    meridiem: () => ({\n      minimum: 0,\n      maximum: 1\n    }),\n    empty: () => ({\n      minimum: 0,\n      maximum: 0\n    })\n  };\n};\nlet warnedOnceInvalidSection = false;\nexport const validateSections = (sections, valueType) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!warnedOnceInvalidSection) {\n      const supportedSections = ['empty'];\n\n      if (['date', 'date-time'].includes(valueType)) {\n        supportedSections.push('weekDay', 'day', 'month', 'year');\n      }\n\n      if (['time', 'date-time'].includes(valueType)) {\n        supportedSections.push('hours', 'minutes', 'seconds', 'meridiem');\n      }\n\n      const invalidSection = sections.find(section => !supportedSections.includes(section.type));\n\n      if (invalidSection) {\n        console.warn(`MUI X: The field component you are using is not compatible with the \"${invalidSection.type}\" date section.`, `The supported date sections are [\"${supportedSections.join('\", \"')}\"]\\`.`);\n        warnedOnceInvalidSection = true;\n      }\n    }\n  }\n};\n\nconst transferDateSectionValue = (utils, timezone, section, dateToTransferFrom, dateToTransferTo) => {\n  switch (section.type) {\n    case 'year':\n      {\n        return utils.setYear(dateToTransferTo, utils.getYear(dateToTransferFrom));\n      }\n\n    case 'month':\n      {\n        return utils.setMonth(dateToTransferTo, utils.getMonth(dateToTransferFrom));\n      }\n\n    case 'weekDay':\n      {\n        const formattedDaysInWeek = getDaysInWeekStr(utils, timezone, section.format);\n        const dayInWeekStrOfActiveDate = utils.formatByString(dateToTransferFrom, section.format);\n        const dayInWeekOfActiveDate = formattedDaysInWeek.indexOf(dayInWeekStrOfActiveDate);\n        const dayInWeekOfNewSectionValue = formattedDaysInWeek.indexOf(section.value);\n        const diff = dayInWeekOfNewSectionValue - dayInWeekOfActiveDate;\n        return utils.addDays(dateToTransferFrom, diff);\n      }\n\n    case 'day':\n      {\n        return utils.setDate(dateToTransferTo, utils.getDate(dateToTransferFrom));\n      }\n\n    case 'meridiem':\n      {\n        const isAM = utils.getHours(dateToTransferFrom) < 12;\n        const mergedDateHours = utils.getHours(dateToTransferTo);\n\n        if (isAM && mergedDateHours >= 12) {\n          return utils.addHours(dateToTransferTo, -12);\n        }\n\n        if (!isAM && mergedDateHours < 12) {\n          return utils.addHours(dateToTransferTo, 12);\n        }\n\n        return dateToTransferTo;\n      }\n\n    case 'hours':\n      {\n        return utils.setHours(dateToTransferTo, utils.getHours(dateToTransferFrom));\n      }\n\n    case 'minutes':\n      {\n        return utils.setMinutes(dateToTransferTo, utils.getMinutes(dateToTransferFrom));\n      }\n\n    case 'seconds':\n      {\n        return utils.setSeconds(dateToTransferTo, utils.getSeconds(dateToTransferFrom));\n      }\n\n    default:\n      {\n        return dateToTransferTo;\n      }\n  }\n};\n\nconst reliableSectionModificationOrder = {\n  year: 1,\n  month: 2,\n  day: 3,\n  weekDay: 4,\n  hours: 5,\n  minutes: 6,\n  seconds: 7,\n  meridiem: 8,\n  empty: 9\n};\nexport const mergeDateIntoReferenceDate = (utils, timezone, dateToTransferFrom, sections, referenceDate, shouldLimitToEditedSections) => // cloning sections before sort to avoid mutating it\n[...sections].sort((a, b) => reliableSectionModificationOrder[a.type] - reliableSectionModificationOrder[b.type]).reduce((mergedDate, section) => {\n  if (!shouldLimitToEditedSections || section.modified) {\n    return transferDateSectionValue(utils, timezone, section, dateToTransferFrom, mergedDate);\n  }\n\n  return mergedDate;\n}, referenceDate);\nexport const isAndroid = () => navigator.userAgent.toLowerCase().indexOf('android') > -1; // TODO v8: Remove if we drop the v6 TextField approach.\n\nexport const getSectionOrder = (sections, shouldApplyRTL) => {\n  const neighbors = {};\n\n  if (!shouldApplyRTL) {\n    sections.forEach((_, index) => {\n      const leftIndex = index === 0 ? null : index - 1;\n      const rightIndex = index === sections.length - 1 ? null : index + 1;\n      neighbors[index] = {\n        leftIndex,\n        rightIndex\n      };\n    });\n    return {\n      neighbors,\n      startIndex: 0,\n      endIndex: sections.length - 1\n    };\n  }\n\n  const rtl2ltr = {};\n  const ltr2rtl = {};\n  let groupedSectionsStart = 0;\n  let groupedSectionsEnd = 0;\n  let RTLIndex = sections.length - 1;\n\n  while (RTLIndex >= 0) {\n    groupedSectionsEnd = sections.findIndex( // eslint-disable-next-line @typescript-eslint/no-loop-func\n    (section, index) => index >= groupedSectionsStart && section.endSeparator?.includes(' ') && // Special case where the spaces were not there in the initial input\n    section.endSeparator !== ' / ');\n\n    if (groupedSectionsEnd === -1) {\n      groupedSectionsEnd = sections.length - 1;\n    }\n\n    for (let i = groupedSectionsEnd; i >= groupedSectionsStart; i -= 1) {\n      ltr2rtl[i] = RTLIndex;\n      rtl2ltr[RTLIndex] = i;\n      RTLIndex -= 1;\n    }\n\n    groupedSectionsStart = groupedSectionsEnd + 1;\n  }\n\n  sections.forEach((_, index) => {\n    const rtlIndex = ltr2rtl[index];\n    const leftIndex = rtlIndex === 0 ? null : rtl2ltr[rtlIndex - 1];\n    const rightIndex = rtlIndex === sections.length - 1 ? null : rtl2ltr[rtlIndex + 1];\n    neighbors[index] = {\n      leftIndex,\n      rightIndex\n    };\n  });\n  return {\n    neighbors,\n    startIndex: rtl2ltr[0],\n    endIndex: rtl2ltr[sections.length - 1]\n  };\n};\nexport const parseSelectedSections = (selectedSections, sections) => {\n  if (selectedSections == null) {\n    return null;\n  }\n\n  if (selectedSections === 'all') {\n    return 'all';\n  }\n\n  if (typeof selectedSections === 'string') {\n    return sections.findIndex(section => section.type === selectedSections);\n  }\n\n  return selectedSections;\n};\nexport const getSectionValueText = (section, utils) => {\n  if (!section.value) {\n    return undefined;\n  }\n\n  switch (section.type) {\n    case 'month':\n      {\n        if (section.contentType === 'digit') {\n          return utils.format(utils.setMonth(utils.date(), Number(section.value) - 1), 'month');\n        }\n\n        const parsedDate = utils.parse(section.value, section.format);\n        return parsedDate ? utils.format(parsedDate, 'month') : undefined;\n      }\n\n    case 'day':\n      return section.contentType === 'digit' ? utils.format(utils.setDate(utils.startOfYear(utils.date()), Number(section.value)), 'dayOfMonthFull') : section.value;\n\n    case 'weekDay':\n      // TODO: improve by providing the label of the week day\n      return undefined;\n\n    default:\n      return undefined;\n  }\n};\nexport const getSectionValueNow = (section, utils) => {\n  if (!section.value) {\n    return undefined;\n  }\n\n  switch (section.type) {\n    case 'weekDay':\n      {\n        if (section.contentType === 'letter') {\n          // TODO: improve by resolving the week day number from a letter week day\n          return undefined;\n        }\n\n        return Number(section.value);\n      }\n\n    case 'meridiem':\n      {\n        const parsedDate = utils.parse(`01:00 ${section.value}`, `${utils.formats.hours12h}:${utils.formats.minutes} ${section.format}`);\n\n        if (parsedDate) {\n          return utils.getHours(parsedDate) >= 12 ? 1 : 0;\n        }\n\n        return undefined;\n      }\n\n    case 'day':\n      return section.contentType === 'digit-with-letter' ? parseInt(section.value, 10) : Number(section.value);\n\n    case 'month':\n      {\n        if (section.contentType === 'digit') {\n          return Number(section.value);\n        }\n\n        const parsedDate = utils.parse(section.value, section.format);\n        return parsedDate ? utils.getMonth(parsedDate) + 1 : undefined;\n      }\n\n    default:\n      return section.contentType !== 'letter' ? Number(section.value) : undefined;\n  }\n};","map":{"version":3,"names":["getMonthsInYear","getDateSectionConfigFromFormatToken","utils","formatToken","config","formatTokenMap","Error","join","type","contentType","maxLength","undefined","sectionType","getDeltaFromKeyCode","keyCode","getDaysInWeekStr","timezone","format","elements","now","date","startDate","startOfWeek","endDate","endOfWeek","current","isBefore","push","addDays","map","weekDay","formatByString","getLetterEditingOptions","month","startOfDay","endOfDay","FORMAT_SECONDS_NO_LEADING_ZEROS","NON_LOCALIZED_DIGITS","getLocalizedDigits","today","formattedZero","setSeconds","Array","from","length","_","index","removeLocalizedDigits","valueStr","localizedDigits","digits","currentFormattedDigit","i","matchingDigitIndex","indexOf","toString","applyLocalizedDigits","split","char","Number","isStringNumber","nonLocalizedValueStr","isNaN","cleanLeadingZeros","size","cleanValueStr","cleanDigitSectionValue","value","sectionBoundaries","section","process","env","NODE_ENV","setDate","longestMonth","hasLeadingZerosInInput","adjustSectionValue","sectionsValueBoundaries","activeDate","stepsAttributes","delta","isStart","isEnd","shouldSetAbsolute","adjustDigitSection","currentDate","getCleanValue","step","minutesStep","currentSectionValue","parseInt","newSectionValueNumber","minimum","maximum","adjustLetterSection","options","currentOptionIndex","newOptionIndex","clampedIndex","getSectionVisibleValue","target","placeholder","hasLeadingZeros","hasLeadingZerosInFormat","shouldAddInvisibleSpace","includes","changeSectionValueFormat","currentFormat","newFormat","parse","isFourDigitYearFormat","doesSectionFormatHaveLeadingZeros","formatted0001","setYear","formatted2001","startOfYear","startOfMonth","setHours","setMinutes","getDateFromDateSections","sections","shouldSkipWeekDays","some","sectionFormats","sectionValues","shouldSkip","formatWithoutSeparator","dateWithoutSeparatorStr","createDateStrForV7HiddenInputFromSections","startSeparator","endSeparator","createDateStrForV6InputFromSections","isRtl","formattedSections","dateValue","dateStr","getSectionsBoundaries","endOfYear","maxDaysInMonth","reduce","acc","daysInMonth","getDaysInMonth","year","getMonth","day","isValid","daysInWeek","Math","min","max","hours","lastHourInDay","getHours","hasMeridiem","minutes","getMinutes","seconds","getSeconds","meridiem","empty","warnedOnceInvalidSection","validateSections","valueType","supportedSections","invalidSection","find","console","warn","transferDateSectionValue","dateToTransferFrom","dateToTransferTo","getYear","setMonth","formattedDaysInWeek","dayInWeekStrOfActiveDate","dayInWeekOfActiveDate","dayInWeekOfNewSectionValue","diff","getDate","isAM","mergedDateHours","addHours","reliableSectionModificationOrder","mergeDateIntoReferenceDate","referenceDate","shouldLimitToEditedSections","sort","a","b","mergedDate","modified","isAndroid","navigator","userAgent","toLowerCase","getSectionOrder","shouldApplyRTL","neighbors","forEach","leftIndex","rightIndex","startIndex","endIndex","rtl2ltr","ltr2rtl","groupedSectionsStart","groupedSectionsEnd","RTLIndex","findIndex","rtlIndex","parseSelectedSections","selectedSections","getSectionValueText","parsedDate","getSectionValueNow","formats","hours12h"],"sources":["C:/Users/kb/Downloads/billBoard/billboard/node_modules/@mui/x-date-pickers/internals/hooks/useField/useField.utils.js"],"sourcesContent":["import { getMonthsInYear } from '../../utils/date-utils';\nexport const getDateSectionConfigFromFormatToken = (utils, formatToken) => {\n  const config = utils.formatTokenMap[formatToken];\n  if (config == null) {\n    throw new Error([`MUI X: The token \"${formatToken}\" is not supported by the Date and Time Pickers.`, 'Please try using another token or open an issue on https://github.com/mui/mui-x/issues/new/choose if you think it should be supported.'].join('\\n'));\n  }\n  if (typeof config === 'string') {\n    return {\n      type: config,\n      contentType: config === 'meridiem' ? 'letter' : 'digit',\n      maxLength: undefined\n    };\n  }\n  return {\n    type: config.sectionType,\n    contentType: config.contentType,\n    maxLength: config.maxLength\n  };\n};\nconst getDeltaFromKeyCode = keyCode => {\n  switch (keyCode) {\n    case 'ArrowUp':\n      return 1;\n    case 'ArrowDown':\n      return -1;\n    case 'PageUp':\n      return 5;\n    case 'PageDown':\n      return -5;\n    default:\n      return 0;\n  }\n};\nexport const getDaysInWeekStr = (utils, timezone, format) => {\n  const elements = [];\n  const now = utils.date(undefined, timezone);\n  const startDate = utils.startOfWeek(now);\n  const endDate = utils.endOfWeek(now);\n  let current = startDate;\n  while (utils.isBefore(current, endDate)) {\n    elements.push(current);\n    current = utils.addDays(current, 1);\n  }\n  return elements.map(weekDay => utils.formatByString(weekDay, format));\n};\nexport const getLetterEditingOptions = (utils, timezone, sectionType, format) => {\n  switch (sectionType) {\n    case 'month':\n      {\n        return getMonthsInYear(utils, utils.date(undefined, timezone)).map(month => utils.formatByString(month, format));\n      }\n    case 'weekDay':\n      {\n        return getDaysInWeekStr(utils, timezone, format);\n      }\n    case 'meridiem':\n      {\n        const now = utils.date(undefined, timezone);\n        return [utils.startOfDay(now), utils.endOfDay(now)].map(date => utils.formatByString(date, format));\n      }\n    default:\n      {\n        return [];\n      }\n  }\n};\n\n// This format should be the same on all the adapters\n// If some adapter does not respect this convention, then we will need to hardcode the format on each adapter.\nexport const FORMAT_SECONDS_NO_LEADING_ZEROS = 's';\nconst NON_LOCALIZED_DIGITS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\nexport const getLocalizedDigits = utils => {\n  const today = utils.date(undefined);\n  const formattedZero = utils.formatByString(utils.setSeconds(today, 0), FORMAT_SECONDS_NO_LEADING_ZEROS);\n  if (formattedZero === '0') {\n    return NON_LOCALIZED_DIGITS;\n  }\n  return Array.from({\n    length: 10\n  }).map((_, index) => utils.formatByString(utils.setSeconds(today, index), FORMAT_SECONDS_NO_LEADING_ZEROS));\n};\nexport const removeLocalizedDigits = (valueStr, localizedDigits) => {\n  if (localizedDigits[0] === '0') {\n    return valueStr;\n  }\n  const digits = [];\n  let currentFormattedDigit = '';\n  for (let i = 0; i < valueStr.length; i += 1) {\n    currentFormattedDigit += valueStr[i];\n    const matchingDigitIndex = localizedDigits.indexOf(currentFormattedDigit);\n    if (matchingDigitIndex > -1) {\n      digits.push(matchingDigitIndex.toString());\n      currentFormattedDigit = '';\n    }\n  }\n  return digits.join('');\n};\nexport const applyLocalizedDigits = (valueStr, localizedDigits) => {\n  if (localizedDigits[0] === '0') {\n    return valueStr;\n  }\n  return valueStr.split('').map(char => localizedDigits[Number(char)]).join('');\n};\nexport const isStringNumber = (valueStr, localizedDigits) => {\n  const nonLocalizedValueStr = removeLocalizedDigits(valueStr, localizedDigits);\n  // `Number(' ')` returns `0` even if ' ' is not a valid number.\n  return nonLocalizedValueStr !== ' ' && !Number.isNaN(Number(nonLocalizedValueStr));\n};\n\n/**\n * Remove the leading zeroes to a digit section value.\n * E.g.: `03` => `3`\n * Warning: Should only be called with non-localized digits. Call `removeLocalizedDigits` with your value if needed.\n */\nexport const cleanLeadingZeros = (valueStr, size) => {\n  let cleanValueStr = valueStr;\n\n  // Remove the leading zeros\n  cleanValueStr = Number(cleanValueStr).toString();\n\n  // Add enough leading zeros to fill the section\n  while (cleanValueStr.length < size) {\n    cleanValueStr = `0${cleanValueStr}`;\n  }\n  return cleanValueStr;\n};\nexport const cleanDigitSectionValue = (utils, value, sectionBoundaries, localizedDigits, section) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (section.type !== 'day' && section.contentType === 'digit-with-letter') {\n      throw new Error([`MUI X: The token \"${section.format}\" is a digit format with letter in it.'\n             This type of format is only supported for 'day' sections`].join('\\n'));\n    }\n  }\n  if (section.type === 'day' && section.contentType === 'digit-with-letter') {\n    const date = utils.setDate(sectionBoundaries.longestMonth, value);\n    return utils.formatByString(date, section.format);\n  }\n\n  // queryValue without leading `0` (`01` => `1`)\n  let valueStr = value.toString();\n  if (section.hasLeadingZerosInInput) {\n    valueStr = cleanLeadingZeros(valueStr, section.maxLength);\n  }\n  return applyLocalizedDigits(valueStr, localizedDigits);\n};\nexport const adjustSectionValue = (utils, timezone, section, keyCode, sectionsValueBoundaries, localizedDigits, activeDate, stepsAttributes) => {\n  const delta = getDeltaFromKeyCode(keyCode);\n  const isStart = keyCode === 'Home';\n  const isEnd = keyCode === 'End';\n  const shouldSetAbsolute = section.value === '' || isStart || isEnd;\n  const adjustDigitSection = () => {\n    const sectionBoundaries = sectionsValueBoundaries[section.type]({\n      currentDate: activeDate,\n      format: section.format,\n      contentType: section.contentType\n    });\n    const getCleanValue = value => cleanDigitSectionValue(utils, value, sectionBoundaries, localizedDigits, section);\n    const step = section.type === 'minutes' && stepsAttributes?.minutesStep ? stepsAttributes.minutesStep : 1;\n    const currentSectionValue = parseInt(removeLocalizedDigits(section.value, localizedDigits), 10);\n    let newSectionValueNumber = currentSectionValue + delta * step;\n    if (shouldSetAbsolute) {\n      if (section.type === 'year' && !isEnd && !isStart) {\n        return utils.formatByString(utils.date(undefined, timezone), section.format);\n      }\n      if (delta > 0 || isStart) {\n        newSectionValueNumber = sectionBoundaries.minimum;\n      } else {\n        newSectionValueNumber = sectionBoundaries.maximum;\n      }\n    }\n    if (newSectionValueNumber % step !== 0) {\n      if (delta < 0 || isStart) {\n        newSectionValueNumber += step - (step + newSectionValueNumber) % step; // for JS -3 % 5 = -3 (should be 2)\n      }\n      if (delta > 0 || isEnd) {\n        newSectionValueNumber -= newSectionValueNumber % step;\n      }\n    }\n    if (newSectionValueNumber > sectionBoundaries.maximum) {\n      return getCleanValue(sectionBoundaries.minimum + (newSectionValueNumber - sectionBoundaries.maximum - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1));\n    }\n    if (newSectionValueNumber < sectionBoundaries.minimum) {\n      return getCleanValue(sectionBoundaries.maximum - (sectionBoundaries.minimum - newSectionValueNumber - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1));\n    }\n    return getCleanValue(newSectionValueNumber);\n  };\n  const adjustLetterSection = () => {\n    const options = getLetterEditingOptions(utils, timezone, section.type, section.format);\n    if (options.length === 0) {\n      return section.value;\n    }\n    if (shouldSetAbsolute) {\n      if (delta > 0 || isStart) {\n        return options[0];\n      }\n      return options[options.length - 1];\n    }\n    const currentOptionIndex = options.indexOf(section.value);\n    const newOptionIndex = (currentOptionIndex + delta) % options.length;\n    const clampedIndex = (newOptionIndex + options.length) % options.length;\n    return options[clampedIndex];\n  };\n  if (section.contentType === 'digit' || section.contentType === 'digit-with-letter') {\n    return adjustDigitSection();\n  }\n  return adjustLetterSection();\n};\nexport const getSectionVisibleValue = (section, target, localizedDigits) => {\n  let value = section.value || section.placeholder;\n  const hasLeadingZeros = target === 'non-input' ? section.hasLeadingZerosInFormat : section.hasLeadingZerosInInput;\n  if (target === 'non-input' && section.hasLeadingZerosInInput && !section.hasLeadingZerosInFormat) {\n    value = Number(removeLocalizedDigits(value, localizedDigits)).toString();\n  }\n\n  // In the input, we add an empty character at the end of each section without leading zeros.\n  // This makes sure that `onChange` will always be fired.\n  // Otherwise, when your input value equals `1/dd/yyyy` (format `M/DD/YYYY` on DayJs),\n  // If you press `1`, on the first section, the new value is also `1/dd/yyyy`,\n  // So the browser will not fire the input `onChange`.\n  const shouldAddInvisibleSpace = ['input-rtl', 'input-ltr'].includes(target) && section.contentType === 'digit' && !hasLeadingZeros && value.length === 1;\n  if (shouldAddInvisibleSpace) {\n    value = `${value}\\u200e`;\n  }\n  if (target === 'input-rtl') {\n    value = `\\u2068${value}\\u2069`;\n  }\n  return value;\n};\nexport const changeSectionValueFormat = (utils, valueStr, currentFormat, newFormat) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (getDateSectionConfigFromFormatToken(utils, currentFormat).type === 'weekDay') {\n      throw new Error(\"changeSectionValueFormat doesn't support week day formats\");\n    }\n  }\n  return utils.formatByString(utils.parse(valueStr, currentFormat), newFormat);\n};\nconst isFourDigitYearFormat = (utils, timezone, format) => utils.formatByString(utils.date(undefined, timezone), format).length === 4;\nexport const doesSectionFormatHaveLeadingZeros = (utils, timezone, contentType, sectionType, format) => {\n  if (contentType !== 'digit') {\n    return false;\n  }\n  const now = utils.date(undefined, timezone);\n  switch (sectionType) {\n    // We can't use `changeSectionValueFormat`, because  `utils.parse('1', 'YYYY')` returns `1971` instead of `1`.\n    case 'year':\n      {\n        if (isFourDigitYearFormat(utils, timezone, format)) {\n          const formatted0001 = utils.formatByString(utils.setYear(now, 1), format);\n          return formatted0001 === '0001';\n        }\n        const formatted2001 = utils.formatByString(utils.setYear(now, 2001), format);\n        return formatted2001 === '01';\n      }\n    case 'month':\n      {\n        return utils.formatByString(utils.startOfYear(now), format).length > 1;\n      }\n    case 'day':\n      {\n        return utils.formatByString(utils.startOfMonth(now), format).length > 1;\n      }\n    case 'weekDay':\n      {\n        return utils.formatByString(utils.startOfWeek(now), format).length > 1;\n      }\n    case 'hours':\n      {\n        return utils.formatByString(utils.setHours(now, 1), format).length > 1;\n      }\n    case 'minutes':\n      {\n        return utils.formatByString(utils.setMinutes(now, 1), format).length > 1;\n      }\n    case 'seconds':\n      {\n        return utils.formatByString(utils.setSeconds(now, 1), format).length > 1;\n      }\n    default:\n      {\n        throw new Error('Invalid section type');\n      }\n  }\n};\n\n/**\n * Some date libraries like `dayjs` don't support parsing from date with escaped characters.\n * To make sure that the parsing works, we are building a format and a date without any separator.\n */\nexport const getDateFromDateSections = (utils, sections, localizedDigits) => {\n  // If we have both a day and a weekDay section,\n  // Then we skip the weekDay in the parsing because libraries like dayjs can't parse complicated formats containing a weekDay.\n  // dayjs(dayjs().format('dddd MMMM D YYYY'), 'dddd MMMM D YYYY')) // returns `Invalid Date` even if the format is valid.\n  const shouldSkipWeekDays = sections.some(section => section.type === 'day');\n  const sectionFormats = [];\n  const sectionValues = [];\n  for (let i = 0; i < sections.length; i += 1) {\n    const section = sections[i];\n    const shouldSkip = shouldSkipWeekDays && section.type === 'weekDay';\n    if (!shouldSkip) {\n      sectionFormats.push(section.format);\n      sectionValues.push(getSectionVisibleValue(section, 'non-input', localizedDigits));\n    }\n  }\n  const formatWithoutSeparator = sectionFormats.join(' ');\n  const dateWithoutSeparatorStr = sectionValues.join(' ');\n  return utils.parse(dateWithoutSeparatorStr, formatWithoutSeparator);\n};\nexport const createDateStrForV7HiddenInputFromSections = sections => sections.map(section => {\n  return `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`;\n}).join('');\nexport const createDateStrForV6InputFromSections = (sections, localizedDigits, isRtl) => {\n  const formattedSections = sections.map(section => {\n    const dateValue = getSectionVisibleValue(section, isRtl ? 'input-rtl' : 'input-ltr', localizedDigits);\n    return `${section.startSeparator}${dateValue}${section.endSeparator}`;\n  });\n  const dateStr = formattedSections.join('');\n  if (!isRtl) {\n    return dateStr;\n  }\n\n  // \\u2066: start left-to-right isolation\n  // \\u2067: start right-to-left isolation\n  // \\u2068: start first strong character isolation\n  // \\u2069: pop isolation\n  // wrap into an isolated group such that separators can split the string in smaller ones by adding \\u2069\\u2068\n  return `\\u2066${dateStr}\\u2069`;\n};\nexport const getSectionsBoundaries = (utils, localizedDigits, timezone) => {\n  const today = utils.date(undefined, timezone);\n  const endOfYear = utils.endOfYear(today);\n  const endOfDay = utils.endOfDay(today);\n  const {\n    maxDaysInMonth,\n    longestMonth\n  } = getMonthsInYear(utils, today).reduce((acc, month) => {\n    const daysInMonth = utils.getDaysInMonth(month);\n    if (daysInMonth > acc.maxDaysInMonth) {\n      return {\n        maxDaysInMonth: daysInMonth,\n        longestMonth: month\n      };\n    }\n    return acc;\n  }, {\n    maxDaysInMonth: 0,\n    longestMonth: null\n  });\n  return {\n    year: ({\n      format\n    }) => ({\n      minimum: 0,\n      maximum: isFourDigitYearFormat(utils, timezone, format) ? 9999 : 99\n    }),\n    month: () => ({\n      minimum: 1,\n      // Assumption: All years have the same amount of months\n      maximum: utils.getMonth(endOfYear) + 1\n    }),\n    day: ({\n      currentDate\n    }) => ({\n      minimum: 1,\n      maximum: currentDate != null && utils.isValid(currentDate) ? utils.getDaysInMonth(currentDate) : maxDaysInMonth,\n      longestMonth: longestMonth\n    }),\n    weekDay: ({\n      format,\n      contentType\n    }) => {\n      if (contentType === 'digit') {\n        const daysInWeek = getDaysInWeekStr(utils, timezone, format).map(Number);\n        return {\n          minimum: Math.min(...daysInWeek),\n          maximum: Math.max(...daysInWeek)\n        };\n      }\n      return {\n        minimum: 1,\n        maximum: 7\n      };\n    },\n    hours: ({\n      format\n    }) => {\n      const lastHourInDay = utils.getHours(endOfDay);\n      const hasMeridiem = removeLocalizedDigits(utils.formatByString(utils.endOfDay(today), format), localizedDigits) !== lastHourInDay.toString();\n      if (hasMeridiem) {\n        return {\n          minimum: 1,\n          maximum: Number(removeLocalizedDigits(utils.formatByString(utils.startOfDay(today), format), localizedDigits))\n        };\n      }\n      return {\n        minimum: 0,\n        maximum: lastHourInDay\n      };\n    },\n    minutes: () => ({\n      minimum: 0,\n      // Assumption: All years have the same amount of minutes\n      maximum: utils.getMinutes(endOfDay)\n    }),\n    seconds: () => ({\n      minimum: 0,\n      // Assumption: All years have the same amount of seconds\n      maximum: utils.getSeconds(endOfDay)\n    }),\n    meridiem: () => ({\n      minimum: 0,\n      maximum: 1\n    }),\n    empty: () => ({\n      minimum: 0,\n      maximum: 0\n    })\n  };\n};\nlet warnedOnceInvalidSection = false;\nexport const validateSections = (sections, valueType) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!warnedOnceInvalidSection) {\n      const supportedSections = ['empty'];\n      if (['date', 'date-time'].includes(valueType)) {\n        supportedSections.push('weekDay', 'day', 'month', 'year');\n      }\n      if (['time', 'date-time'].includes(valueType)) {\n        supportedSections.push('hours', 'minutes', 'seconds', 'meridiem');\n      }\n      const invalidSection = sections.find(section => !supportedSections.includes(section.type));\n      if (invalidSection) {\n        console.warn(`MUI X: The field component you are using is not compatible with the \"${invalidSection.type}\" date section.`, `The supported date sections are [\"${supportedSections.join('\", \"')}\"]\\`.`);\n        warnedOnceInvalidSection = true;\n      }\n    }\n  }\n};\nconst transferDateSectionValue = (utils, timezone, section, dateToTransferFrom, dateToTransferTo) => {\n  switch (section.type) {\n    case 'year':\n      {\n        return utils.setYear(dateToTransferTo, utils.getYear(dateToTransferFrom));\n      }\n    case 'month':\n      {\n        return utils.setMonth(dateToTransferTo, utils.getMonth(dateToTransferFrom));\n      }\n    case 'weekDay':\n      {\n        const formattedDaysInWeek = getDaysInWeekStr(utils, timezone, section.format);\n        const dayInWeekStrOfActiveDate = utils.formatByString(dateToTransferFrom, section.format);\n        const dayInWeekOfActiveDate = formattedDaysInWeek.indexOf(dayInWeekStrOfActiveDate);\n        const dayInWeekOfNewSectionValue = formattedDaysInWeek.indexOf(section.value);\n        const diff = dayInWeekOfNewSectionValue - dayInWeekOfActiveDate;\n        return utils.addDays(dateToTransferFrom, diff);\n      }\n    case 'day':\n      {\n        return utils.setDate(dateToTransferTo, utils.getDate(dateToTransferFrom));\n      }\n    case 'meridiem':\n      {\n        const isAM = utils.getHours(dateToTransferFrom) < 12;\n        const mergedDateHours = utils.getHours(dateToTransferTo);\n        if (isAM && mergedDateHours >= 12) {\n          return utils.addHours(dateToTransferTo, -12);\n        }\n        if (!isAM && mergedDateHours < 12) {\n          return utils.addHours(dateToTransferTo, 12);\n        }\n        return dateToTransferTo;\n      }\n    case 'hours':\n      {\n        return utils.setHours(dateToTransferTo, utils.getHours(dateToTransferFrom));\n      }\n    case 'minutes':\n      {\n        return utils.setMinutes(dateToTransferTo, utils.getMinutes(dateToTransferFrom));\n      }\n    case 'seconds':\n      {\n        return utils.setSeconds(dateToTransferTo, utils.getSeconds(dateToTransferFrom));\n      }\n    default:\n      {\n        return dateToTransferTo;\n      }\n  }\n};\nconst reliableSectionModificationOrder = {\n  year: 1,\n  month: 2,\n  day: 3,\n  weekDay: 4,\n  hours: 5,\n  minutes: 6,\n  seconds: 7,\n  meridiem: 8,\n  empty: 9\n};\nexport const mergeDateIntoReferenceDate = (utils, timezone, dateToTransferFrom, sections, referenceDate, shouldLimitToEditedSections) =>\n// cloning sections before sort to avoid mutating it\n[...sections].sort((a, b) => reliableSectionModificationOrder[a.type] - reliableSectionModificationOrder[b.type]).reduce((mergedDate, section) => {\n  if (!shouldLimitToEditedSections || section.modified) {\n    return transferDateSectionValue(utils, timezone, section, dateToTransferFrom, mergedDate);\n  }\n  return mergedDate;\n}, referenceDate);\nexport const isAndroid = () => navigator.userAgent.toLowerCase().indexOf('android') > -1;\n\n// TODO v8: Remove if we drop the v6 TextField approach.\nexport const getSectionOrder = (sections, shouldApplyRTL) => {\n  const neighbors = {};\n  if (!shouldApplyRTL) {\n    sections.forEach((_, index) => {\n      const leftIndex = index === 0 ? null : index - 1;\n      const rightIndex = index === sections.length - 1 ? null : index + 1;\n      neighbors[index] = {\n        leftIndex,\n        rightIndex\n      };\n    });\n    return {\n      neighbors,\n      startIndex: 0,\n      endIndex: sections.length - 1\n    };\n  }\n  const rtl2ltr = {};\n  const ltr2rtl = {};\n  let groupedSectionsStart = 0;\n  let groupedSectionsEnd = 0;\n  let RTLIndex = sections.length - 1;\n  while (RTLIndex >= 0) {\n    groupedSectionsEnd = sections.findIndex(\n    // eslint-disable-next-line @typescript-eslint/no-loop-func\n    (section, index) => index >= groupedSectionsStart && section.endSeparator?.includes(' ') &&\n    // Special case where the spaces were not there in the initial input\n    section.endSeparator !== ' / ');\n    if (groupedSectionsEnd === -1) {\n      groupedSectionsEnd = sections.length - 1;\n    }\n    for (let i = groupedSectionsEnd; i >= groupedSectionsStart; i -= 1) {\n      ltr2rtl[i] = RTLIndex;\n      rtl2ltr[RTLIndex] = i;\n      RTLIndex -= 1;\n    }\n    groupedSectionsStart = groupedSectionsEnd + 1;\n  }\n  sections.forEach((_, index) => {\n    const rtlIndex = ltr2rtl[index];\n    const leftIndex = rtlIndex === 0 ? null : rtl2ltr[rtlIndex - 1];\n    const rightIndex = rtlIndex === sections.length - 1 ? null : rtl2ltr[rtlIndex + 1];\n    neighbors[index] = {\n      leftIndex,\n      rightIndex\n    };\n  });\n  return {\n    neighbors,\n    startIndex: rtl2ltr[0],\n    endIndex: rtl2ltr[sections.length - 1]\n  };\n};\nexport const parseSelectedSections = (selectedSections, sections) => {\n  if (selectedSections == null) {\n    return null;\n  }\n  if (selectedSections === 'all') {\n    return 'all';\n  }\n  if (typeof selectedSections === 'string') {\n    return sections.findIndex(section => section.type === selectedSections);\n  }\n  return selectedSections;\n};\nexport const getSectionValueText = (section, utils) => {\n  if (!section.value) {\n    return undefined;\n  }\n  switch (section.type) {\n    case 'month':\n      {\n        if (section.contentType === 'digit') {\n          return utils.format(utils.setMonth(utils.date(), Number(section.value) - 1), 'month');\n        }\n        const parsedDate = utils.parse(section.value, section.format);\n        return parsedDate ? utils.format(parsedDate, 'month') : undefined;\n      }\n    case 'day':\n      return section.contentType === 'digit' ? utils.format(utils.setDate(utils.startOfYear(utils.date()), Number(section.value)), 'dayOfMonthFull') : section.value;\n    case 'weekDay':\n      // TODO: improve by providing the label of the week day\n      return undefined;\n    default:\n      return undefined;\n  }\n};\nexport const getSectionValueNow = (section, utils) => {\n  if (!section.value) {\n    return undefined;\n  }\n  switch (section.type) {\n    case 'weekDay':\n      {\n        if (section.contentType === 'letter') {\n          // TODO: improve by resolving the week day number from a letter week day\n          return undefined;\n        }\n        return Number(section.value);\n      }\n    case 'meridiem':\n      {\n        const parsedDate = utils.parse(`01:00 ${section.value}`, `${utils.formats.hours12h}:${utils.formats.minutes} ${section.format}`);\n        if (parsedDate) {\n          return utils.getHours(parsedDate) >= 12 ? 1 : 0;\n        }\n        return undefined;\n      }\n    case 'day':\n      return section.contentType === 'digit-with-letter' ? parseInt(section.value, 10) : Number(section.value);\n    case 'month':\n      {\n        if (section.contentType === 'digit') {\n          return Number(section.value);\n        }\n        const parsedDate = utils.parse(section.value, section.format);\n        return parsedDate ? utils.getMonth(parsedDate) + 1 : undefined;\n      }\n    default:\n      return section.contentType !== 'letter' ? Number(section.value) : undefined;\n  }\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}