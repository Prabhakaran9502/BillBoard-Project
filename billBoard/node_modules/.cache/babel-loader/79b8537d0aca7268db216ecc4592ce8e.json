{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { DEFAULT_GRID_COL_TYPE_KEY, GRID_STRING_COL_DEF, getGridDefaultColumnTypes } from '../../../colDef';\nimport { gridColumnsStateSelector, gridColumnVisibilityModelSelector } from './gridColumnsSelector';\nimport { clamp } from '../../../utils/utils';\nimport { gridDensityFactorSelector } from '../density/densitySelector';\nimport { gridHeaderFilteringEnabledSelector } from '../headerFiltering/gridHeaderFilteringSelectors';\nimport { gridColumnGroupsHeaderMaxDepthSelector } from '../columnGrouping/gridColumnGroupsSelector';\nexport const COLUMNS_DIMENSION_PROPERTIES = ['maxWidth', 'minWidth', 'width', 'flex'];\nconst COLUMN_TYPES = getGridDefaultColumnTypes();\n/**\n * Computes width for flex columns.\n * Based on CSS Flexbox specification:\n * https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n */\n\nexport function computeFlexColumnsWidth(_ref) {\n  let {\n    initialFreeSpace,\n    totalFlexUnits,\n    flexColumns\n  } = _ref;\n  const uniqueFlexColumns = new Set(flexColumns.map(col => col.field));\n  const flexColumnsLookup = {\n    all: {},\n    frozenFields: [],\n    freeze: field => {\n      const value = flexColumnsLookup.all[field];\n\n      if (value && value.frozen !== true) {\n        flexColumnsLookup.all[field].frozen = true;\n        flexColumnsLookup.frozenFields.push(field);\n      }\n    }\n  }; // Step 5 of https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n\n  function loopOverFlexItems() {\n    // 5a: If all the flex items on the line are frozen, free space has been distributed.\n    if (flexColumnsLookup.frozenFields.length === uniqueFlexColumns.size) {\n      return;\n    }\n\n    const violationsLookup = {\n      min: {},\n      max: {}\n    };\n    let remainingFreeSpace = initialFreeSpace;\n    let flexUnits = totalFlexUnits;\n    let totalViolation = 0; // 5b: Calculate the remaining free space\n\n    flexColumnsLookup.frozenFields.forEach(field => {\n      remainingFreeSpace -= flexColumnsLookup.all[field].computedWidth;\n      flexUnits -= flexColumnsLookup.all[field].flex;\n    });\n\n    for (let i = 0; i < flexColumns.length; i += 1) {\n      const column = flexColumns[i];\n\n      if (flexColumnsLookup.all[column.field] && flexColumnsLookup.all[column.field].frozen === true) {\n        continue;\n      } // 5c: Distribute remaining free space proportional to the flex factors\n\n\n      const widthPerFlexUnit = remainingFreeSpace / flexUnits;\n      let computedWidth = widthPerFlexUnit * column.flex; // 5d: Fix min/max violations\n\n      if (computedWidth < column.minWidth) {\n        totalViolation += column.minWidth - computedWidth;\n        computedWidth = column.minWidth;\n        violationsLookup.min[column.field] = true;\n      } else if (computedWidth > column.maxWidth) {\n        totalViolation += column.maxWidth - computedWidth;\n        computedWidth = column.maxWidth;\n        violationsLookup.max[column.field] = true;\n      }\n\n      flexColumnsLookup.all[column.field] = {\n        frozen: false,\n        computedWidth,\n        flex: column.flex\n      };\n    } // 5e: Freeze over-flexed items\n\n\n    if (totalViolation < 0) {\n      // Freeze all the items with max violations\n      Object.keys(violationsLookup.max).forEach(field => {\n        flexColumnsLookup.freeze(field);\n      });\n    } else if (totalViolation > 0) {\n      // Freeze all the items with min violations\n      Object.keys(violationsLookup.min).forEach(field => {\n        flexColumnsLookup.freeze(field);\n      });\n    } else {\n      // Freeze all items\n      flexColumns.forEach(_ref2 => {\n        let {\n          field\n        } = _ref2;\n        flexColumnsLookup.freeze(field);\n      });\n    } // 5f: Return to the start of this loop\n\n\n    loopOverFlexItems();\n  }\n\n  loopOverFlexItems();\n  return flexColumnsLookup.all;\n}\n/**\n * Compute the `computedWidth` (ie: the width the column should have during rendering) based on the `width` / `flex` / `minWidth` / `maxWidth` properties of `GridColDef`.\n * The columns already have been merged with there `type` default values for `minWidth`, `maxWidth` and `width`, thus the `!` for those properties below.\n * TODO: Unit test this function in depth and only keep basic cases for the whole grid testing.\n * TODO: Improve the `GridColDef` typing to reflect the fact that `minWidth` / `maxWidth` and `width` can't be null after the merge with the `type` default values.\n */\n\nexport const hydrateColumnsWidth = (rawState, dimensions) => {\n  const columnsLookup = {};\n  let totalFlexUnits = 0;\n  let widthAllocatedBeforeFlex = 0;\n  const flexColumns = []; // For the non-flex columns, compute their width\n  // For the flex columns, compute their minimum width and how much width must be allocated during the flex allocation\n\n  rawState.orderedFields.forEach(columnField => {\n    let column = rawState.lookup[columnField];\n    let computedWidth = 0;\n    let isFlex = false;\n\n    if (rawState.columnVisibilityModel[columnField] !== false) {\n      if (column.flex && column.flex > 0) {\n        totalFlexUnits += column.flex;\n        isFlex = true;\n      } else {\n        computedWidth = clamp(column.width || GRID_STRING_COL_DEF.width, column.minWidth || GRID_STRING_COL_DEF.minWidth, column.maxWidth || GRID_STRING_COL_DEF.maxWidth);\n      }\n\n      widthAllocatedBeforeFlex += computedWidth;\n    }\n\n    if (column.computedWidth !== computedWidth) {\n      column = _extends({}, column, {\n        computedWidth\n      });\n    }\n\n    if (isFlex) {\n      flexColumns.push(column);\n    }\n\n    columnsLookup[columnField] = column;\n  });\n  const availableWidth = dimensions === undefined ? 0 : dimensions.viewportOuterSize.width - (dimensions.hasScrollY ? dimensions.scrollbarSize : 0);\n  const initialFreeSpace = Math.max(availableWidth - widthAllocatedBeforeFlex, 0); // Allocate the remaining space to the flex columns\n\n  if (totalFlexUnits > 0 && availableWidth > 0) {\n    const computedColumnWidths = computeFlexColumnsWidth({\n      initialFreeSpace,\n      totalFlexUnits,\n      flexColumns\n    });\n    Object.keys(computedColumnWidths).forEach(field => {\n      columnsLookup[field].computedWidth = computedColumnWidths[field].computedWidth;\n    });\n  }\n\n  return _extends({}, rawState, {\n    lookup: columnsLookup\n  });\n};\n/**\n * Apply the order and the dimensions of the initial state.\n * The columns not registered in `orderedFields` will be placed after the imported columns.\n */\n\nexport const applyInitialState = (columnsState, initialState) => {\n  if (!initialState) {\n    return columnsState;\n  }\n\n  const {\n    orderedFields = [],\n    dimensions = {}\n  } = initialState;\n  const columnsWithUpdatedDimensions = Object.keys(dimensions);\n\n  if (columnsWithUpdatedDimensions.length === 0 && orderedFields.length === 0) {\n    return columnsState;\n  }\n\n  const orderedFieldsLookup = {};\n  const cleanOrderedFields = [];\n\n  for (let i = 0; i < orderedFields.length; i += 1) {\n    const field = orderedFields[i]; // Ignores the fields in the initialState that matches no field on the current column state\n\n    if (columnsState.lookup[field]) {\n      orderedFieldsLookup[field] = true;\n      cleanOrderedFields.push(field);\n    }\n  }\n\n  const newOrderedFields = cleanOrderedFields.length === 0 ? columnsState.orderedFields : [...cleanOrderedFields, ...columnsState.orderedFields.filter(field => !orderedFieldsLookup[field])];\n\n  const newColumnLookup = _extends({}, columnsState.lookup);\n\n  for (let i = 0; i < columnsWithUpdatedDimensions.length; i += 1) {\n    const field = columnsWithUpdatedDimensions[i];\n\n    const newColDef = _extends({}, newColumnLookup[field], {\n      hasBeenResized: true\n    });\n\n    Object.entries(dimensions[field]).forEach(_ref3 => {\n      let [key, value] = _ref3;\n      newColDef[key] = value === -1 ? Infinity : value;\n    });\n    newColumnLookup[field] = newColDef;\n  }\n\n  const newColumnsState = _extends({}, columnsState, {\n    orderedFields: newOrderedFields,\n    lookup: newColumnLookup\n  });\n\n  return newColumnsState;\n};\n\nfunction getDefaultColTypeDef(type) {\n  let colDef = COLUMN_TYPES[DEFAULT_GRID_COL_TYPE_KEY];\n\n  if (type && COLUMN_TYPES[type]) {\n    colDef = COLUMN_TYPES[type];\n  }\n\n  return colDef;\n}\n\nexport const createColumnsState = _ref4 => {\n  let {\n    apiRef,\n    columnsToUpsert,\n    initialState,\n    columnVisibilityModel = gridColumnVisibilityModelSelector(apiRef),\n    keepOnlyColumnsToUpsert = false\n  } = _ref4;\n  const isInsideStateInitializer = !apiRef.current.state.columns;\n  let columnsState;\n\n  if (isInsideStateInitializer) {\n    columnsState = {\n      orderedFields: [],\n      lookup: {},\n      columnVisibilityModel\n    };\n  } else {\n    const currentState = gridColumnsStateSelector(apiRef.current.state);\n    columnsState = {\n      orderedFields: keepOnlyColumnsToUpsert ? [] : [...currentState.orderedFields],\n      lookup: _extends({}, currentState.lookup),\n      // Will be cleaned later if keepOnlyColumnsToUpsert=true\n      columnVisibilityModel\n    };\n  }\n\n  let columnsToKeep = {};\n\n  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {\n    columnsToKeep = Object.keys(columnsState.lookup).reduce((acc, key) => _extends({}, acc, {\n      [key]: false\n    }), {});\n  }\n\n  const columnsToUpsertLookup = {};\n  columnsToUpsert.forEach(newColumn => {\n    const {\n      field\n    } = newColumn;\n    columnsToUpsertLookup[field] = true;\n    columnsToKeep[field] = true;\n    let existingState = columnsState.lookup[field];\n\n    if (existingState == null) {\n      existingState = _extends({}, getDefaultColTypeDef(newColumn.type), {\n        field,\n        hasBeenResized: false\n      });\n      columnsState.orderedFields.push(field);\n    } else if (keepOnlyColumnsToUpsert) {\n      columnsState.orderedFields.push(field);\n    } // If the column type has changed - merge the existing state with the default column type definition\n\n\n    if (existingState && existingState.type !== newColumn.type) {\n      existingState = _extends({}, getDefaultColTypeDef(newColumn.type), {\n        field\n      });\n    }\n\n    let hasBeenResized = existingState.hasBeenResized;\n    COLUMNS_DIMENSION_PROPERTIES.forEach(key => {\n      if (newColumn[key] !== undefined) {\n        hasBeenResized = true;\n\n        if (newColumn[key] === -1) {\n          newColumn[key] = Infinity;\n        }\n      }\n    });\n    columnsState.lookup[field] = _extends({}, existingState, newColumn, {\n      hasBeenResized\n    });\n  });\n\n  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {\n    Object.keys(columnsState.lookup).forEach(field => {\n      if (!columnsToKeep[field]) {\n        delete columnsState.lookup[field];\n      }\n    });\n  }\n\n  const columnsStateWithPreProcessing = apiRef.current.unstable_applyPipeProcessors('hydrateColumns', columnsState);\n  const columnsStateWithPortableColumns = applyInitialState(columnsStateWithPreProcessing, initialState);\n  return hydrateColumnsWidth(columnsStateWithPortableColumns, apiRef.current.getRootDimensions?.() ?? undefined);\n};\nexport function getFirstNonSpannedColumnToRender(_ref5) {\n  let {\n    firstColumnToRender,\n    apiRef,\n    firstRowToRender,\n    lastRowToRender,\n    visibleRows\n  } = _ref5;\n  let firstNonSpannedColumnToRender = firstColumnToRender;\n\n  for (let i = firstRowToRender; i < lastRowToRender; i += 1) {\n    const row = visibleRows[i];\n\n    if (row) {\n      const rowId = visibleRows[i].id;\n      const cellColSpanInfo = apiRef.current.unstable_getCellColSpanInfo(rowId, firstColumnToRender);\n\n      if (cellColSpanInfo && cellColSpanInfo.spannedByColSpan) {\n        firstNonSpannedColumnToRender = cellColSpanInfo.leftVisibleCellIndex;\n      }\n    }\n  }\n\n  return firstNonSpannedColumnToRender;\n}\nexport function getTotalHeaderHeight(apiRef, props) {\n  const densityFactor = gridDensityFactorSelector(apiRef);\n  const maxDepth = gridColumnGroupsHeaderMaxDepthSelector(apiRef);\n  const isHeaderFilteringEnabled = gridHeaderFilteringEnabledSelector(apiRef);\n  const columnHeadersHeight = Math.floor(props.columnHeaderHeight * densityFactor);\n  const filterHeadersHeight = isHeaderFilteringEnabled ? Math.floor((props.headerFilterHeight ?? props.columnHeaderHeight) * densityFactor) : 0;\n  return columnHeadersHeight * (1 + (maxDepth ?? 0)) + filterHeadersHeight;\n}","map":{"version":3,"names":["_extends","DEFAULT_GRID_COL_TYPE_KEY","GRID_STRING_COL_DEF","getGridDefaultColumnTypes","gridColumnsStateSelector","gridColumnVisibilityModelSelector","clamp","gridDensityFactorSelector","gridHeaderFilteringEnabledSelector","gridColumnGroupsHeaderMaxDepthSelector","COLUMNS_DIMENSION_PROPERTIES","COLUMN_TYPES","computeFlexColumnsWidth","initialFreeSpace","totalFlexUnits","flexColumns","uniqueFlexColumns","Set","map","col","field","flexColumnsLookup","all","frozenFields","freeze","value","frozen","push","loopOverFlexItems","length","size","violationsLookup","min","max","remainingFreeSpace","flexUnits","totalViolation","forEach","computedWidth","flex","i","column","widthPerFlexUnit","minWidth","maxWidth","Object","keys","hydrateColumnsWidth","rawState","dimensions","columnsLookup","widthAllocatedBeforeFlex","orderedFields","columnField","lookup","isFlex","columnVisibilityModel","width","availableWidth","undefined","viewportOuterSize","hasScrollY","scrollbarSize","Math","computedColumnWidths","applyInitialState","columnsState","initialState","columnsWithUpdatedDimensions","orderedFieldsLookup","cleanOrderedFields","newOrderedFields","filter","newColumnLookup","newColDef","hasBeenResized","entries","key","Infinity","newColumnsState","getDefaultColTypeDef","type","colDef","createColumnsState","apiRef","columnsToUpsert","keepOnlyColumnsToUpsert","isInsideStateInitializer","current","state","columns","currentState","columnsToKeep","reduce","acc","columnsToUpsertLookup","newColumn","existingState","columnsStateWithPreProcessing","unstable_applyPipeProcessors","columnsStateWithPortableColumns","getRootDimensions","getFirstNonSpannedColumnToRender","firstColumnToRender","firstRowToRender","lastRowToRender","visibleRows","firstNonSpannedColumnToRender","row","rowId","id","cellColSpanInfo","unstable_getCellColSpanInfo","spannedByColSpan","leftVisibleCellIndex","getTotalHeaderHeight","props","densityFactor","maxDepth","isHeaderFilteringEnabled","columnHeadersHeight","floor","columnHeaderHeight","filterHeadersHeight","headerFilterHeight"],"sources":["C:/Users/kb/Downloads/billBoard/billboard/node_modules/@mui/x-data-grid/hooks/features/columns/gridColumnsUtils.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { DEFAULT_GRID_COL_TYPE_KEY, GRID_STRING_COL_DEF, getGridDefaultColumnTypes } from '../../../colDef';\nimport { gridColumnsStateSelector, gridColumnVisibilityModelSelector } from './gridColumnsSelector';\nimport { clamp } from '../../../utils/utils';\nimport { gridDensityFactorSelector } from '../density/densitySelector';\nimport { gridHeaderFilteringEnabledSelector } from '../headerFiltering/gridHeaderFilteringSelectors';\nimport { gridColumnGroupsHeaderMaxDepthSelector } from '../columnGrouping/gridColumnGroupsSelector';\nexport const COLUMNS_DIMENSION_PROPERTIES = ['maxWidth', 'minWidth', 'width', 'flex'];\nconst COLUMN_TYPES = getGridDefaultColumnTypes();\n\n/**\n * Computes width for flex columns.\n * Based on CSS Flexbox specification:\n * https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n */\nexport function computeFlexColumnsWidth({\n  initialFreeSpace,\n  totalFlexUnits,\n  flexColumns\n}) {\n  const uniqueFlexColumns = new Set(flexColumns.map(col => col.field));\n  const flexColumnsLookup = {\n    all: {},\n    frozenFields: [],\n    freeze: field => {\n      const value = flexColumnsLookup.all[field];\n      if (value && value.frozen !== true) {\n        flexColumnsLookup.all[field].frozen = true;\n        flexColumnsLookup.frozenFields.push(field);\n      }\n    }\n  };\n\n  // Step 5 of https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n  function loopOverFlexItems() {\n    // 5a: If all the flex items on the line are frozen, free space has been distributed.\n    if (flexColumnsLookup.frozenFields.length === uniqueFlexColumns.size) {\n      return;\n    }\n    const violationsLookup = {\n      min: {},\n      max: {}\n    };\n    let remainingFreeSpace = initialFreeSpace;\n    let flexUnits = totalFlexUnits;\n    let totalViolation = 0;\n\n    // 5b: Calculate the remaining free space\n    flexColumnsLookup.frozenFields.forEach(field => {\n      remainingFreeSpace -= flexColumnsLookup.all[field].computedWidth;\n      flexUnits -= flexColumnsLookup.all[field].flex;\n    });\n    for (let i = 0; i < flexColumns.length; i += 1) {\n      const column = flexColumns[i];\n      if (flexColumnsLookup.all[column.field] && flexColumnsLookup.all[column.field].frozen === true) {\n        continue;\n      }\n\n      // 5c: Distribute remaining free space proportional to the flex factors\n      const widthPerFlexUnit = remainingFreeSpace / flexUnits;\n      let computedWidth = widthPerFlexUnit * column.flex;\n\n      // 5d: Fix min/max violations\n      if (computedWidth < column.minWidth) {\n        totalViolation += column.minWidth - computedWidth;\n        computedWidth = column.minWidth;\n        violationsLookup.min[column.field] = true;\n      } else if (computedWidth > column.maxWidth) {\n        totalViolation += column.maxWidth - computedWidth;\n        computedWidth = column.maxWidth;\n        violationsLookup.max[column.field] = true;\n      }\n      flexColumnsLookup.all[column.field] = {\n        frozen: false,\n        computedWidth,\n        flex: column.flex\n      };\n    }\n\n    // 5e: Freeze over-flexed items\n    if (totalViolation < 0) {\n      // Freeze all the items with max violations\n      Object.keys(violationsLookup.max).forEach(field => {\n        flexColumnsLookup.freeze(field);\n      });\n    } else if (totalViolation > 0) {\n      // Freeze all the items with min violations\n      Object.keys(violationsLookup.min).forEach(field => {\n        flexColumnsLookup.freeze(field);\n      });\n    } else {\n      // Freeze all items\n      flexColumns.forEach(({\n        field\n      }) => {\n        flexColumnsLookup.freeze(field);\n      });\n    }\n\n    // 5f: Return to the start of this loop\n    loopOverFlexItems();\n  }\n  loopOverFlexItems();\n  return flexColumnsLookup.all;\n}\n\n/**\n * Compute the `computedWidth` (ie: the width the column should have during rendering) based on the `width` / `flex` / `minWidth` / `maxWidth` properties of `GridColDef`.\n * The columns already have been merged with there `type` default values for `minWidth`, `maxWidth` and `width`, thus the `!` for those properties below.\n * TODO: Unit test this function in depth and only keep basic cases for the whole grid testing.\n * TODO: Improve the `GridColDef` typing to reflect the fact that `minWidth` / `maxWidth` and `width` can't be null after the merge with the `type` default values.\n */\nexport const hydrateColumnsWidth = (rawState, dimensions) => {\n  const columnsLookup = {};\n  let totalFlexUnits = 0;\n  let widthAllocatedBeforeFlex = 0;\n  const flexColumns = [];\n\n  // For the non-flex columns, compute their width\n  // For the flex columns, compute their minimum width and how much width must be allocated during the flex allocation\n  rawState.orderedFields.forEach(columnField => {\n    let column = rawState.lookup[columnField];\n    let computedWidth = 0;\n    let isFlex = false;\n    if (rawState.columnVisibilityModel[columnField] !== false) {\n      if (column.flex && column.flex > 0) {\n        totalFlexUnits += column.flex;\n        isFlex = true;\n      } else {\n        computedWidth = clamp(column.width || GRID_STRING_COL_DEF.width, column.minWidth || GRID_STRING_COL_DEF.minWidth, column.maxWidth || GRID_STRING_COL_DEF.maxWidth);\n      }\n      widthAllocatedBeforeFlex += computedWidth;\n    }\n    if (column.computedWidth !== computedWidth) {\n      column = _extends({}, column, {\n        computedWidth\n      });\n    }\n    if (isFlex) {\n      flexColumns.push(column);\n    }\n    columnsLookup[columnField] = column;\n  });\n  const availableWidth = dimensions === undefined ? 0 : dimensions.viewportOuterSize.width - (dimensions.hasScrollY ? dimensions.scrollbarSize : 0);\n  const initialFreeSpace = Math.max(availableWidth - widthAllocatedBeforeFlex, 0);\n\n  // Allocate the remaining space to the flex columns\n  if (totalFlexUnits > 0 && availableWidth > 0) {\n    const computedColumnWidths = computeFlexColumnsWidth({\n      initialFreeSpace,\n      totalFlexUnits,\n      flexColumns\n    });\n    Object.keys(computedColumnWidths).forEach(field => {\n      columnsLookup[field].computedWidth = computedColumnWidths[field].computedWidth;\n    });\n  }\n  return _extends({}, rawState, {\n    lookup: columnsLookup\n  });\n};\n\n/**\n * Apply the order and the dimensions of the initial state.\n * The columns not registered in `orderedFields` will be placed after the imported columns.\n */\nexport const applyInitialState = (columnsState, initialState) => {\n  if (!initialState) {\n    return columnsState;\n  }\n  const {\n    orderedFields = [],\n    dimensions = {}\n  } = initialState;\n  const columnsWithUpdatedDimensions = Object.keys(dimensions);\n  if (columnsWithUpdatedDimensions.length === 0 && orderedFields.length === 0) {\n    return columnsState;\n  }\n  const orderedFieldsLookup = {};\n  const cleanOrderedFields = [];\n  for (let i = 0; i < orderedFields.length; i += 1) {\n    const field = orderedFields[i];\n\n    // Ignores the fields in the initialState that matches no field on the current column state\n    if (columnsState.lookup[field]) {\n      orderedFieldsLookup[field] = true;\n      cleanOrderedFields.push(field);\n    }\n  }\n  const newOrderedFields = cleanOrderedFields.length === 0 ? columnsState.orderedFields : [...cleanOrderedFields, ...columnsState.orderedFields.filter(field => !orderedFieldsLookup[field])];\n  const newColumnLookup = _extends({}, columnsState.lookup);\n  for (let i = 0; i < columnsWithUpdatedDimensions.length; i += 1) {\n    const field = columnsWithUpdatedDimensions[i];\n    const newColDef = _extends({}, newColumnLookup[field], {\n      hasBeenResized: true\n    });\n    Object.entries(dimensions[field]).forEach(([key, value]) => {\n      newColDef[key] = value === -1 ? Infinity : value;\n    });\n    newColumnLookup[field] = newColDef;\n  }\n  const newColumnsState = _extends({}, columnsState, {\n    orderedFields: newOrderedFields,\n    lookup: newColumnLookup\n  });\n  return newColumnsState;\n};\nfunction getDefaultColTypeDef(type) {\n  let colDef = COLUMN_TYPES[DEFAULT_GRID_COL_TYPE_KEY];\n  if (type && COLUMN_TYPES[type]) {\n    colDef = COLUMN_TYPES[type];\n  }\n  return colDef;\n}\nexport const createColumnsState = ({\n  apiRef,\n  columnsToUpsert,\n  initialState,\n  columnVisibilityModel = gridColumnVisibilityModelSelector(apiRef),\n  keepOnlyColumnsToUpsert = false\n}) => {\n  const isInsideStateInitializer = !apiRef.current.state.columns;\n  let columnsState;\n  if (isInsideStateInitializer) {\n    columnsState = {\n      orderedFields: [],\n      lookup: {},\n      columnVisibilityModel\n    };\n  } else {\n    const currentState = gridColumnsStateSelector(apiRef.current.state);\n    columnsState = {\n      orderedFields: keepOnlyColumnsToUpsert ? [] : [...currentState.orderedFields],\n      lookup: _extends({}, currentState.lookup),\n      // Will be cleaned later if keepOnlyColumnsToUpsert=true\n      columnVisibilityModel\n    };\n  }\n  let columnsToKeep = {};\n  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {\n    columnsToKeep = Object.keys(columnsState.lookup).reduce((acc, key) => _extends({}, acc, {\n      [key]: false\n    }), {});\n  }\n  const columnsToUpsertLookup = {};\n  columnsToUpsert.forEach(newColumn => {\n    const {\n      field\n    } = newColumn;\n    columnsToUpsertLookup[field] = true;\n    columnsToKeep[field] = true;\n    let existingState = columnsState.lookup[field];\n    if (existingState == null) {\n      existingState = _extends({}, getDefaultColTypeDef(newColumn.type), {\n        field,\n        hasBeenResized: false\n      });\n      columnsState.orderedFields.push(field);\n    } else if (keepOnlyColumnsToUpsert) {\n      columnsState.orderedFields.push(field);\n    }\n\n    // If the column type has changed - merge the existing state with the default column type definition\n    if (existingState && existingState.type !== newColumn.type) {\n      existingState = _extends({}, getDefaultColTypeDef(newColumn.type), {\n        field\n      });\n    }\n    let hasBeenResized = existingState.hasBeenResized;\n    COLUMNS_DIMENSION_PROPERTIES.forEach(key => {\n      if (newColumn[key] !== undefined) {\n        hasBeenResized = true;\n        if (newColumn[key] === -1) {\n          newColumn[key] = Infinity;\n        }\n      }\n    });\n    columnsState.lookup[field] = _extends({}, existingState, newColumn, {\n      hasBeenResized\n    });\n  });\n  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {\n    Object.keys(columnsState.lookup).forEach(field => {\n      if (!columnsToKeep[field]) {\n        delete columnsState.lookup[field];\n      }\n    });\n  }\n  const columnsStateWithPreProcessing = apiRef.current.unstable_applyPipeProcessors('hydrateColumns', columnsState);\n  const columnsStateWithPortableColumns = applyInitialState(columnsStateWithPreProcessing, initialState);\n  return hydrateColumnsWidth(columnsStateWithPortableColumns, apiRef.current.getRootDimensions?.() ?? undefined);\n};\nexport function getFirstNonSpannedColumnToRender({\n  firstColumnToRender,\n  apiRef,\n  firstRowToRender,\n  lastRowToRender,\n  visibleRows\n}) {\n  let firstNonSpannedColumnToRender = firstColumnToRender;\n  for (let i = firstRowToRender; i < lastRowToRender; i += 1) {\n    const row = visibleRows[i];\n    if (row) {\n      const rowId = visibleRows[i].id;\n      const cellColSpanInfo = apiRef.current.unstable_getCellColSpanInfo(rowId, firstColumnToRender);\n      if (cellColSpanInfo && cellColSpanInfo.spannedByColSpan) {\n        firstNonSpannedColumnToRender = cellColSpanInfo.leftVisibleCellIndex;\n      }\n    }\n  }\n  return firstNonSpannedColumnToRender;\n}\nexport function getTotalHeaderHeight(apiRef, props) {\n  const densityFactor = gridDensityFactorSelector(apiRef);\n  const maxDepth = gridColumnGroupsHeaderMaxDepthSelector(apiRef);\n  const isHeaderFilteringEnabled = gridHeaderFilteringEnabledSelector(apiRef);\n  const columnHeadersHeight = Math.floor(props.columnHeaderHeight * densityFactor);\n  const filterHeadersHeight = isHeaderFilteringEnabled ? Math.floor((props.headerFilterHeight ?? props.columnHeaderHeight) * densityFactor) : 0;\n  return columnHeadersHeight * (1 + (maxDepth ?? 0)) + filterHeadersHeight;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}