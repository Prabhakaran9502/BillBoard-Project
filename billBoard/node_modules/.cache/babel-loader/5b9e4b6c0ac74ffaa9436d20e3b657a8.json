{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setStrategyAvailability = exports.mergeStateWithRowGroupingModel = exports.isGroupingColumn = exports.getRowGroupingFieldFromGroupingCriteria = exports.getRowGroupingCriteriaFromGroupingField = exports.getGroupingRules = exports.getColDefOverrides = exports.getCellGroupingCriteria = exports.filterRowTreeFromGroupingColumns = exports.areGroupingRulesEqual = exports.ROW_GROUPING_STRATEGY = exports.GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _internals = require(\"@mui/x-data-grid-pro/internals\");\n\nvar _gridRowGroupingSelector = require(\"./gridRowGroupingSelector\");\n\nconst GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD = exports.GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD = '__row_group_by_columns_group__';\nconst ROW_GROUPING_STRATEGY = exports.ROW_GROUPING_STRATEGY = 'grouping-columns';\n\nconst getRowGroupingFieldFromGroupingCriteria = groupingCriteria => {\n  if (groupingCriteria === null) {\n    return GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD;\n  }\n\n  return `__row_group_by_columns_group_${groupingCriteria}__`;\n};\n\nexports.getRowGroupingFieldFromGroupingCriteria = getRowGroupingFieldFromGroupingCriteria;\n\nconst getRowGroupingCriteriaFromGroupingField = groupingColDefField => {\n  const match = groupingColDefField.match(/^__row_group_by_columns_group_(.*)__$/);\n\n  if (!match) {\n    return null;\n  }\n\n  return match[1];\n};\n\nexports.getRowGroupingCriteriaFromGroupingField = getRowGroupingCriteriaFromGroupingField;\n\nconst isGroupingColumn = field => field === GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD || getRowGroupingCriteriaFromGroupingField(field) !== null;\n\nexports.isGroupingColumn = isGroupingColumn;\n/**\n * When filtering a group, we only want to filter according to the items related to this grouping column.\n */\n\nconst shouldApplyFilterItemOnGroup = (columnField, node) => {\n  if (columnField === GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD) {\n    return true;\n  }\n\n  const groupingCriteriaField = getRowGroupingCriteriaFromGroupingField(columnField);\n  return groupingCriteriaField === node.groupingField;\n};\n/**\n * A leaf is visible if it passed the filter\n * A group is visible if all the following criteria are met:\n * - One of its children is passing the filter\n * - It is passing the filter\n */\n\n\nconst filterRowTreeFromGroupingColumns = params => {\n  const {\n    apiRef,\n    rowTree,\n    isRowMatchingFilters,\n    filterModel\n  } = params;\n  const filteredRowsLookup = {};\n  const filteredDescendantCountLookup = {};\n  const filterCache = {};\n\n  const filterTreeNode = (node, areAncestorsExpanded, ancestorsResults) => {\n    const filterResults = {\n      passingFilterItems: null,\n      passingQuickFilterValues: null\n    };\n    let isPassingFiltering = false;\n\n    if (isRowMatchingFilters && node.type !== 'footer') {\n      const shouldApplyItem = node.type === 'group' && node.isAutoGenerated ? columnField => shouldApplyFilterItemOnGroup(columnField, node) : undefined;\n      const row = apiRef.current.getRow(node.id);\n      isRowMatchingFilters(row, shouldApplyItem, filterResults);\n    } else {\n      isPassingFiltering = true;\n    }\n\n    let filteredDescendantCount = 0;\n\n    if (node.type === 'group') {\n      node.children.forEach(childId => {\n        const childNode = rowTree[childId];\n        const childSubTreeSize = filterTreeNode(childNode, areAncestorsExpanded && !!node.childrenExpanded, [...ancestorsResults, filterResults]);\n        filteredDescendantCount += childSubTreeSize;\n      });\n    }\n\n    if (isPassingFiltering === false) {\n      if (node.type === 'group') {\n        // If node has children - it's passing if at least one child passes filters\n        isPassingFiltering = filteredDescendantCount > 0;\n      } else {\n        const allResults = [...ancestorsResults, filterResults];\n        isPassingFiltering = (0, _internals.passFilterLogic)(allResults.map(result => result.passingFilterItems), allResults.map(result => result.passingQuickFilterValues), filterModel, params.apiRef, filterCache);\n      }\n    }\n\n    filteredRowsLookup[node.id] = isPassingFiltering;\n\n    if (!isPassingFiltering) {\n      return 0;\n    }\n\n    filteredDescendantCountLookup[node.id] = filteredDescendantCount;\n\n    if (node.type !== 'group') {\n      return filteredDescendantCount + 1;\n    }\n\n    return filteredDescendantCount;\n  };\n\n  const nodes = Object.values(rowTree);\n\n  for (let i = 0; i < nodes.length; i += 1) {\n    const node = nodes[i];\n\n    if (node.depth === 0) {\n      filterTreeNode(node, true, []);\n    }\n  }\n\n  return {\n    filteredRowsLookup,\n    filteredDescendantCountLookup\n  };\n};\n\nexports.filterRowTreeFromGroupingColumns = filterRowTreeFromGroupingColumns;\n\nconst getColDefOverrides = (groupingColDefProp, fields) => {\n  if (typeof groupingColDefProp === 'function') {\n    return groupingColDefProp({\n      groupingName: ROW_GROUPING_STRATEGY,\n      fields\n    });\n  }\n\n  return groupingColDefProp;\n};\n\nexports.getColDefOverrides = getColDefOverrides;\n\nconst mergeStateWithRowGroupingModel = rowGroupingModel => state => (0, _extends2.default)({}, state, {\n  rowGrouping: (0, _extends2.default)({}, state.rowGrouping, {\n    model: rowGroupingModel\n  })\n});\n\nexports.mergeStateWithRowGroupingModel = mergeStateWithRowGroupingModel;\n\nconst setStrategyAvailability = (privateApiRef, disableRowGrouping) => {\n  let isAvailable;\n\n  if (disableRowGrouping) {\n    isAvailable = () => false;\n  } else {\n    isAvailable = () => {\n      const rowGroupingSanitizedModel = (0, _gridRowGroupingSelector.gridRowGroupingSanitizedModelSelector)(privateApiRef);\n      return rowGroupingSanitizedModel.length > 0;\n    };\n  }\n\n  privateApiRef.current.setStrategyAvailability('rowTree', ROW_GROUPING_STRATEGY, isAvailable);\n};\n\nexports.setStrategyAvailability = setStrategyAvailability;\n\nconst getCellGroupingCriteria = _ref => {\n  let {\n    row,\n    colDef,\n    groupingRule,\n    apiRef\n  } = _ref;\n  let key;\n\n  if (groupingRule.groupingValueGetter) {\n    key = groupingRule.groupingValueGetter(row[groupingRule.field], row, colDef, apiRef);\n  } else {\n    key = row[groupingRule.field];\n  }\n\n  return {\n    key,\n    field: groupingRule.field\n  };\n};\n\nexports.getCellGroupingCriteria = getCellGroupingCriteria;\n\nconst getGroupingRules = _ref2 => {\n  let {\n    sanitizedRowGroupingModel,\n    columnsLookup\n  } = _ref2;\n  return sanitizedRowGroupingModel.map(field => ({\n    field,\n    groupingValueGetter: columnsLookup[field]?.groupingValueGetter\n  }));\n};\n/**\n * Compares two sets of grouping rules to determine if they are equal or not.\n */\n\n\nexports.getGroupingRules = getGroupingRules;\n\nconst areGroupingRulesEqual = (newValue, previousValue) => {\n  if (previousValue.length !== newValue.length) {\n    return false;\n  }\n\n  return newValue.every((newRule, newRuleIndex) => {\n    const previousRule = previousValue[newRuleIndex];\n\n    if (previousRule.groupingValueGetter !== newRule.groupingValueGetter) {\n      return false;\n    }\n\n    if (previousRule.field !== newRule.field) {\n      return false;\n    }\n\n    return true;\n  });\n};\n\nexports.areGroupingRulesEqual = areGroupingRulesEqual;","map":{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","setStrategyAvailability","mergeStateWithRowGroupingModel","isGroupingColumn","getRowGroupingFieldFromGroupingCriteria","getRowGroupingCriteriaFromGroupingField","getGroupingRules","getColDefOverrides","getCellGroupingCriteria","filterRowTreeFromGroupingColumns","areGroupingRulesEqual","ROW_GROUPING_STRATEGY","GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD","_extends2","_internals","_gridRowGroupingSelector","groupingCriteria","groupingColDefField","match","field","shouldApplyFilterItemOnGroup","columnField","node","groupingCriteriaField","groupingField","params","apiRef","rowTree","isRowMatchingFilters","filterModel","filteredRowsLookup","filteredDescendantCountLookup","filterCache","filterTreeNode","areAncestorsExpanded","ancestorsResults","filterResults","passingFilterItems","passingQuickFilterValues","isPassingFiltering","type","shouldApplyItem","isAutoGenerated","undefined","row","current","getRow","id","filteredDescendantCount","children","forEach","childId","childNode","childSubTreeSize","childrenExpanded","allResults","passFilterLogic","map","result","nodes","values","i","length","depth","groupingColDefProp","fields","groupingName","rowGroupingModel","state","default","rowGrouping","model","privateApiRef","disableRowGrouping","isAvailable","rowGroupingSanitizedModel","gridRowGroupingSanitizedModelSelector","colDef","groupingRule","key","groupingValueGetter","sanitizedRowGroupingModel","columnsLookup","newValue","previousValue","every","newRule","newRuleIndex","previousRule"],"sources":["C:/Users/kb/node_modules/@mui/x-data-grid-premium/hooks/features/rowGrouping/gridRowGroupingUtils.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setStrategyAvailability = exports.mergeStateWithRowGroupingModel = exports.isGroupingColumn = exports.getRowGroupingFieldFromGroupingCriteria = exports.getRowGroupingCriteriaFromGroupingField = exports.getGroupingRules = exports.getColDefOverrides = exports.getCellGroupingCriteria = exports.filterRowTreeFromGroupingColumns = exports.areGroupingRulesEqual = exports.ROW_GROUPING_STRATEGY = exports.GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD = void 0;\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nvar _internals = require(\"@mui/x-data-grid-pro/internals\");\nvar _gridRowGroupingSelector = require(\"./gridRowGroupingSelector\");\nconst GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD = exports.GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD = '__row_group_by_columns_group__';\nconst ROW_GROUPING_STRATEGY = exports.ROW_GROUPING_STRATEGY = 'grouping-columns';\nconst getRowGroupingFieldFromGroupingCriteria = groupingCriteria => {\n  if (groupingCriteria === null) {\n    return GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD;\n  }\n  return `__row_group_by_columns_group_${groupingCriteria}__`;\n};\nexports.getRowGroupingFieldFromGroupingCriteria = getRowGroupingFieldFromGroupingCriteria;\nconst getRowGroupingCriteriaFromGroupingField = groupingColDefField => {\n  const match = groupingColDefField.match(/^__row_group_by_columns_group_(.*)__$/);\n  if (!match) {\n    return null;\n  }\n  return match[1];\n};\nexports.getRowGroupingCriteriaFromGroupingField = getRowGroupingCriteriaFromGroupingField;\nconst isGroupingColumn = field => field === GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD || getRowGroupingCriteriaFromGroupingField(field) !== null;\nexports.isGroupingColumn = isGroupingColumn;\n/**\n * When filtering a group, we only want to filter according to the items related to this grouping column.\n */\nconst shouldApplyFilterItemOnGroup = (columnField, node) => {\n  if (columnField === GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD) {\n    return true;\n  }\n  const groupingCriteriaField = getRowGroupingCriteriaFromGroupingField(columnField);\n  return groupingCriteriaField === node.groupingField;\n};\n\n/**\n * A leaf is visible if it passed the filter\n * A group is visible if all the following criteria are met:\n * - One of its children is passing the filter\n * - It is passing the filter\n */\nconst filterRowTreeFromGroupingColumns = params => {\n  const {\n    apiRef,\n    rowTree,\n    isRowMatchingFilters,\n    filterModel\n  } = params;\n  const filteredRowsLookup = {};\n  const filteredDescendantCountLookup = {};\n  const filterCache = {};\n  const filterTreeNode = (node, areAncestorsExpanded, ancestorsResults) => {\n    const filterResults = {\n      passingFilterItems: null,\n      passingQuickFilterValues: null\n    };\n    let isPassingFiltering = false;\n    if (isRowMatchingFilters && node.type !== 'footer') {\n      const shouldApplyItem = node.type === 'group' && node.isAutoGenerated ? columnField => shouldApplyFilterItemOnGroup(columnField, node) : undefined;\n      const row = apiRef.current.getRow(node.id);\n      isRowMatchingFilters(row, shouldApplyItem, filterResults);\n    } else {\n      isPassingFiltering = true;\n    }\n    let filteredDescendantCount = 0;\n    if (node.type === 'group') {\n      node.children.forEach(childId => {\n        const childNode = rowTree[childId];\n        const childSubTreeSize = filterTreeNode(childNode, areAncestorsExpanded && !!node.childrenExpanded, [...ancestorsResults, filterResults]);\n        filteredDescendantCount += childSubTreeSize;\n      });\n    }\n    if (isPassingFiltering === false) {\n      if (node.type === 'group') {\n        // If node has children - it's passing if at least one child passes filters\n        isPassingFiltering = filteredDescendantCount > 0;\n      } else {\n        const allResults = [...ancestorsResults, filterResults];\n        isPassingFiltering = (0, _internals.passFilterLogic)(allResults.map(result => result.passingFilterItems), allResults.map(result => result.passingQuickFilterValues), filterModel, params.apiRef, filterCache);\n      }\n    }\n    filteredRowsLookup[node.id] = isPassingFiltering;\n    if (!isPassingFiltering) {\n      return 0;\n    }\n    filteredDescendantCountLookup[node.id] = filteredDescendantCount;\n    if (node.type !== 'group') {\n      return filteredDescendantCount + 1;\n    }\n    return filteredDescendantCount;\n  };\n  const nodes = Object.values(rowTree);\n  for (let i = 0; i < nodes.length; i += 1) {\n    const node = nodes[i];\n    if (node.depth === 0) {\n      filterTreeNode(node, true, []);\n    }\n  }\n  return {\n    filteredRowsLookup,\n    filteredDescendantCountLookup\n  };\n};\nexports.filterRowTreeFromGroupingColumns = filterRowTreeFromGroupingColumns;\nconst getColDefOverrides = (groupingColDefProp, fields) => {\n  if (typeof groupingColDefProp === 'function') {\n    return groupingColDefProp({\n      groupingName: ROW_GROUPING_STRATEGY,\n      fields\n    });\n  }\n  return groupingColDefProp;\n};\nexports.getColDefOverrides = getColDefOverrides;\nconst mergeStateWithRowGroupingModel = rowGroupingModel => state => (0, _extends2.default)({}, state, {\n  rowGrouping: (0, _extends2.default)({}, state.rowGrouping, {\n    model: rowGroupingModel\n  })\n});\nexports.mergeStateWithRowGroupingModel = mergeStateWithRowGroupingModel;\nconst setStrategyAvailability = (privateApiRef, disableRowGrouping) => {\n  let isAvailable;\n  if (disableRowGrouping) {\n    isAvailable = () => false;\n  } else {\n    isAvailable = () => {\n      const rowGroupingSanitizedModel = (0, _gridRowGroupingSelector.gridRowGroupingSanitizedModelSelector)(privateApiRef);\n      return rowGroupingSanitizedModel.length > 0;\n    };\n  }\n  privateApiRef.current.setStrategyAvailability('rowTree', ROW_GROUPING_STRATEGY, isAvailable);\n};\nexports.setStrategyAvailability = setStrategyAvailability;\nconst getCellGroupingCriteria = ({\n  row,\n  colDef,\n  groupingRule,\n  apiRef\n}) => {\n  let key;\n  if (groupingRule.groupingValueGetter) {\n    key = groupingRule.groupingValueGetter(row[groupingRule.field], row, colDef, apiRef);\n  } else {\n    key = row[groupingRule.field];\n  }\n  return {\n    key,\n    field: groupingRule.field\n  };\n};\nexports.getCellGroupingCriteria = getCellGroupingCriteria;\nconst getGroupingRules = ({\n  sanitizedRowGroupingModel,\n  columnsLookup\n}) => sanitizedRowGroupingModel.map(field => ({\n  field,\n  groupingValueGetter: columnsLookup[field]?.groupingValueGetter\n}));\n\n/**\n * Compares two sets of grouping rules to determine if they are equal or not.\n */\nexports.getGroupingRules = getGroupingRules;\nconst areGroupingRulesEqual = (newValue, previousValue) => {\n  if (previousValue.length !== newValue.length) {\n    return false;\n  }\n  return newValue.every((newRule, newRuleIndex) => {\n    const previousRule = previousValue[newRuleIndex];\n    if (previousRule.groupingValueGetter !== newRule.groupingValueGetter) {\n      return false;\n    }\n    if (previousRule.field !== newRule.field) {\n      return false;\n    }\n    return true;\n  });\n};\nexports.areGroupingRulesEqual = areGroupingRulesEqual;"],"mappings":"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"},"metadata":{},"sourceType":"script"}