{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createGroupingColDefForOneGroupingCriteria = exports.createGroupingColDefForAllGroupingCriteria = void 0;\n\nvar _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutPropertiesLoose\"));\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _xDataGridPro = require(\"@mui/x-data-grid-pro\");\n\nvar _internals = require(\"@mui/x-data-grid-pro/internals\");\n\nvar _GridGroupingColumnFooterCell = require(\"../../../components/GridGroupingColumnFooterCell\");\n\nvar _GridGroupingCriteriaCell = require(\"../../../components/GridGroupingCriteriaCell\");\n\nvar _GridGroupingColumnLeafCell = require(\"../../../components/GridGroupingColumnLeafCell\");\n\nvar _gridRowGroupingUtils = require(\"./gridRowGroupingUtils\");\n\nvar _gridRowGroupingSelector = require(\"./gridRowGroupingSelector\");\n\nvar _jsxRuntime = require(\"react/jsx-runtime\");\n\nconst _excluded = [\"leafField\", \"mainGroupingCriteria\", \"hideDescendantCount\"],\n      _excluded2 = [\"leafField\", \"mainGroupingCriteria\", \"hideDescendantCount\"];\n\nfunction _getRequireWildcardCache(e) {\n  if (\"function\" != typeof WeakMap) return null;\n  var r = new WeakMap(),\n      t = new WeakMap();\n  return (_getRequireWildcardCache = function (e) {\n    return e ? t : r;\n  })(e);\n}\n\nfunction _interopRequireWildcard(e, r) {\n  if (!r && e && e.__esModule) return e;\n  if (null === e || \"object\" != typeof e && \"function\" != typeof e) return {\n    default: e\n  };\n\n  var t = _getRequireWildcardCache(r);\n\n  if (t && t.has(e)) return t.get(e);\n  var n = {\n    __proto__: null\n  },\n      a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) {\n    var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n    i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n  }\n\n  return n.default = e, t && t.set(e, n), n;\n}\n\nconst GROUPING_COL_DEF_DEFAULT_PROPERTIES = (0, _extends2.default)({}, _xDataGridPro.GRID_STRING_COL_DEF, {\n  type: 'custom',\n  disableReorder: true\n});\nconst GROUPING_COL_DEF_FORCED_PROPERTIES = {\n  editable: false,\n  groupable: false\n};\n/**\n * When sorting two cells with different grouping criteria, we consider that the cell with the grouping criteria coming first in the model should be displayed below.\n * This can occur when some rows don't have all the fields. In which case we want the rows with the missing field to be displayed above.\n * TODO: Make this index comparator depth invariant, the logic should not be inverted when sorting in the \"desc\" direction (but the current return format of `sortComparator` does not support this behavior).\n */\n\nconst groupingFieldIndexComparator = (v1, v2, cellParams1, cellParams2) => {\n  const model = (0, _gridRowGroupingSelector.gridRowGroupingSanitizedModelSelector)(cellParams1.api.state, cellParams1.api.instanceId);\n  const groupingField1 = cellParams1.rowNode.groupingField ?? null;\n  const groupingField2 = cellParams2.rowNode.groupingField ?? null;\n\n  if (groupingField1 === groupingField2) {\n    return 0;\n  }\n\n  if (groupingField1 == null) {\n    return -1;\n  }\n\n  if (groupingField2 == null) {\n    return 1;\n  }\n\n  if (model.indexOf(groupingField1) < model.indexOf(groupingField2)) {\n    return -1;\n  }\n\n  return 1;\n};\n\nconst getLeafProperties = leafColDef => ({\n  headerName: leafColDef.headerName ?? leafColDef.field,\n  sortable: leafColDef.sortable,\n  filterable: leafColDef.filterable,\n  valueOptions: (0, _internals.isSingleSelectColDef)(leafColDef) ? leafColDef.valueOptions : undefined,\n  filterOperators: leafColDef.filterOperators,\n  sortComparator: (v1, v2, cellParams1, cellParams2) => {\n    // We only want to sort the leaves\n    if (cellParams1.rowNode.type === 'leaf' && cellParams2.rowNode.type === 'leaf') {\n      return leafColDef.sortComparator(v1, v2, cellParams1, cellParams2);\n    }\n\n    return groupingFieldIndexComparator(v1, v2, cellParams1, cellParams2);\n  }\n});\n\nconst getGroupingCriteriaProperties = (groupedByColDef, applyHeaderName) => {\n  const properties = {\n    sortable: groupedByColDef.sortable,\n    filterable: groupedByColDef.filterable,\n    valueOptions: (0, _internals.isSingleSelectColDef)(groupedByColDef) ? groupedByColDef.valueOptions : undefined,\n    sortComparator: (v1, v2, cellParams1, cellParams2) => {\n      // We only want to sort the groups of the current grouping criteria\n      if (cellParams1.rowNode.type === 'group' && cellParams2.rowNode.type === 'group' && cellParams1.rowNode.groupingField === cellParams2.rowNode.groupingField) {\n        const colDef = cellParams1.api.getColumn(cellParams1.rowNode.groupingField);\n        return colDef.sortComparator(v1, v2, cellParams1, cellParams2);\n      }\n\n      return groupingFieldIndexComparator(v1, v2, cellParams1, cellParams2);\n    },\n    filterOperators: groupedByColDef.filterOperators\n  };\n\n  if (applyHeaderName) {\n    properties.headerName = groupedByColDef.headerName ?? groupedByColDef.field;\n  }\n\n  return properties;\n};\n/**\n * Creates the `GridColDef` for a grouping column that only takes care of a single grouping criteria\n */\n\n\nconst createGroupingColDefForOneGroupingCriteria = _ref3 => {\n  let {\n    columnsLookup,\n    groupedByColDef,\n    groupingCriteria,\n    colDefOverride\n  } = _ref3;\n\n  const _ref = colDefOverride ?? {},\n        {\n    leafField,\n    mainGroupingCriteria,\n    hideDescendantCount\n  } = _ref,\n        colDefOverrideProperties = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);\n\n  const leafColDef = leafField ? columnsLookup[leafField] : null; // The properties that do not depend on the presence of a `leafColDef` and that can be overridden by `colDefOverride`\n\n  const commonProperties = {\n    width: Math.max((groupedByColDef.width ?? _xDataGridPro.GRID_STRING_COL_DEF.width) + 40, leafColDef?.width ?? 0),\n    renderCell: params => {\n      // Render footer\n      if (params.rowNode.type === 'footer' || params.rowNode.type === 'pinnedRow') {\n        return /*#__PURE__*/(0, _jsxRuntime.jsx)(_GridGroupingColumnFooterCell.GridGroupingColumnFooterCell, (0, _extends2.default)({}, params));\n      } // Render leaves\n\n\n      if (params.rowNode.type === 'leaf') {\n        if (leafColDef) {\n          const leafParams = (0, _extends2.default)({}, params.api.getCellParams(params.id, leafField), {\n            api: params.api,\n            hasFocus: params.hasFocus\n          });\n\n          if (leafColDef.renderCell) {\n            return leafColDef.renderCell(leafParams);\n          }\n\n          return /*#__PURE__*/(0, _jsxRuntime.jsx)(_GridGroupingColumnLeafCell.GridGroupingColumnLeafCell, (0, _extends2.default)({}, leafParams));\n        }\n\n        return '';\n      } // Render current grouping criteria groups\n\n\n      if (params.rowNode.groupingField === groupingCriteria) {\n        return /*#__PURE__*/(0, _jsxRuntime.jsx)(_GridGroupingCriteriaCell.GridGroupingCriteriaCell, (0, _extends2.default)({}, params, {\n          hideDescendantCount: hideDescendantCount\n        }));\n      }\n\n      return '';\n    },\n    valueGetter: (value, row, column, apiRef) => {\n      const rowId = apiRef.current.getRowId(row);\n      const rowNode = apiRef.current.getRowNode(rowId);\n\n      if (!rowNode || rowNode.type === 'footer' || rowNode.type === 'pinnedRow') {\n        return undefined;\n      }\n\n      if (rowNode.type === 'leaf') {\n        if (leafColDef) {\n          return apiRef.current.getCellValue(rowId, leafField);\n        }\n\n        return undefined;\n      }\n\n      if (rowNode.groupingField === groupingCriteria) {\n        return rowNode.groupingKey;\n      }\n\n      return undefined;\n    }\n  }; // If we have a `mainGroupingCriteria` defined and matching the `groupingCriteria`\n  // Then we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `groupedByColDef`.\n  // It can be useful to define a `leafField` for leaves rendering but still use the grouping criteria for the sorting / filtering\n  //\n  // If we have a `leafField` defined and matching an existing column\n  // Then we apply the sorting / filtering on the leaves based on the properties of `leavesColDef`\n  //\n  // By default, we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `groupedColDef`.\n\n  let sourceProperties;\n\n  if (mainGroupingCriteria && mainGroupingCriteria === groupingCriteria) {\n    sourceProperties = getGroupingCriteriaProperties(groupedByColDef, true);\n  } else if (leafColDef) {\n    sourceProperties = getLeafProperties(leafColDef);\n  } else {\n    sourceProperties = getGroupingCriteriaProperties(groupedByColDef, true);\n  } // The properties that can't be overridden with `colDefOverride`\n\n\n  const forcedProperties = (0, _extends2.default)({\n    field: (0, _gridRowGroupingUtils.getRowGroupingFieldFromGroupingCriteria)(groupingCriteria)\n  }, GROUPING_COL_DEF_FORCED_PROPERTIES);\n  return (0, _extends2.default)({}, GROUPING_COL_DEF_DEFAULT_PROPERTIES, commonProperties, sourceProperties, colDefOverrideProperties, forcedProperties);\n};\n\nexports.createGroupingColDefForOneGroupingCriteria = createGroupingColDefForOneGroupingCriteria;\n/**\n * Creates the `GridColDef` for a grouping column that takes care of all the grouping criteria\n */\n\nconst createGroupingColDefForAllGroupingCriteria = _ref4 => {\n  let {\n    apiRef,\n    columnsLookup,\n    rowGroupingModel,\n    colDefOverride\n  } = _ref4;\n\n  const _ref2 = colDefOverride ?? {},\n        {\n    leafField,\n    mainGroupingCriteria,\n    hideDescendantCount\n  } = _ref2,\n        colDefOverrideProperties = (0, _objectWithoutPropertiesLoose2.default)(_ref2, _excluded2);\n\n  const leafColDef = leafField ? columnsLookup[leafField] : null; // The properties that do not depend on the presence of a `leafColDef` and that can be overridden by `colDefOverride`\n\n  const commonProperties = {\n    headerName: apiRef.current.getLocaleText('groupingColumnHeaderName'),\n    width: Math.max(...rowGroupingModel.map(field => (columnsLookup[field].width ?? _xDataGridPro.GRID_STRING_COL_DEF.width) + 40), leafColDef?.width ?? 0),\n    renderCell: params => {\n      // Render footer\n      if (params.rowNode.type === 'footer' || params.rowNode.type === 'pinnedRow') {\n        return /*#__PURE__*/(0, _jsxRuntime.jsx)(_GridGroupingColumnFooterCell.GridGroupingColumnFooterCell, (0, _extends2.default)({}, params));\n      } // Render the leaves\n\n\n      if (params.rowNode.type === 'leaf') {\n        if (leafColDef) {\n          const leafParams = (0, _extends2.default)({}, params.api.getCellParams(params.id, leafField), {\n            api: params.api,\n            hasFocus: params.hasFocus\n          });\n\n          if (leafColDef.renderCell) {\n            return leafColDef.renderCell(leafParams);\n          }\n\n          return /*#__PURE__*/(0, _jsxRuntime.jsx)(_GridGroupingColumnLeafCell.GridGroupingColumnLeafCell, (0, _extends2.default)({}, leafParams));\n        }\n\n        return '';\n      } // Render the groups\n\n\n      return /*#__PURE__*/(0, _jsxRuntime.jsx)(_GridGroupingCriteriaCell.GridGroupingCriteriaCell, (0, _extends2.default)({}, params, {\n        hideDescendantCount: hideDescendantCount\n      }));\n    },\n    valueGetter: (value, row) => {\n      const rowId = apiRef.current.getRowId(row);\n      const rowNode = apiRef.current.getRowNode(rowId);\n\n      if (!rowNode || rowNode.type === 'footer' || rowNode.type === 'pinnedRow') {\n        return undefined;\n      }\n\n      if (rowNode.type === 'leaf') {\n        if (leafColDef) {\n          return apiRef.current.getCellValue(rowId, leafField);\n        }\n\n        return undefined;\n      }\n\n      return rowNode.groupingKey;\n    }\n  }; // If we have a `mainGroupingCriteria` defined and matching one of the `orderedGroupedByFields`\n  // Then we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `columnsLookup[mainGroupingCriteria]`.\n  // It can be useful to use another grouping criteria than the top level one for the sorting / filtering\n  //\n  // If we have a `leafField` defined and matching an existing column\n  // Then we apply the sorting / filtering on the leaves based on the properties of `leavesColDef`\n  //\n  // By default, we apply the sorting / filtering on the groups of the top level grouping criteria based on the properties of `columnsLookup[orderedGroupedByFields[0]]`.\n\n  let sourceProperties;\n\n  if (mainGroupingCriteria && rowGroupingModel.includes(mainGroupingCriteria)) {\n    sourceProperties = getGroupingCriteriaProperties(columnsLookup[mainGroupingCriteria], true);\n  } else if (leafColDef) {\n    sourceProperties = getLeafProperties(leafColDef);\n  } else {\n    sourceProperties = getGroupingCriteriaProperties(columnsLookup[rowGroupingModel[0]], rowGroupingModel.length === 1);\n  } // The properties that can't be overridden with `colDefOverride`\n\n\n  const forcedProperties = (0, _extends2.default)({\n    field: _gridRowGroupingUtils.GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD\n  }, GROUPING_COL_DEF_FORCED_PROPERTIES);\n  return (0, _extends2.default)({}, GROUPING_COL_DEF_DEFAULT_PROPERTIES, commonProperties, sourceProperties, colDefOverrideProperties, forcedProperties);\n};\n\nexports.createGroupingColDefForAllGroupingCriteria = createGroupingColDefForAllGroupingCriteria;","map":{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","createGroupingColDefForOneGroupingCriteria","createGroupingColDefForAllGroupingCriteria","_objectWithoutPropertiesLoose2","_extends2","React","_interopRequireWildcard","_xDataGridPro","_internals","_GridGroupingColumnFooterCell","_GridGroupingCriteriaCell","_GridGroupingColumnLeafCell","_gridRowGroupingUtils","_gridRowGroupingSelector","_jsxRuntime","_excluded","_excluded2","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","GROUPING_COL_DEF_DEFAULT_PROPERTIES","GRID_STRING_COL_DEF","type","disableReorder","GROUPING_COL_DEF_FORCED_PROPERTIES","editable","groupable","groupingFieldIndexComparator","v1","v2","cellParams1","cellParams2","model","gridRowGroupingSanitizedModelSelector","api","state","instanceId","groupingField1","rowNode","groupingField","groupingField2","indexOf","getLeafProperties","leafColDef","headerName","field","sortable","filterable","valueOptions","isSingleSelectColDef","undefined","filterOperators","sortComparator","getGroupingCriteriaProperties","groupedByColDef","applyHeaderName","properties","colDef","getColumn","columnsLookup","groupingCriteria","colDefOverride","_ref","leafField","mainGroupingCriteria","hideDescendantCount","colDefOverrideProperties","commonProperties","width","Math","max","renderCell","params","jsx","GridGroupingColumnFooterCell","leafParams","getCellParams","id","hasFocus","GridGroupingColumnLeafCell","GridGroupingCriteriaCell","valueGetter","row","column","apiRef","rowId","current","getRowId","getRowNode","getCellValue","groupingKey","sourceProperties","forcedProperties","getRowGroupingFieldFromGroupingCriteria","rowGroupingModel","_ref2","getLocaleText","map","includes","length","GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD"],"sources":["C:/Users/kb/node_modules/@mui/x-data-grid-premium/hooks/features/rowGrouping/createGroupingColDef.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createGroupingColDefForOneGroupingCriteria = exports.createGroupingColDefForAllGroupingCriteria = void 0;\nvar _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutPropertiesLoose\"));\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _xDataGridPro = require(\"@mui/x-data-grid-pro\");\nvar _internals = require(\"@mui/x-data-grid-pro/internals\");\nvar _GridGroupingColumnFooterCell = require(\"../../../components/GridGroupingColumnFooterCell\");\nvar _GridGroupingCriteriaCell = require(\"../../../components/GridGroupingCriteriaCell\");\nvar _GridGroupingColumnLeafCell = require(\"../../../components/GridGroupingColumnLeafCell\");\nvar _gridRowGroupingUtils = require(\"./gridRowGroupingUtils\");\nvar _gridRowGroupingSelector = require(\"./gridRowGroupingSelector\");\nvar _jsxRuntime = require(\"react/jsx-runtime\");\nconst _excluded = [\"leafField\", \"mainGroupingCriteria\", \"hideDescendantCount\"],\n  _excluded2 = [\"leafField\", \"mainGroupingCriteria\", \"hideDescendantCount\"];\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\nconst GROUPING_COL_DEF_DEFAULT_PROPERTIES = (0, _extends2.default)({}, _xDataGridPro.GRID_STRING_COL_DEF, {\n  type: 'custom',\n  disableReorder: true\n});\nconst GROUPING_COL_DEF_FORCED_PROPERTIES = {\n  editable: false,\n  groupable: false\n};\n\n/**\n * When sorting two cells with different grouping criteria, we consider that the cell with the grouping criteria coming first in the model should be displayed below.\n * This can occur when some rows don't have all the fields. In which case we want the rows with the missing field to be displayed above.\n * TODO: Make this index comparator depth invariant, the logic should not be inverted when sorting in the \"desc\" direction (but the current return format of `sortComparator` does not support this behavior).\n */\nconst groupingFieldIndexComparator = (v1, v2, cellParams1, cellParams2) => {\n  const model = (0, _gridRowGroupingSelector.gridRowGroupingSanitizedModelSelector)(cellParams1.api.state, cellParams1.api.instanceId);\n  const groupingField1 = cellParams1.rowNode.groupingField ?? null;\n  const groupingField2 = cellParams2.rowNode.groupingField ?? null;\n  if (groupingField1 === groupingField2) {\n    return 0;\n  }\n  if (groupingField1 == null) {\n    return -1;\n  }\n  if (groupingField2 == null) {\n    return 1;\n  }\n  if (model.indexOf(groupingField1) < model.indexOf(groupingField2)) {\n    return -1;\n  }\n  return 1;\n};\nconst getLeafProperties = leafColDef => ({\n  headerName: leafColDef.headerName ?? leafColDef.field,\n  sortable: leafColDef.sortable,\n  filterable: leafColDef.filterable,\n  valueOptions: (0, _internals.isSingleSelectColDef)(leafColDef) ? leafColDef.valueOptions : undefined,\n  filterOperators: leafColDef.filterOperators,\n  sortComparator: (v1, v2, cellParams1, cellParams2) => {\n    // We only want to sort the leaves\n    if (cellParams1.rowNode.type === 'leaf' && cellParams2.rowNode.type === 'leaf') {\n      return leafColDef.sortComparator(v1, v2, cellParams1, cellParams2);\n    }\n    return groupingFieldIndexComparator(v1, v2, cellParams1, cellParams2);\n  }\n});\nconst getGroupingCriteriaProperties = (groupedByColDef, applyHeaderName) => {\n  const properties = {\n    sortable: groupedByColDef.sortable,\n    filterable: groupedByColDef.filterable,\n    valueOptions: (0, _internals.isSingleSelectColDef)(groupedByColDef) ? groupedByColDef.valueOptions : undefined,\n    sortComparator: (v1, v2, cellParams1, cellParams2) => {\n      // We only want to sort the groups of the current grouping criteria\n      if (cellParams1.rowNode.type === 'group' && cellParams2.rowNode.type === 'group' && cellParams1.rowNode.groupingField === cellParams2.rowNode.groupingField) {\n        const colDef = cellParams1.api.getColumn(cellParams1.rowNode.groupingField);\n        return colDef.sortComparator(v1, v2, cellParams1, cellParams2);\n      }\n      return groupingFieldIndexComparator(v1, v2, cellParams1, cellParams2);\n    },\n    filterOperators: groupedByColDef.filterOperators\n  };\n  if (applyHeaderName) {\n    properties.headerName = groupedByColDef.headerName ?? groupedByColDef.field;\n  }\n  return properties;\n};\n/**\n * Creates the `GridColDef` for a grouping column that only takes care of a single grouping criteria\n */\nconst createGroupingColDefForOneGroupingCriteria = ({\n  columnsLookup,\n  groupedByColDef,\n  groupingCriteria,\n  colDefOverride\n}) => {\n  const _ref = colDefOverride ?? {},\n    {\n      leafField,\n      mainGroupingCriteria,\n      hideDescendantCount\n    } = _ref,\n    colDefOverrideProperties = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);\n  const leafColDef = leafField ? columnsLookup[leafField] : null;\n\n  // The properties that do not depend on the presence of a `leafColDef` and that can be overridden by `colDefOverride`\n  const commonProperties = {\n    width: Math.max((groupedByColDef.width ?? _xDataGridPro.GRID_STRING_COL_DEF.width) + 40, leafColDef?.width ?? 0),\n    renderCell: params => {\n      // Render footer\n      if (params.rowNode.type === 'footer' || params.rowNode.type === 'pinnedRow') {\n        return /*#__PURE__*/(0, _jsxRuntime.jsx)(_GridGroupingColumnFooterCell.GridGroupingColumnFooterCell, (0, _extends2.default)({}, params));\n      }\n\n      // Render leaves\n      if (params.rowNode.type === 'leaf') {\n        if (leafColDef) {\n          const leafParams = (0, _extends2.default)({}, params.api.getCellParams(params.id, leafField), {\n            api: params.api,\n            hasFocus: params.hasFocus\n          });\n          if (leafColDef.renderCell) {\n            return leafColDef.renderCell(leafParams);\n          }\n          return /*#__PURE__*/(0, _jsxRuntime.jsx)(_GridGroupingColumnLeafCell.GridGroupingColumnLeafCell, (0, _extends2.default)({}, leafParams));\n        }\n        return '';\n      }\n\n      // Render current grouping criteria groups\n      if (params.rowNode.groupingField === groupingCriteria) {\n        return /*#__PURE__*/(0, _jsxRuntime.jsx)(_GridGroupingCriteriaCell.GridGroupingCriteriaCell, (0, _extends2.default)({}, params, {\n          hideDescendantCount: hideDescendantCount\n        }));\n      }\n      return '';\n    },\n    valueGetter: (value, row, column, apiRef) => {\n      const rowId = apiRef.current.getRowId(row);\n      const rowNode = apiRef.current.getRowNode(rowId);\n      if (!rowNode || rowNode.type === 'footer' || rowNode.type === 'pinnedRow') {\n        return undefined;\n      }\n      if (rowNode.type === 'leaf') {\n        if (leafColDef) {\n          return apiRef.current.getCellValue(rowId, leafField);\n        }\n        return undefined;\n      }\n      if (rowNode.groupingField === groupingCriteria) {\n        return rowNode.groupingKey;\n      }\n      return undefined;\n    }\n  };\n\n  // If we have a `mainGroupingCriteria` defined and matching the `groupingCriteria`\n  // Then we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `groupedByColDef`.\n  // It can be useful to define a `leafField` for leaves rendering but still use the grouping criteria for the sorting / filtering\n  //\n  // If we have a `leafField` defined and matching an existing column\n  // Then we apply the sorting / filtering on the leaves based on the properties of `leavesColDef`\n  //\n  // By default, we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `groupedColDef`.\n  let sourceProperties;\n  if (mainGroupingCriteria && mainGroupingCriteria === groupingCriteria) {\n    sourceProperties = getGroupingCriteriaProperties(groupedByColDef, true);\n  } else if (leafColDef) {\n    sourceProperties = getLeafProperties(leafColDef);\n  } else {\n    sourceProperties = getGroupingCriteriaProperties(groupedByColDef, true);\n  }\n\n  // The properties that can't be overridden with `colDefOverride`\n  const forcedProperties = (0, _extends2.default)({\n    field: (0, _gridRowGroupingUtils.getRowGroupingFieldFromGroupingCriteria)(groupingCriteria)\n  }, GROUPING_COL_DEF_FORCED_PROPERTIES);\n  return (0, _extends2.default)({}, GROUPING_COL_DEF_DEFAULT_PROPERTIES, commonProperties, sourceProperties, colDefOverrideProperties, forcedProperties);\n};\nexports.createGroupingColDefForOneGroupingCriteria = createGroupingColDefForOneGroupingCriteria;\n/**\n * Creates the `GridColDef` for a grouping column that takes care of all the grouping criteria\n */\nconst createGroupingColDefForAllGroupingCriteria = ({\n  apiRef,\n  columnsLookup,\n  rowGroupingModel,\n  colDefOverride\n}) => {\n  const _ref2 = colDefOverride ?? {},\n    {\n      leafField,\n      mainGroupingCriteria,\n      hideDescendantCount\n    } = _ref2,\n    colDefOverrideProperties = (0, _objectWithoutPropertiesLoose2.default)(_ref2, _excluded2);\n  const leafColDef = leafField ? columnsLookup[leafField] : null;\n\n  // The properties that do not depend on the presence of a `leafColDef` and that can be overridden by `colDefOverride`\n  const commonProperties = {\n    headerName: apiRef.current.getLocaleText('groupingColumnHeaderName'),\n    width: Math.max(...rowGroupingModel.map(field => (columnsLookup[field].width ?? _xDataGridPro.GRID_STRING_COL_DEF.width) + 40), leafColDef?.width ?? 0),\n    renderCell: params => {\n      // Render footer\n      if (params.rowNode.type === 'footer' || params.rowNode.type === 'pinnedRow') {\n        return /*#__PURE__*/(0, _jsxRuntime.jsx)(_GridGroupingColumnFooterCell.GridGroupingColumnFooterCell, (0, _extends2.default)({}, params));\n      }\n\n      // Render the leaves\n      if (params.rowNode.type === 'leaf') {\n        if (leafColDef) {\n          const leafParams = (0, _extends2.default)({}, params.api.getCellParams(params.id, leafField), {\n            api: params.api,\n            hasFocus: params.hasFocus\n          });\n          if (leafColDef.renderCell) {\n            return leafColDef.renderCell(leafParams);\n          }\n          return /*#__PURE__*/(0, _jsxRuntime.jsx)(_GridGroupingColumnLeafCell.GridGroupingColumnLeafCell, (0, _extends2.default)({}, leafParams));\n        }\n        return '';\n      }\n\n      // Render the groups\n      return /*#__PURE__*/(0, _jsxRuntime.jsx)(_GridGroupingCriteriaCell.GridGroupingCriteriaCell, (0, _extends2.default)({}, params, {\n        hideDescendantCount: hideDescendantCount\n      }));\n    },\n    valueGetter: (value, row) => {\n      const rowId = apiRef.current.getRowId(row);\n      const rowNode = apiRef.current.getRowNode(rowId);\n      if (!rowNode || rowNode.type === 'footer' || rowNode.type === 'pinnedRow') {\n        return undefined;\n      }\n      if (rowNode.type === 'leaf') {\n        if (leafColDef) {\n          return apiRef.current.getCellValue(rowId, leafField);\n        }\n        return undefined;\n      }\n      return rowNode.groupingKey;\n    }\n  };\n\n  // If we have a `mainGroupingCriteria` defined and matching one of the `orderedGroupedByFields`\n  // Then we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `columnsLookup[mainGroupingCriteria]`.\n  // It can be useful to use another grouping criteria than the top level one for the sorting / filtering\n  //\n  // If we have a `leafField` defined and matching an existing column\n  // Then we apply the sorting / filtering on the leaves based on the properties of `leavesColDef`\n  //\n  // By default, we apply the sorting / filtering on the groups of the top level grouping criteria based on the properties of `columnsLookup[orderedGroupedByFields[0]]`.\n  let sourceProperties;\n  if (mainGroupingCriteria && rowGroupingModel.includes(mainGroupingCriteria)) {\n    sourceProperties = getGroupingCriteriaProperties(columnsLookup[mainGroupingCriteria], true);\n  } else if (leafColDef) {\n    sourceProperties = getLeafProperties(leafColDef);\n  } else {\n    sourceProperties = getGroupingCriteriaProperties(columnsLookup[rowGroupingModel[0]], rowGroupingModel.length === 1);\n  }\n\n  // The properties that can't be overridden with `colDefOverride`\n  const forcedProperties = (0, _extends2.default)({\n    field: _gridRowGroupingUtils.GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD\n  }, GROUPING_COL_DEF_FORCED_PROPERTIES);\n  return (0, _extends2.default)({}, GROUPING_COL_DEF_DEFAULT_PROPERTIES, commonProperties, sourceProperties, colDefOverrideProperties, forcedProperties);\n};\nexports.createGroupingColDefForAllGroupingCriteria = createGroupingColDefForAllGroupingCriteria;"],"mappings":"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"},"metadata":{},"sourceType":"script"}