{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { GRID_DATE_COL_DEF, GRID_DATETIME_COL_DEF } from '@mui/x-data-grid-pro';\nimport { buildWarning, isObject, isSingleSelectColDef, gridHasColSpanSelector } from '@mui/x-data-grid/internals';\n\nconst getExcelJs = async () => {\n  const excelJsModule = await import('exceljs');\n  return excelJsModule.default ?? excelJsModule;\n};\n\nconst warnInvalidFormattedValue = buildWarning(['MUI X: When the value of a field is an object or a `renderCell` is provided, the Excel export might not display the value correctly.', 'You can provide a `valueFormatter` with a string representation to be used.']);\n\nconst getFormattedValueOptions = (colDef, row, valueOptions, api) => {\n  if (!colDef.valueOptions) {\n    return [];\n  }\n\n  let valueOptionsFormatted = valueOptions;\n\n  if (colDef.valueFormatter) {\n    valueOptionsFormatted = valueOptionsFormatted.map(option => {\n      if (typeof option === 'object') {\n        return option;\n      }\n\n      return String(colDef.valueFormatter(option, row, colDef, {\n        current: api\n      }));\n    });\n  }\n\n  return valueOptionsFormatted.map(option => typeof option === 'object' ? option.label : option);\n};\n/**\n * FIXME: This function mutates the colspan info, but colspan info assumes that the columns\n * passed to it are always consistent. In this case, the exported columns may differ from the\n * actual rendered columns.\n * The caller of this function MUST call `resetColSpan()` before and after usage.\n */\n\n\nexport const serializeRowUnsafe = (id, columns, apiRef, defaultValueOptionsFormulae, options) => {\n  const row = {};\n  const dataValidation = {};\n  const mergedCells = [];\n  const firstCellParams = apiRef.current.getCellParams(id, columns[0].field);\n  const outlineLevel = firstCellParams.rowNode.depth;\n  const hasColSpan = gridHasColSpanSelector(apiRef);\n\n  if (hasColSpan) {\n    // `colSpan` is only calculated for rendered rows, so we need to calculate it during export for every row\n    apiRef.current.calculateColSpan({\n      rowId: id,\n      minFirstColumn: 0,\n      maxLastColumn: columns.length,\n      columns\n    });\n  }\n\n  columns.forEach((column, colIndex) => {\n    const colSpanInfo = hasColSpan ? apiRef.current.unstable_getCellColSpanInfo(id, colIndex) : undefined;\n\n    if (colSpanInfo && colSpanInfo.spannedByColSpan) {\n      return;\n    }\n\n    if (colSpanInfo && colSpanInfo.cellProps.colSpan > 1) {\n      mergedCells.push({\n        leftIndex: colIndex + 1,\n        rightIndex: colIndex + colSpanInfo.cellProps.colSpan\n      });\n    }\n\n    const cellParams = apiRef.current.getCellParams(id, column.field);\n    let cellValue;\n\n    switch (cellParams.colDef.type) {\n      case 'singleSelect':\n        {\n          const castColumn = cellParams.colDef;\n\n          if (typeof castColumn.valueOptions === 'function') {\n            // If value option depends on the row, set specific options to the cell\n            // This dataValidation is buggy with LibreOffice and does not allow to have coma\n            const valueOptions = castColumn.valueOptions({\n              id,\n              row,\n              field: cellParams.field\n            });\n            const formattedValueOptions = getFormattedValueOptions(castColumn, row, valueOptions, apiRef.current);\n            dataValidation[castColumn.field] = {\n              type: 'list',\n              allowBlank: true,\n              formulae: [`\"${formattedValueOptions.map(x => x.toString().replaceAll(',', 'CHAR(44)')).join(',')}\"`]\n            };\n          } else {\n            const address = defaultValueOptionsFormulae[column.field].address; // If value option is defined for the column, refer to another sheet\n\n            dataValidation[castColumn.field] = {\n              type: 'list',\n              allowBlank: true,\n              formulae: [address]\n            };\n          }\n\n          const formattedValue = apiRef.current.getCellParams(id, castColumn.field).formattedValue;\n\n          if (process.env.NODE_ENV !== 'production') {\n            if (String(cellParams.formattedValue) === '[object Object]') {\n              warnInvalidFormattedValue();\n            }\n          }\n\n          if (isObject(formattedValue)) {\n            row[castColumn.field] = formattedValue?.label;\n          } else {\n            row[castColumn.field] = formattedValue;\n          }\n\n          break;\n        }\n\n      case 'boolean':\n      case 'number':\n        cellValue = apiRef.current.getCellParams(id, column.field).value;\n        break;\n\n      case 'date':\n      case 'dateTime':\n        {\n          // Excel does not do any timezone conversion, so we create a date using UTC instead of local timezone\n          // Solution from: https://github.com/exceljs/exceljs/issues/486#issuecomment-432557582\n          // About Date.UTC(): https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/UTC#exemples\n          const value = apiRef.current.getCellParams(id, column.field).value; // value may be `undefined` in auto-generated grouping rows\n\n          if (!value) {\n            break;\n          }\n\n          const utcDate = new Date(Date.UTC(value.getFullYear(), value.getMonth(), value.getDate(), value.getHours(), value.getMinutes(), value.getSeconds()));\n          row[column.field] = utcDate;\n          break;\n        }\n\n      case 'actions':\n        break;\n\n      default:\n        cellValue = apiRef.current.getCellParams(id, column.field).formattedValue;\n\n        if (process.env.NODE_ENV !== 'production') {\n          if (String(cellParams.formattedValue) === '[object Object]') {\n            warnInvalidFormattedValue();\n          }\n        }\n\n        break;\n    }\n\n    if (typeof cellValue === 'string' && options.escapeFormulas) {\n      // See https://owasp.org/www-community/attacks/CSV_Injection\n      if (['=', '+', '-', '@', '\\t', '\\r'].includes(cellValue[0])) {\n        cellValue = `'${cellValue}`;\n      }\n    }\n\n    if (typeof cellValue !== 'undefined') {\n      row[column.field] = cellValue;\n    }\n  });\n  return {\n    row,\n    dataValidation,\n    outlineLevel,\n    mergedCells\n  };\n};\nconst defaultColumnsStyles = {\n  [GRID_DATE_COL_DEF.type]: {\n    numFmt: 'dd.mm.yyyy'\n  },\n  [GRID_DATETIME_COL_DEF.type]: {\n    numFmt: 'dd.mm.yyyy hh:mm'\n  }\n};\nexport const serializeColumn = (column, columnsStyles) => {\n  const {\n    field,\n    type\n  } = column;\n  return {\n    key: field,\n    headerText: column.headerName ?? column.field,\n    // Excel width must stay between 0 and 255 (https://support.microsoft.com/en-us/office/change-the-column-width-and-row-height-72f5e3cc-994d-43e8-ae58-9774a0905f46)\n    // From the example of column width behavior (https://docs.microsoft.com/en-US/office/troubleshoot/excel/determine-column-widths#example-of-column-width-behavior)\n    // a value of 10 corresponds to 75px. This is an approximation, because column width depends on the font-size\n    width: Math.min(255, column.width ? column.width / 7.5 : 8.43),\n    style: _extends({}, type && defaultColumnsStyles?.[type], columnsStyles?.[field])\n  };\n};\n\nconst addColumnGroupingHeaders = (worksheet, columns, columnGroupPaths, columnGroupDetails) => {\n  const maxDepth = Math.max(...columns.map(_ref => {\n    let {\n      key\n    } = _ref;\n    return columnGroupPaths[key]?.length ?? 0;\n  }));\n\n  if (maxDepth === 0) {\n    return;\n  }\n\n  for (let rowIndex = 0; rowIndex < maxDepth; rowIndex += 1) {\n    const row = columns.map(_ref2 => {\n      let {\n        key\n      } = _ref2;\n      const groupingPath = columnGroupPaths[key];\n\n      if (groupingPath.length <= rowIndex) {\n        return {\n          groupId: null,\n          parents: groupingPath\n        };\n      }\n\n      return _extends({}, columnGroupDetails[groupingPath[rowIndex]], {\n        parents: groupingPath.slice(0, rowIndex)\n      });\n    });\n    const newRow = worksheet.addRow(row.map(group => group.groupId === null ? null : group?.headerName ?? group.groupId)); // use `rowCount`, since worksheet can have additional rows added in `exceljsPreProcess`\n\n    const lastRowIndex = newRow.worksheet.rowCount;\n    let leftIndex = 0;\n    let rightIndex = 1;\n\n    while (rightIndex < columns.length) {\n      const {\n        groupId: leftGroupId,\n        parents: leftParents\n      } = row[leftIndex];\n      const {\n        groupId: rightGroupId,\n        parents: rightParents\n      } = row[rightIndex];\n      const areInSameGroup = leftGroupId === rightGroupId && leftParents.length === rightParents.length && leftParents.every((leftParent, index) => rightParents[index] === leftParent);\n\n      if (areInSameGroup) {\n        rightIndex += 1;\n      } else {\n        if (rightIndex - leftIndex > 1) {\n          worksheet.mergeCells(lastRowIndex, leftIndex + 1, lastRowIndex, rightIndex);\n        }\n\n        leftIndex = rightIndex;\n        rightIndex += 1;\n      }\n    }\n\n    if (rightIndex - leftIndex > 1) {\n      worksheet.mergeCells(lastRowIndex, leftIndex + 1, lastRowIndex, rightIndex);\n    }\n  }\n};\n\nexport function serializeColumns(columns, styles) {\n  return columns.map(column => serializeColumn(column, styles));\n}\nexport async function getDataForValueOptionsSheet(columns, valueOptionsSheetName, api) {\n  const candidateColumns = columns.filter(column => isSingleSelectColDef(column) && Array.isArray(column.valueOptions)); // Creates a temp worksheet to obtain the column letters\n\n  const excelJS = await getExcelJs();\n  const workbook = new excelJS.Workbook();\n  const worksheet = workbook.addWorksheet('Sheet1');\n  worksheet.columns = candidateColumns.map(column => ({\n    key: column.field\n  }));\n  return candidateColumns.reduce((acc, column) => {\n    const singleSelectColumn = column;\n    const formattedValueOptions = getFormattedValueOptions(singleSelectColumn, {}, singleSelectColumn.valueOptions, api);\n    const header = column.headerName ?? column.field;\n    const values = [header, ...formattedValueOptions];\n    const letter = worksheet.getColumn(column.field).letter;\n    const address = `${valueOptionsSheetName}!$${letter}$2:$${letter}$${values.length}`;\n    acc[column.field] = {\n      values,\n      address\n    };\n    return acc;\n  }, {});\n}\n\nfunction addSerializedRowToWorksheet(serializedRow, worksheet) {\n  const {\n    row,\n    dataValidation,\n    outlineLevel,\n    mergedCells\n  } = serializedRow;\n  const newRow = worksheet.addRow(row);\n  Object.keys(dataValidation).forEach(field => {\n    newRow.getCell(field).dataValidation = _extends({}, dataValidation[field]);\n  });\n\n  if (outlineLevel) {\n    newRow.outlineLevel = outlineLevel;\n  } // use `rowCount`, since worksheet can have additional rows added in `exceljsPreProcess`\n\n\n  const lastRowIndex = newRow.worksheet.rowCount;\n  mergedCells.forEach(mergedCell => {\n    worksheet.mergeCells(lastRowIndex, mergedCell.leftIndex, lastRowIndex, mergedCell.rightIndex);\n  });\n}\n\nasync function createValueOptionsSheetIfNeeded(valueOptionsData, sheetName, workbook) {\n  if (Object.keys(valueOptionsData).length === 0) {\n    return;\n  }\n\n  const valueOptionsWorksheet = workbook.addWorksheet(sheetName);\n  valueOptionsWorksheet.columns = Object.keys(valueOptionsData).map(key => ({\n    key\n  }));\n  Object.entries(valueOptionsData).forEach(_ref3 => {\n    let [field, {\n      values\n    }] = _ref3;\n    valueOptionsWorksheet.getColumn(field).values = values;\n  });\n}\n\nexport async function buildExcel(options, apiRef) {\n  const {\n    columns,\n    rowIds,\n    includeHeaders,\n    includeColumnGroupsHeaders,\n    valueOptionsSheetName = 'Options',\n    exceljsPreProcess,\n    exceljsPostProcess,\n    columnsStyles = {}\n  } = options;\n  const excelJS = await getExcelJs();\n  const workbook = new excelJS.Workbook();\n  const worksheet = workbook.addWorksheet('Sheet1');\n  const serializedColumns = serializeColumns(columns, columnsStyles);\n  worksheet.columns = serializedColumns;\n\n  if (exceljsPreProcess) {\n    await exceljsPreProcess({\n      workbook,\n      worksheet\n    });\n  }\n\n  if (includeColumnGroupsHeaders) {\n    const columnGroupPaths = columns.reduce((acc, column) => {\n      acc[column.field] = apiRef.current.getColumnGroupPath(column.field);\n      return acc;\n    }, {});\n    addColumnGroupingHeaders(worksheet, serializedColumns, columnGroupPaths, apiRef.current.getAllGroupDetails());\n  }\n\n  if (includeHeaders) {\n    worksheet.addRow(columns.map(column => column.headerName ?? column.field));\n  }\n\n  const valueOptionsData = await getDataForValueOptionsSheet(columns, valueOptionsSheetName, apiRef.current);\n  createValueOptionsSheetIfNeeded(valueOptionsData, valueOptionsSheetName, workbook);\n  apiRef.current.resetColSpan();\n  rowIds.forEach(id => {\n    const serializedRow = serializeRowUnsafe(id, columns, apiRef, valueOptionsData, options);\n    addSerializedRowToWorksheet(serializedRow, worksheet);\n  });\n  apiRef.current.resetColSpan();\n\n  if (exceljsPostProcess) {\n    await exceljsPostProcess({\n      workbook,\n      worksheet\n    });\n  }\n\n  return workbook;\n}\nexport function setupExcelExportWebWorker() {\n  let workerOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  // eslint-disable-next-line no-restricted-globals\n  addEventListener('message', async event => {\n    const {\n      serializedColumns,\n      serializedRows,\n      options,\n      valueOptionsSheetName,\n      valueOptionsData,\n      columnGroupDetails,\n      columnGroupPaths\n    } = event.data;\n    const {\n      exceljsPostProcess,\n      exceljsPreProcess\n    } = workerOptions;\n    const excelJS = await getExcelJs();\n    const workbook = new excelJS.Workbook();\n    const worksheet = workbook.addWorksheet('Sheet1');\n    worksheet.columns = serializedColumns;\n\n    if (exceljsPreProcess) {\n      await exceljsPreProcess({\n        workbook,\n        worksheet\n      });\n    }\n\n    if (options.includeColumnGroupsHeaders) {\n      addColumnGroupingHeaders(worksheet, serializedColumns, columnGroupPaths, columnGroupDetails);\n    }\n\n    const includeHeaders = options.includeHeaders ?? true;\n\n    if (includeHeaders) {\n      worksheet.addRow(serializedColumns.map(column => column.headerText));\n    }\n\n    createValueOptionsSheetIfNeeded(valueOptionsData, valueOptionsSheetName, workbook);\n    serializedRows.forEach(serializedRow => {\n      addSerializedRowToWorksheet(serializedRow, worksheet);\n    });\n\n    if (exceljsPostProcess) {\n      await exceljsPostProcess({\n        workbook,\n        worksheet\n      });\n    }\n\n    postMessage(await workbook.xlsx.writeBuffer());\n  });\n}","map":{"version":3,"names":["_extends","GRID_DATE_COL_DEF","GRID_DATETIME_COL_DEF","buildWarning","isObject","isSingleSelectColDef","gridHasColSpanSelector","getExcelJs","excelJsModule","default","warnInvalidFormattedValue","getFormattedValueOptions","colDef","row","valueOptions","api","valueOptionsFormatted","valueFormatter","map","option","String","current","label","serializeRowUnsafe","id","columns","apiRef","defaultValueOptionsFormulae","options","dataValidation","mergedCells","firstCellParams","getCellParams","field","outlineLevel","rowNode","depth","hasColSpan","calculateColSpan","rowId","minFirstColumn","maxLastColumn","length","forEach","column","colIndex","colSpanInfo","unstable_getCellColSpanInfo","undefined","spannedByColSpan","cellProps","colSpan","push","leftIndex","rightIndex","cellParams","cellValue","type","castColumn","formattedValueOptions","allowBlank","formulae","x","toString","replaceAll","join","address","formattedValue","process","env","NODE_ENV","value","utcDate","Date","UTC","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","escapeFormulas","includes","defaultColumnsStyles","numFmt","serializeColumn","columnsStyles","key","headerText","headerName","width","Math","min","style","addColumnGroupingHeaders","worksheet","columnGroupPaths","columnGroupDetails","maxDepth","max","rowIndex","groupingPath","groupId","parents","slice","newRow","addRow","group","lastRowIndex","rowCount","leftGroupId","leftParents","rightGroupId","rightParents","areInSameGroup","every","leftParent","index","mergeCells","serializeColumns","styles","getDataForValueOptionsSheet","valueOptionsSheetName","candidateColumns","filter","Array","isArray","excelJS","workbook","Workbook","addWorksheet","reduce","acc","singleSelectColumn","header","values","letter","getColumn","addSerializedRowToWorksheet","serializedRow","Object","keys","getCell","mergedCell","createValueOptionsSheetIfNeeded","valueOptionsData","sheetName","valueOptionsWorksheet","entries","buildExcel","rowIds","includeHeaders","includeColumnGroupsHeaders","exceljsPreProcess","exceljsPostProcess","serializedColumns","getColumnGroupPath","getAllGroupDetails","resetColSpan","setupExcelExportWebWorker","workerOptions","addEventListener","event","serializedRows","data","postMessage","xlsx","writeBuffer"],"sources":["C:/Users/kb/node_modules/@mui/x-data-grid-premium/esm/hooks/features/export/serializer/excelSerializer.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { GRID_DATE_COL_DEF, GRID_DATETIME_COL_DEF } from '@mui/x-data-grid-pro';\nimport { buildWarning, isObject, isSingleSelectColDef, gridHasColSpanSelector } from '@mui/x-data-grid/internals';\nconst getExcelJs = async () => {\n  const excelJsModule = await import('exceljs');\n  return excelJsModule.default ?? excelJsModule;\n};\nconst warnInvalidFormattedValue = buildWarning(['MUI X: When the value of a field is an object or a `renderCell` is provided, the Excel export might not display the value correctly.', 'You can provide a `valueFormatter` with a string representation to be used.']);\nconst getFormattedValueOptions = (colDef, row, valueOptions, api) => {\n  if (!colDef.valueOptions) {\n    return [];\n  }\n  let valueOptionsFormatted = valueOptions;\n  if (colDef.valueFormatter) {\n    valueOptionsFormatted = valueOptionsFormatted.map(option => {\n      if (typeof option === 'object') {\n        return option;\n      }\n      return String(colDef.valueFormatter(option, row, colDef, {\n        current: api\n      }));\n    });\n  }\n  return valueOptionsFormatted.map(option => typeof option === 'object' ? option.label : option);\n};\n/**\n * FIXME: This function mutates the colspan info, but colspan info assumes that the columns\n * passed to it are always consistent. In this case, the exported columns may differ from the\n * actual rendered columns.\n * The caller of this function MUST call `resetColSpan()` before and after usage.\n */\nexport const serializeRowUnsafe = (id, columns, apiRef, defaultValueOptionsFormulae, options) => {\n  const row = {};\n  const dataValidation = {};\n  const mergedCells = [];\n  const firstCellParams = apiRef.current.getCellParams(id, columns[0].field);\n  const outlineLevel = firstCellParams.rowNode.depth;\n  const hasColSpan = gridHasColSpanSelector(apiRef);\n  if (hasColSpan) {\n    // `colSpan` is only calculated for rendered rows, so we need to calculate it during export for every row\n    apiRef.current.calculateColSpan({\n      rowId: id,\n      minFirstColumn: 0,\n      maxLastColumn: columns.length,\n      columns\n    });\n  }\n  columns.forEach((column, colIndex) => {\n    const colSpanInfo = hasColSpan ? apiRef.current.unstable_getCellColSpanInfo(id, colIndex) : undefined;\n    if (colSpanInfo && colSpanInfo.spannedByColSpan) {\n      return;\n    }\n    if (colSpanInfo && colSpanInfo.cellProps.colSpan > 1) {\n      mergedCells.push({\n        leftIndex: colIndex + 1,\n        rightIndex: colIndex + colSpanInfo.cellProps.colSpan\n      });\n    }\n    const cellParams = apiRef.current.getCellParams(id, column.field);\n    let cellValue;\n    switch (cellParams.colDef.type) {\n      case 'singleSelect':\n        {\n          const castColumn = cellParams.colDef;\n          if (typeof castColumn.valueOptions === 'function') {\n            // If value option depends on the row, set specific options to the cell\n            // This dataValidation is buggy with LibreOffice and does not allow to have coma\n            const valueOptions = castColumn.valueOptions({\n              id,\n              row,\n              field: cellParams.field\n            });\n            const formattedValueOptions = getFormattedValueOptions(castColumn, row, valueOptions, apiRef.current);\n            dataValidation[castColumn.field] = {\n              type: 'list',\n              allowBlank: true,\n              formulae: [`\"${formattedValueOptions.map(x => x.toString().replaceAll(',', 'CHAR(44)')).join(',')}\"`]\n            };\n          } else {\n            const address = defaultValueOptionsFormulae[column.field].address;\n\n            // If value option is defined for the column, refer to another sheet\n            dataValidation[castColumn.field] = {\n              type: 'list',\n              allowBlank: true,\n              formulae: [address]\n            };\n          }\n          const formattedValue = apiRef.current.getCellParams(id, castColumn.field).formattedValue;\n          if (process.env.NODE_ENV !== 'production') {\n            if (String(cellParams.formattedValue) === '[object Object]') {\n              warnInvalidFormattedValue();\n            }\n          }\n          if (isObject(formattedValue)) {\n            row[castColumn.field] = formattedValue?.label;\n          } else {\n            row[castColumn.field] = formattedValue;\n          }\n          break;\n        }\n      case 'boolean':\n      case 'number':\n        cellValue = apiRef.current.getCellParams(id, column.field).value;\n        break;\n      case 'date':\n      case 'dateTime':\n        {\n          // Excel does not do any timezone conversion, so we create a date using UTC instead of local timezone\n          // Solution from: https://github.com/exceljs/exceljs/issues/486#issuecomment-432557582\n          // About Date.UTC(): https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/UTC#exemples\n          const value = apiRef.current.getCellParams(id, column.field).value;\n          // value may be `undefined` in auto-generated grouping rows\n          if (!value) {\n            break;\n          }\n          const utcDate = new Date(Date.UTC(value.getFullYear(), value.getMonth(), value.getDate(), value.getHours(), value.getMinutes(), value.getSeconds()));\n          row[column.field] = utcDate;\n          break;\n        }\n      case 'actions':\n        break;\n      default:\n        cellValue = apiRef.current.getCellParams(id, column.field).formattedValue;\n        if (process.env.NODE_ENV !== 'production') {\n          if (String(cellParams.formattedValue) === '[object Object]') {\n            warnInvalidFormattedValue();\n          }\n        }\n        break;\n    }\n    if (typeof cellValue === 'string' && options.escapeFormulas) {\n      // See https://owasp.org/www-community/attacks/CSV_Injection\n      if (['=', '+', '-', '@', '\\t', '\\r'].includes(cellValue[0])) {\n        cellValue = `'${cellValue}`;\n      }\n    }\n    if (typeof cellValue !== 'undefined') {\n      row[column.field] = cellValue;\n    }\n  });\n  return {\n    row,\n    dataValidation,\n    outlineLevel,\n    mergedCells\n  };\n};\nconst defaultColumnsStyles = {\n  [GRID_DATE_COL_DEF.type]: {\n    numFmt: 'dd.mm.yyyy'\n  },\n  [GRID_DATETIME_COL_DEF.type]: {\n    numFmt: 'dd.mm.yyyy hh:mm'\n  }\n};\nexport const serializeColumn = (column, columnsStyles) => {\n  const {\n    field,\n    type\n  } = column;\n  return {\n    key: field,\n    headerText: column.headerName ?? column.field,\n    // Excel width must stay between 0 and 255 (https://support.microsoft.com/en-us/office/change-the-column-width-and-row-height-72f5e3cc-994d-43e8-ae58-9774a0905f46)\n    // From the example of column width behavior (https://docs.microsoft.com/en-US/office/troubleshoot/excel/determine-column-widths#example-of-column-width-behavior)\n    // a value of 10 corresponds to 75px. This is an approximation, because column width depends on the font-size\n    width: Math.min(255, column.width ? column.width / 7.5 : 8.43),\n    style: _extends({}, type && defaultColumnsStyles?.[type], columnsStyles?.[field])\n  };\n};\nconst addColumnGroupingHeaders = (worksheet, columns, columnGroupPaths, columnGroupDetails) => {\n  const maxDepth = Math.max(...columns.map(({\n    key\n  }) => columnGroupPaths[key]?.length ?? 0));\n  if (maxDepth === 0) {\n    return;\n  }\n  for (let rowIndex = 0; rowIndex < maxDepth; rowIndex += 1) {\n    const row = columns.map(({\n      key\n    }) => {\n      const groupingPath = columnGroupPaths[key];\n      if (groupingPath.length <= rowIndex) {\n        return {\n          groupId: null,\n          parents: groupingPath\n        };\n      }\n      return _extends({}, columnGroupDetails[groupingPath[rowIndex]], {\n        parents: groupingPath.slice(0, rowIndex)\n      });\n    });\n    const newRow = worksheet.addRow(row.map(group => group.groupId === null ? null : group?.headerName ?? group.groupId));\n\n    // use `rowCount`, since worksheet can have additional rows added in `exceljsPreProcess`\n    const lastRowIndex = newRow.worksheet.rowCount;\n    let leftIndex = 0;\n    let rightIndex = 1;\n    while (rightIndex < columns.length) {\n      const {\n        groupId: leftGroupId,\n        parents: leftParents\n      } = row[leftIndex];\n      const {\n        groupId: rightGroupId,\n        parents: rightParents\n      } = row[rightIndex];\n      const areInSameGroup = leftGroupId === rightGroupId && leftParents.length === rightParents.length && leftParents.every((leftParent, index) => rightParents[index] === leftParent);\n      if (areInSameGroup) {\n        rightIndex += 1;\n      } else {\n        if (rightIndex - leftIndex > 1) {\n          worksheet.mergeCells(lastRowIndex, leftIndex + 1, lastRowIndex, rightIndex);\n        }\n        leftIndex = rightIndex;\n        rightIndex += 1;\n      }\n    }\n    if (rightIndex - leftIndex > 1) {\n      worksheet.mergeCells(lastRowIndex, leftIndex + 1, lastRowIndex, rightIndex);\n    }\n  }\n};\nexport function serializeColumns(columns, styles) {\n  return columns.map(column => serializeColumn(column, styles));\n}\nexport async function getDataForValueOptionsSheet(columns, valueOptionsSheetName, api) {\n  const candidateColumns = columns.filter(column => isSingleSelectColDef(column) && Array.isArray(column.valueOptions));\n\n  // Creates a temp worksheet to obtain the column letters\n  const excelJS = await getExcelJs();\n  const workbook = new excelJS.Workbook();\n  const worksheet = workbook.addWorksheet('Sheet1');\n  worksheet.columns = candidateColumns.map(column => ({\n    key: column.field\n  }));\n  return candidateColumns.reduce((acc, column) => {\n    const singleSelectColumn = column;\n    const formattedValueOptions = getFormattedValueOptions(singleSelectColumn, {}, singleSelectColumn.valueOptions, api);\n    const header = column.headerName ?? column.field;\n    const values = [header, ...formattedValueOptions];\n    const letter = worksheet.getColumn(column.field).letter;\n    const address = `${valueOptionsSheetName}!$${letter}$2:$${letter}$${values.length}`;\n    acc[column.field] = {\n      values,\n      address\n    };\n    return acc;\n  }, {});\n}\nfunction addSerializedRowToWorksheet(serializedRow, worksheet) {\n  const {\n    row,\n    dataValidation,\n    outlineLevel,\n    mergedCells\n  } = serializedRow;\n  const newRow = worksheet.addRow(row);\n  Object.keys(dataValidation).forEach(field => {\n    newRow.getCell(field).dataValidation = _extends({}, dataValidation[field]);\n  });\n  if (outlineLevel) {\n    newRow.outlineLevel = outlineLevel;\n  }\n\n  // use `rowCount`, since worksheet can have additional rows added in `exceljsPreProcess`\n  const lastRowIndex = newRow.worksheet.rowCount;\n  mergedCells.forEach(mergedCell => {\n    worksheet.mergeCells(lastRowIndex, mergedCell.leftIndex, lastRowIndex, mergedCell.rightIndex);\n  });\n}\nasync function createValueOptionsSheetIfNeeded(valueOptionsData, sheetName, workbook) {\n  if (Object.keys(valueOptionsData).length === 0) {\n    return;\n  }\n  const valueOptionsWorksheet = workbook.addWorksheet(sheetName);\n  valueOptionsWorksheet.columns = Object.keys(valueOptionsData).map(key => ({\n    key\n  }));\n  Object.entries(valueOptionsData).forEach(([field, {\n    values\n  }]) => {\n    valueOptionsWorksheet.getColumn(field).values = values;\n  });\n}\nexport async function buildExcel(options, apiRef) {\n  const {\n    columns,\n    rowIds,\n    includeHeaders,\n    includeColumnGroupsHeaders,\n    valueOptionsSheetName = 'Options',\n    exceljsPreProcess,\n    exceljsPostProcess,\n    columnsStyles = {}\n  } = options;\n  const excelJS = await getExcelJs();\n  const workbook = new excelJS.Workbook();\n  const worksheet = workbook.addWorksheet('Sheet1');\n  const serializedColumns = serializeColumns(columns, columnsStyles);\n  worksheet.columns = serializedColumns;\n  if (exceljsPreProcess) {\n    await exceljsPreProcess({\n      workbook,\n      worksheet\n    });\n  }\n  if (includeColumnGroupsHeaders) {\n    const columnGroupPaths = columns.reduce((acc, column) => {\n      acc[column.field] = apiRef.current.getColumnGroupPath(column.field);\n      return acc;\n    }, {});\n    addColumnGroupingHeaders(worksheet, serializedColumns, columnGroupPaths, apiRef.current.getAllGroupDetails());\n  }\n  if (includeHeaders) {\n    worksheet.addRow(columns.map(column => column.headerName ?? column.field));\n  }\n  const valueOptionsData = await getDataForValueOptionsSheet(columns, valueOptionsSheetName, apiRef.current);\n  createValueOptionsSheetIfNeeded(valueOptionsData, valueOptionsSheetName, workbook);\n  apiRef.current.resetColSpan();\n  rowIds.forEach(id => {\n    const serializedRow = serializeRowUnsafe(id, columns, apiRef, valueOptionsData, options);\n    addSerializedRowToWorksheet(serializedRow, worksheet);\n  });\n  apiRef.current.resetColSpan();\n  if (exceljsPostProcess) {\n    await exceljsPostProcess({\n      workbook,\n      worksheet\n    });\n  }\n  return workbook;\n}\nexport function setupExcelExportWebWorker(workerOptions = {}) {\n  // eslint-disable-next-line no-restricted-globals\n  addEventListener('message', async event => {\n    const {\n      serializedColumns,\n      serializedRows,\n      options,\n      valueOptionsSheetName,\n      valueOptionsData,\n      columnGroupDetails,\n      columnGroupPaths\n    } = event.data;\n    const {\n      exceljsPostProcess,\n      exceljsPreProcess\n    } = workerOptions;\n    const excelJS = await getExcelJs();\n    const workbook = new excelJS.Workbook();\n    const worksheet = workbook.addWorksheet('Sheet1');\n    worksheet.columns = serializedColumns;\n    if (exceljsPreProcess) {\n      await exceljsPreProcess({\n        workbook,\n        worksheet\n      });\n    }\n    if (options.includeColumnGroupsHeaders) {\n      addColumnGroupingHeaders(worksheet, serializedColumns, columnGroupPaths, columnGroupDetails);\n    }\n    const includeHeaders = options.includeHeaders ?? true;\n    if (includeHeaders) {\n      worksheet.addRow(serializedColumns.map(column => column.headerText));\n    }\n    createValueOptionsSheetIfNeeded(valueOptionsData, valueOptionsSheetName, workbook);\n    serializedRows.forEach(serializedRow => {\n      addSerializedRowToWorksheet(serializedRow, worksheet);\n    });\n    if (exceljsPostProcess) {\n      await exceljsPostProcess({\n        workbook,\n        worksheet\n      });\n    }\n    postMessage(await workbook.xlsx.writeBuffer());\n  });\n}"],"mappings":"AAAA,OAAOA,QAAP,MAAqB,oCAArB;AACA,SAASC,iBAAT,EAA4BC,qBAA5B,QAAyD,sBAAzD;AACA,SAASC,YAAT,EAAuBC,QAAvB,EAAiCC,oBAAjC,EAAuDC,sBAAvD,QAAqF,4BAArF;;AACA,MAAMC,UAAU,GAAG,YAAY;EAC7B,MAAMC,aAAa,GAAG,MAAM,OAAO,SAAP,CAA5B;EACA,OAAOA,aAAa,CAACC,OAAd,IAAyBD,aAAhC;AACD,CAHD;;AAIA,MAAME,yBAAyB,GAAGP,YAAY,CAAC,CAAC,sIAAD,EAAyI,6EAAzI,CAAD,CAA9C;;AACA,MAAMQ,wBAAwB,GAAG,CAACC,MAAD,EAASC,GAAT,EAAcC,YAAd,EAA4BC,GAA5B,KAAoC;EACnE,IAAI,CAACH,MAAM,CAACE,YAAZ,EAA0B;IACxB,OAAO,EAAP;EACD;;EACD,IAAIE,qBAAqB,GAAGF,YAA5B;;EACA,IAAIF,MAAM,CAACK,cAAX,EAA2B;IACzBD,qBAAqB,GAAGA,qBAAqB,CAACE,GAAtB,CAA0BC,MAAM,IAAI;MAC1D,IAAI,OAAOA,MAAP,KAAkB,QAAtB,EAAgC;QAC9B,OAAOA,MAAP;MACD;;MACD,OAAOC,MAAM,CAACR,MAAM,CAACK,cAAP,CAAsBE,MAAtB,EAA8BN,GAA9B,EAAmCD,MAAnC,EAA2C;QACvDS,OAAO,EAAEN;MAD8C,CAA3C,CAAD,CAAb;IAGD,CAPuB,CAAxB;EAQD;;EACD,OAAOC,qBAAqB,CAACE,GAAtB,CAA0BC,MAAM,IAAI,OAAOA,MAAP,KAAkB,QAAlB,GAA6BA,MAAM,CAACG,KAApC,GAA4CH,MAAhF,CAAP;AACD,CAhBD;AAiBA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,MAAMI,kBAAkB,GAAG,CAACC,EAAD,EAAKC,OAAL,EAAcC,MAAd,EAAsBC,2BAAtB,EAAmDC,OAAnD,KAA+D;EAC/F,MAAMf,GAAG,GAAG,EAAZ;EACA,MAAMgB,cAAc,GAAG,EAAvB;EACA,MAAMC,WAAW,GAAG,EAApB;EACA,MAAMC,eAAe,GAAGL,MAAM,CAACL,OAAP,CAAeW,aAAf,CAA6BR,EAA7B,EAAiCC,OAAO,CAAC,CAAD,CAAP,CAAWQ,KAA5C,CAAxB;EACA,MAAMC,YAAY,GAAGH,eAAe,CAACI,OAAhB,CAAwBC,KAA7C;EACA,MAAMC,UAAU,GAAG/B,sBAAsB,CAACoB,MAAD,CAAzC;;EACA,IAAIW,UAAJ,EAAgB;IACd;IACAX,MAAM,CAACL,OAAP,CAAeiB,gBAAf,CAAgC;MAC9BC,KAAK,EAAEf,EADuB;MAE9BgB,cAAc,EAAE,CAFc;MAG9BC,aAAa,EAAEhB,OAAO,CAACiB,MAHO;MAI9BjB;IAJ8B,CAAhC;EAMD;;EACDA,OAAO,CAACkB,OAAR,CAAgB,CAACC,MAAD,EAASC,QAAT,KAAsB;IACpC,MAAMC,WAAW,GAAGT,UAAU,GAAGX,MAAM,CAACL,OAAP,CAAe0B,2BAAf,CAA2CvB,EAA3C,EAA+CqB,QAA/C,CAAH,GAA8DG,SAA5F;;IACA,IAAIF,WAAW,IAAIA,WAAW,CAACG,gBAA/B,EAAiD;MAC/C;IACD;;IACD,IAAIH,WAAW,IAAIA,WAAW,CAACI,SAAZ,CAAsBC,OAAtB,GAAgC,CAAnD,EAAsD;MACpDrB,WAAW,CAACsB,IAAZ,CAAiB;QACfC,SAAS,EAAER,QAAQ,GAAG,CADP;QAEfS,UAAU,EAAET,QAAQ,GAAGC,WAAW,CAACI,SAAZ,CAAsBC;MAF9B,CAAjB;IAID;;IACD,MAAMI,UAAU,GAAG7B,MAAM,CAACL,OAAP,CAAeW,aAAf,CAA6BR,EAA7B,EAAiCoB,MAAM,CAACX,KAAxC,CAAnB;IACA,IAAIuB,SAAJ;;IACA,QAAQD,UAAU,CAAC3C,MAAX,CAAkB6C,IAA1B;MACE,KAAK,cAAL;QACE;UACE,MAAMC,UAAU,GAAGH,UAAU,CAAC3C,MAA9B;;UACA,IAAI,OAAO8C,UAAU,CAAC5C,YAAlB,KAAmC,UAAvC,EAAmD;YACjD;YACA;YACA,MAAMA,YAAY,GAAG4C,UAAU,CAAC5C,YAAX,CAAwB;cAC3CU,EAD2C;cAE3CX,GAF2C;cAG3CoB,KAAK,EAAEsB,UAAU,CAACtB;YAHyB,CAAxB,CAArB;YAKA,MAAM0B,qBAAqB,GAAGhD,wBAAwB,CAAC+C,UAAD,EAAa7C,GAAb,EAAkBC,YAAlB,EAAgCY,MAAM,CAACL,OAAvC,CAAtD;YACAQ,cAAc,CAAC6B,UAAU,CAACzB,KAAZ,CAAd,GAAmC;cACjCwB,IAAI,EAAE,MAD2B;cAEjCG,UAAU,EAAE,IAFqB;cAGjCC,QAAQ,EAAE,CAAE,IAAGF,qBAAqB,CAACzC,GAAtB,CAA0B4C,CAAC,IAAIA,CAAC,CAACC,QAAF,GAAaC,UAAb,CAAwB,GAAxB,EAA6B,UAA7B,CAA/B,EAAyEC,IAAzE,CAA8E,GAA9E,CAAmF,GAAxF;YAHuB,CAAnC;UAKD,CAdD,MAcO;YACL,MAAMC,OAAO,GAAGvC,2BAA2B,CAACiB,MAAM,CAACX,KAAR,CAA3B,CAA0CiC,OAA1D,CADK,CAGL;;YACArC,cAAc,CAAC6B,UAAU,CAACzB,KAAZ,CAAd,GAAmC;cACjCwB,IAAI,EAAE,MAD2B;cAEjCG,UAAU,EAAE,IAFqB;cAGjCC,QAAQ,EAAE,CAACK,OAAD;YAHuB,CAAnC;UAKD;;UACD,MAAMC,cAAc,GAAGzC,MAAM,CAACL,OAAP,CAAeW,aAAf,CAA6BR,EAA7B,EAAiCkC,UAAU,CAACzB,KAA5C,EAAmDkC,cAA1E;;UACA,IAAIC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;YACzC,IAAIlD,MAAM,CAACmC,UAAU,CAACY,cAAZ,CAAN,KAAsC,iBAA1C,EAA6D;cAC3DzD,yBAAyB;YAC1B;UACF;;UACD,IAAIN,QAAQ,CAAC+D,cAAD,CAAZ,EAA8B;YAC5BtD,GAAG,CAAC6C,UAAU,CAACzB,KAAZ,CAAH,GAAwBkC,cAAc,EAAE7C,KAAxC;UACD,CAFD,MAEO;YACLT,GAAG,CAAC6C,UAAU,CAACzB,KAAZ,CAAH,GAAwBkC,cAAxB;UACD;;UACD;QACD;;MACH,KAAK,SAAL;MACA,KAAK,QAAL;QACEX,SAAS,GAAG9B,MAAM,CAACL,OAAP,CAAeW,aAAf,CAA6BR,EAA7B,EAAiCoB,MAAM,CAACX,KAAxC,EAA+CsC,KAA3D;QACA;;MACF,KAAK,MAAL;MACA,KAAK,UAAL;QACE;UACE;UACA;UACA;UACA,MAAMA,KAAK,GAAG7C,MAAM,CAACL,OAAP,CAAeW,aAAf,CAA6BR,EAA7B,EAAiCoB,MAAM,CAACX,KAAxC,EAA+CsC,KAA7D,CAJF,CAKE;;UACA,IAAI,CAACA,KAAL,EAAY;YACV;UACD;;UACD,MAAMC,OAAO,GAAG,IAAIC,IAAJ,CAASA,IAAI,CAACC,GAAL,CAASH,KAAK,CAACI,WAAN,EAAT,EAA8BJ,KAAK,CAACK,QAAN,EAA9B,EAAgDL,KAAK,CAACM,OAAN,EAAhD,EAAiEN,KAAK,CAACO,QAAN,EAAjE,EAAmFP,KAAK,CAACQ,UAAN,EAAnF,EAAuGR,KAAK,CAACS,UAAN,EAAvG,CAAT,CAAhB;UACAnE,GAAG,CAAC+B,MAAM,CAACX,KAAR,CAAH,GAAoBuC,OAApB;UACA;QACD;;MACH,KAAK,SAAL;QACE;;MACF;QACEhB,SAAS,GAAG9B,MAAM,CAACL,OAAP,CAAeW,aAAf,CAA6BR,EAA7B,EAAiCoB,MAAM,CAACX,KAAxC,EAA+CkC,cAA3D;;QACA,IAAIC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;UACzC,IAAIlD,MAAM,CAACmC,UAAU,CAACY,cAAZ,CAAN,KAAsC,iBAA1C,EAA6D;YAC3DzD,yBAAyB;UAC1B;QACF;;QACD;IArEJ;;IAuEA,IAAI,OAAO8C,SAAP,KAAqB,QAArB,IAAiC5B,OAAO,CAACqD,cAA7C,EAA6D;MAC3D;MACA,IAAI,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,EAAqB,IAArB,EAA2B,IAA3B,EAAiCC,QAAjC,CAA0C1B,SAAS,CAAC,CAAD,CAAnD,CAAJ,EAA6D;QAC3DA,SAAS,GAAI,IAAGA,SAAU,EAA1B;MACD;IACF;;IACD,IAAI,OAAOA,SAAP,KAAqB,WAAzB,EAAsC;MACpC3C,GAAG,CAAC+B,MAAM,CAACX,KAAR,CAAH,GAAoBuB,SAApB;IACD;EACF,CA7FD;EA8FA,OAAO;IACL3C,GADK;IAELgB,cAFK;IAGLK,YAHK;IAILJ;EAJK,CAAP;AAMD,CApHM;AAqHP,MAAMqD,oBAAoB,GAAG;EAC3B,CAAClF,iBAAiB,CAACwD,IAAnB,GAA0B;IACxB2B,MAAM,EAAE;EADgB,CADC;EAI3B,CAAClF,qBAAqB,CAACuD,IAAvB,GAA8B;IAC5B2B,MAAM,EAAE;EADoB;AAJH,CAA7B;AAQA,OAAO,MAAMC,eAAe,GAAG,CAACzC,MAAD,EAAS0C,aAAT,KAA2B;EACxD,MAAM;IACJrD,KADI;IAEJwB;EAFI,IAGFb,MAHJ;EAIA,OAAO;IACL2C,GAAG,EAAEtD,KADA;IAELuD,UAAU,EAAE5C,MAAM,CAAC6C,UAAP,IAAqB7C,MAAM,CAACX,KAFnC;IAGL;IACA;IACA;IACAyD,KAAK,EAAEC,IAAI,CAACC,GAAL,CAAS,GAAT,EAAchD,MAAM,CAAC8C,KAAP,GAAe9C,MAAM,CAAC8C,KAAP,GAAe,GAA9B,GAAoC,IAAlD,CANF;IAOLG,KAAK,EAAE7F,QAAQ,CAAC,EAAD,EAAKyD,IAAI,IAAI0B,oBAAoB,GAAG1B,IAAH,CAAjC,EAA2C6B,aAAa,GAAGrD,KAAH,CAAxD;EAPV,CAAP;AASD,CAdM;;AAeP,MAAM6D,wBAAwB,GAAG,CAACC,SAAD,EAAYtE,OAAZ,EAAqBuE,gBAArB,EAAuCC,kBAAvC,KAA8D;EAC7F,MAAMC,QAAQ,GAAGP,IAAI,CAACQ,GAAL,CAAS,GAAG1E,OAAO,CAACP,GAAR,CAAY;IAAA,IAAC;MACxCqE;IADwC,CAAD;IAAA,OAEnCS,gBAAgB,CAACT,GAAD,CAAhB,EAAuB7C,MAAvB,IAAiC,CAFE;EAAA,CAAZ,CAAZ,CAAjB;;EAGA,IAAIwD,QAAQ,KAAK,CAAjB,EAAoB;IAClB;EACD;;EACD,KAAK,IAAIE,QAAQ,GAAG,CAApB,EAAuBA,QAAQ,GAAGF,QAAlC,EAA4CE,QAAQ,IAAI,CAAxD,EAA2D;IACzD,MAAMvF,GAAG,GAAGY,OAAO,CAACP,GAAR,CAAY,SAElB;MAAA,IAFmB;QACvBqE;MADuB,CAEnB;MACJ,MAAMc,YAAY,GAAGL,gBAAgB,CAACT,GAAD,CAArC;;MACA,IAAIc,YAAY,CAAC3D,MAAb,IAAuB0D,QAA3B,EAAqC;QACnC,OAAO;UACLE,OAAO,EAAE,IADJ;UAELC,OAAO,EAAEF;QAFJ,CAAP;MAID;;MACD,OAAOrG,QAAQ,CAAC,EAAD,EAAKiG,kBAAkB,CAACI,YAAY,CAACD,QAAD,CAAb,CAAvB,EAAiD;QAC9DG,OAAO,EAAEF,YAAY,CAACG,KAAb,CAAmB,CAAnB,EAAsBJ,QAAtB;MADqD,CAAjD,CAAf;IAGD,CAbW,CAAZ;IAcA,MAAMK,MAAM,GAAGV,SAAS,CAACW,MAAV,CAAiB7F,GAAG,CAACK,GAAJ,CAAQyF,KAAK,IAAIA,KAAK,CAACL,OAAN,KAAkB,IAAlB,GAAyB,IAAzB,GAAgCK,KAAK,EAAElB,UAAP,IAAqBkB,KAAK,CAACL,OAA5E,CAAjB,CAAf,CAfyD,CAiBzD;;IACA,MAAMM,YAAY,GAAGH,MAAM,CAACV,SAAP,CAAiBc,QAAtC;IACA,IAAIxD,SAAS,GAAG,CAAhB;IACA,IAAIC,UAAU,GAAG,CAAjB;;IACA,OAAOA,UAAU,GAAG7B,OAAO,CAACiB,MAA5B,EAAoC;MAClC,MAAM;QACJ4D,OAAO,EAAEQ,WADL;QAEJP,OAAO,EAAEQ;MAFL,IAGFlG,GAAG,CAACwC,SAAD,CAHP;MAIA,MAAM;QACJiD,OAAO,EAAEU,YADL;QAEJT,OAAO,EAAEU;MAFL,IAGFpG,GAAG,CAACyC,UAAD,CAHP;MAIA,MAAM4D,cAAc,GAAGJ,WAAW,KAAKE,YAAhB,IAAgCD,WAAW,CAACrE,MAAZ,KAAuBuE,YAAY,CAACvE,MAApE,IAA8EqE,WAAW,CAACI,KAAZ,CAAkB,CAACC,UAAD,EAAaC,KAAb,KAAuBJ,YAAY,CAACI,KAAD,CAAZ,KAAwBD,UAAjE,CAArG;;MACA,IAAIF,cAAJ,EAAoB;QAClB5D,UAAU,IAAI,CAAd;MACD,CAFD,MAEO;QACL,IAAIA,UAAU,GAAGD,SAAb,GAAyB,CAA7B,EAAgC;UAC9B0C,SAAS,CAACuB,UAAV,CAAqBV,YAArB,EAAmCvD,SAAS,GAAG,CAA/C,EAAkDuD,YAAlD,EAAgEtD,UAAhE;QACD;;QACDD,SAAS,GAAGC,UAAZ;QACAA,UAAU,IAAI,CAAd;MACD;IACF;;IACD,IAAIA,UAAU,GAAGD,SAAb,GAAyB,CAA7B,EAAgC;MAC9B0C,SAAS,CAACuB,UAAV,CAAqBV,YAArB,EAAmCvD,SAAS,GAAG,CAA/C,EAAkDuD,YAAlD,EAAgEtD,UAAhE;IACD;EACF;AACF,CApDD;;AAqDA,OAAO,SAASiE,gBAAT,CAA0B9F,OAA1B,EAAmC+F,MAAnC,EAA2C;EAChD,OAAO/F,OAAO,CAACP,GAAR,CAAY0B,MAAM,IAAIyC,eAAe,CAACzC,MAAD,EAAS4E,MAAT,CAArC,CAAP;AACD;AACD,OAAO,eAAeC,2BAAf,CAA2ChG,OAA3C,EAAoDiG,qBAApD,EAA2E3G,GAA3E,EAAgF;EACrF,MAAM4G,gBAAgB,GAAGlG,OAAO,CAACmG,MAAR,CAAehF,MAAM,IAAIvC,oBAAoB,CAACuC,MAAD,CAApB,IAAgCiF,KAAK,CAACC,OAAN,CAAclF,MAAM,CAAC9B,YAArB,CAAzD,CAAzB,CADqF,CAGrF;;EACA,MAAMiH,OAAO,GAAG,MAAMxH,UAAU,EAAhC;EACA,MAAMyH,QAAQ,GAAG,IAAID,OAAO,CAACE,QAAZ,EAAjB;EACA,MAAMlC,SAAS,GAAGiC,QAAQ,CAACE,YAAT,CAAsB,QAAtB,CAAlB;EACAnC,SAAS,CAACtE,OAAV,GAAoBkG,gBAAgB,CAACzG,GAAjB,CAAqB0B,MAAM,KAAK;IAClD2C,GAAG,EAAE3C,MAAM,CAACX;EADsC,CAAL,CAA3B,CAApB;EAGA,OAAO0F,gBAAgB,CAACQ,MAAjB,CAAwB,CAACC,GAAD,EAAMxF,MAAN,KAAiB;IAC9C,MAAMyF,kBAAkB,GAAGzF,MAA3B;IACA,MAAMe,qBAAqB,GAAGhD,wBAAwB,CAAC0H,kBAAD,EAAqB,EAArB,EAAyBA,kBAAkB,CAACvH,YAA5C,EAA0DC,GAA1D,CAAtD;IACA,MAAMuH,MAAM,GAAG1F,MAAM,CAAC6C,UAAP,IAAqB7C,MAAM,CAACX,KAA3C;IACA,MAAMsG,MAAM,GAAG,CAACD,MAAD,EAAS,GAAG3E,qBAAZ,CAAf;IACA,MAAM6E,MAAM,GAAGzC,SAAS,CAAC0C,SAAV,CAAoB7F,MAAM,CAACX,KAA3B,EAAkCuG,MAAjD;IACA,MAAMtE,OAAO,GAAI,GAAEwD,qBAAsB,KAAIc,MAAO,OAAMA,MAAO,IAAGD,MAAM,CAAC7F,MAAO,EAAlF;IACA0F,GAAG,CAACxF,MAAM,CAACX,KAAR,CAAH,GAAoB;MAClBsG,MADkB;MAElBrE;IAFkB,CAApB;IAIA,OAAOkE,GAAP;EACD,CAZM,EAYJ,EAZI,CAAP;AAaD;;AACD,SAASM,2BAAT,CAAqCC,aAArC,EAAoD5C,SAApD,EAA+D;EAC7D,MAAM;IACJlF,GADI;IAEJgB,cAFI;IAGJK,YAHI;IAIJJ;EAJI,IAKF6G,aALJ;EAMA,MAAMlC,MAAM,GAAGV,SAAS,CAACW,MAAV,CAAiB7F,GAAjB,CAAf;EACA+H,MAAM,CAACC,IAAP,CAAYhH,cAAZ,EAA4Bc,OAA5B,CAAoCV,KAAK,IAAI;IAC3CwE,MAAM,CAACqC,OAAP,CAAe7G,KAAf,EAAsBJ,cAAtB,GAAuC7B,QAAQ,CAAC,EAAD,EAAK6B,cAAc,CAACI,KAAD,CAAnB,CAA/C;EACD,CAFD;;EAGA,IAAIC,YAAJ,EAAkB;IAChBuE,MAAM,CAACvE,YAAP,GAAsBA,YAAtB;EACD,CAb4D,CAe7D;;;EACA,MAAM0E,YAAY,GAAGH,MAAM,CAACV,SAAP,CAAiBc,QAAtC;EACA/E,WAAW,CAACa,OAAZ,CAAoBoG,UAAU,IAAI;IAChChD,SAAS,CAACuB,UAAV,CAAqBV,YAArB,EAAmCmC,UAAU,CAAC1F,SAA9C,EAAyDuD,YAAzD,EAAuEmC,UAAU,CAACzF,UAAlF;EACD,CAFD;AAGD;;AACD,eAAe0F,+BAAf,CAA+CC,gBAA/C,EAAiEC,SAAjE,EAA4ElB,QAA5E,EAAsF;EACpF,IAAIY,MAAM,CAACC,IAAP,CAAYI,gBAAZ,EAA8BvG,MAA9B,KAAyC,CAA7C,EAAgD;IAC9C;EACD;;EACD,MAAMyG,qBAAqB,GAAGnB,QAAQ,CAACE,YAAT,CAAsBgB,SAAtB,CAA9B;EACAC,qBAAqB,CAAC1H,OAAtB,GAAgCmH,MAAM,CAACC,IAAP,CAAYI,gBAAZ,EAA8B/H,GAA9B,CAAkCqE,GAAG,KAAK;IACxEA;EADwE,CAAL,CAArC,CAAhC;EAGAqD,MAAM,CAACQ,OAAP,CAAeH,gBAAf,EAAiCtG,OAAjC,CAAyC,SAElC;IAAA,IAFmC,CAACV,KAAD,EAAQ;MAChDsG;IADgD,CAAR,CAEnC;IACLY,qBAAqB,CAACV,SAAtB,CAAgCxG,KAAhC,EAAuCsG,MAAvC,GAAgDA,MAAhD;EACD,CAJD;AAKD;;AACD,OAAO,eAAec,UAAf,CAA0BzH,OAA1B,EAAmCF,MAAnC,EAA2C;EAChD,MAAM;IACJD,OADI;IAEJ6H,MAFI;IAGJC,cAHI;IAIJC,0BAJI;IAKJ9B,qBAAqB,GAAG,SALpB;IAMJ+B,iBANI;IAOJC,kBAPI;IAQJpE,aAAa,GAAG;EARZ,IASF1D,OATJ;EAUA,MAAMmG,OAAO,GAAG,MAAMxH,UAAU,EAAhC;EACA,MAAMyH,QAAQ,GAAG,IAAID,OAAO,CAACE,QAAZ,EAAjB;EACA,MAAMlC,SAAS,GAAGiC,QAAQ,CAACE,YAAT,CAAsB,QAAtB,CAAlB;EACA,MAAMyB,iBAAiB,GAAGpC,gBAAgB,CAAC9F,OAAD,EAAU6D,aAAV,CAA1C;EACAS,SAAS,CAACtE,OAAV,GAAoBkI,iBAApB;;EACA,IAAIF,iBAAJ,EAAuB;IACrB,MAAMA,iBAAiB,CAAC;MACtBzB,QADsB;MAEtBjC;IAFsB,CAAD,CAAvB;EAID;;EACD,IAAIyD,0BAAJ,EAAgC;IAC9B,MAAMxD,gBAAgB,GAAGvE,OAAO,CAAC0G,MAAR,CAAe,CAACC,GAAD,EAAMxF,MAAN,KAAiB;MACvDwF,GAAG,CAACxF,MAAM,CAACX,KAAR,CAAH,GAAoBP,MAAM,CAACL,OAAP,CAAeuI,kBAAf,CAAkChH,MAAM,CAACX,KAAzC,CAApB;MACA,OAAOmG,GAAP;IACD,CAHwB,EAGtB,EAHsB,CAAzB;IAIAtC,wBAAwB,CAACC,SAAD,EAAY4D,iBAAZ,EAA+B3D,gBAA/B,EAAiDtE,MAAM,CAACL,OAAP,CAAewI,kBAAf,EAAjD,CAAxB;EACD;;EACD,IAAIN,cAAJ,EAAoB;IAClBxD,SAAS,CAACW,MAAV,CAAiBjF,OAAO,CAACP,GAAR,CAAY0B,MAAM,IAAIA,MAAM,CAAC6C,UAAP,IAAqB7C,MAAM,CAACX,KAAlD,CAAjB;EACD;;EACD,MAAMgH,gBAAgB,GAAG,MAAMxB,2BAA2B,CAAChG,OAAD,EAAUiG,qBAAV,EAAiChG,MAAM,CAACL,OAAxC,CAA1D;EACA2H,+BAA+B,CAACC,gBAAD,EAAmBvB,qBAAnB,EAA0CM,QAA1C,CAA/B;EACAtG,MAAM,CAACL,OAAP,CAAeyI,YAAf;EACAR,MAAM,CAAC3G,OAAP,CAAenB,EAAE,IAAI;IACnB,MAAMmH,aAAa,GAAGpH,kBAAkB,CAACC,EAAD,EAAKC,OAAL,EAAcC,MAAd,EAAsBuH,gBAAtB,EAAwCrH,OAAxC,CAAxC;IACA8G,2BAA2B,CAACC,aAAD,EAAgB5C,SAAhB,CAA3B;EACD,CAHD;EAIArE,MAAM,CAACL,OAAP,CAAeyI,YAAf;;EACA,IAAIJ,kBAAJ,EAAwB;IACtB,MAAMA,kBAAkB,CAAC;MACvB1B,QADuB;MAEvBjC;IAFuB,CAAD,CAAxB;EAID;;EACD,OAAOiC,QAAP;AACD;AACD,OAAO,SAAS+B,yBAAT,GAAuD;EAAA,IAApBC,aAAoB,uEAAJ,EAAI;EAC5D;EACAC,gBAAgB,CAAC,SAAD,EAAY,MAAMC,KAAN,IAAe;IACzC,MAAM;MACJP,iBADI;MAEJQ,cAFI;MAGJvI,OAHI;MAIJ8F,qBAJI;MAKJuB,gBALI;MAMJhD,kBANI;MAOJD;IAPI,IAQFkE,KAAK,CAACE,IARV;IASA,MAAM;MACJV,kBADI;MAEJD;IAFI,IAGFO,aAHJ;IAIA,MAAMjC,OAAO,GAAG,MAAMxH,UAAU,EAAhC;IACA,MAAMyH,QAAQ,GAAG,IAAID,OAAO,CAACE,QAAZ,EAAjB;IACA,MAAMlC,SAAS,GAAGiC,QAAQ,CAACE,YAAT,CAAsB,QAAtB,CAAlB;IACAnC,SAAS,CAACtE,OAAV,GAAoBkI,iBAApB;;IACA,IAAIF,iBAAJ,EAAuB;MACrB,MAAMA,iBAAiB,CAAC;QACtBzB,QADsB;QAEtBjC;MAFsB,CAAD,CAAvB;IAID;;IACD,IAAInE,OAAO,CAAC4H,0BAAZ,EAAwC;MACtC1D,wBAAwB,CAACC,SAAD,EAAY4D,iBAAZ,EAA+B3D,gBAA/B,EAAiDC,kBAAjD,CAAxB;IACD;;IACD,MAAMsD,cAAc,GAAG3H,OAAO,CAAC2H,cAAR,IAA0B,IAAjD;;IACA,IAAIA,cAAJ,EAAoB;MAClBxD,SAAS,CAACW,MAAV,CAAiBiD,iBAAiB,CAACzI,GAAlB,CAAsB0B,MAAM,IAAIA,MAAM,CAAC4C,UAAvC,CAAjB;IACD;;IACDwD,+BAA+B,CAACC,gBAAD,EAAmBvB,qBAAnB,EAA0CM,QAA1C,CAA/B;IACAmC,cAAc,CAACxH,OAAf,CAAuBgG,aAAa,IAAI;MACtCD,2BAA2B,CAACC,aAAD,EAAgB5C,SAAhB,CAA3B;IACD,CAFD;;IAGA,IAAI2D,kBAAJ,EAAwB;MACtB,MAAMA,kBAAkB,CAAC;QACvB1B,QADuB;QAEvBjC;MAFuB,CAAD,CAAxB;IAID;;IACDsE,WAAW,CAAC,MAAMrC,QAAQ,CAACsC,IAAT,CAAcC,WAAd,EAAP,CAAX;EACD,CA1Ce,CAAhB;AA2CD"},"metadata":{},"sourceType":"module"}