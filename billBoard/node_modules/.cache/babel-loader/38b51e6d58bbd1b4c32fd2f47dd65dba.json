{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridApiMethod } from '../utils';\nimport { isFunction } from '../../utils/utils';\nexport const useGridStateInitialization = apiRef => {\n  const controlStateMapRef = React.useRef({});\n  const [, rawForceUpdate] = React.useState();\n  const registerControlState = React.useCallback(controlStateItem => {\n    controlStateMapRef.current[controlStateItem.stateId] = controlStateItem;\n  }, []);\n  const setState = React.useCallback((state, reason) => {\n    let newState;\n\n    if (isFunction(state)) {\n      newState = state(apiRef.current.state);\n    } else {\n      newState = state;\n    }\n\n    if (apiRef.current.state === newState) {\n      return false;\n    }\n\n    let ignoreSetState = false; // Apply the control state constraints\n\n    const updatedControlStateIds = [];\n    Object.keys(controlStateMapRef.current).forEach(stateId => {\n      const controlState = controlStateMapRef.current[stateId];\n      const oldSubState = controlState.stateSelector(apiRef.current.state, apiRef.current.instanceId);\n      const newSubState = controlState.stateSelector(newState, apiRef.current.instanceId);\n\n      if (newSubState === oldSubState) {\n        return;\n      }\n\n      updatedControlStateIds.push({\n        stateId: controlState.stateId,\n        hasPropChanged: newSubState !== controlState.propModel\n      }); // The state is controlled, the prop should always win\n\n      if (controlState.propModel !== undefined && newSubState !== controlState.propModel) {\n        ignoreSetState = true;\n      }\n    });\n\n    if (updatedControlStateIds.length > 1) {\n      // Each hook modify its own state, and it should not leak\n      // Events are here to forward to other hooks and apply changes.\n      // You are trying to update several states in a no isolated way.\n      throw new Error(`You're not allowed to update several sub-state in one transaction. You already updated ${updatedControlStateIds[0].stateId}, therefore, you're not allowed to update ${updatedControlStateIds.map(el => el.stateId).join(', ')} in the same transaction.`);\n    }\n\n    if (!ignoreSetState) {\n      // We always assign it as we mutate rows for perf reason.\n      apiRef.current.state = newState;\n\n      if (apiRef.current.publishEvent) {\n        apiRef.current.publishEvent('stateChange', newState);\n      }\n\n      apiRef.current.store.update(newState);\n    }\n\n    if (updatedControlStateIds.length === 1) {\n      const {\n        stateId,\n        hasPropChanged\n      } = updatedControlStateIds[0];\n      const controlState = controlStateMapRef.current[stateId];\n      const model = controlState.stateSelector(newState, apiRef.current.instanceId);\n\n      if (controlState.propOnChange && hasPropChanged) {\n        controlState.propOnChange(model, {\n          reason,\n          api: apiRef.current\n        });\n      }\n\n      if (!ignoreSetState) {\n        apiRef.current.publishEvent(controlState.changeEvent, model, {\n          reason\n        });\n      }\n    }\n\n    return !ignoreSetState;\n  }, [apiRef]);\n  const updateControlState = React.useCallback((key, state, reason) => {\n    return apiRef.current.setState(previousState => {\n      return _extends({}, previousState, {\n        [key]: state(previousState[key])\n      });\n    }, reason);\n  }, [apiRef]);\n  const forceUpdate = React.useCallback(() => rawForceUpdate(() => apiRef.current.state), [apiRef]);\n  const publicStateApi = {\n    setState,\n    forceUpdate\n  };\n  const privateStateApi = {\n    updateControlState,\n    registerControlState\n  };\n  useGridApiMethod(apiRef, publicStateApi, 'public');\n  useGridApiMethod(apiRef, privateStateApi, 'private');\n};","map":{"version":3,"names":["_extends","React","useGridApiMethod","isFunction","useGridStateInitialization","apiRef","controlStateMapRef","useRef","rawForceUpdate","useState","registerControlState","useCallback","controlStateItem","current","stateId","setState","state","reason","newState","ignoreSetState","updatedControlStateIds","Object","keys","forEach","controlState","oldSubState","stateSelector","instanceId","newSubState","push","hasPropChanged","propModel","undefined","length","Error","map","el","join","publishEvent","store","update","model","propOnChange","api","changeEvent","updateControlState","key","previousState","forceUpdate","publicStateApi","privateStateApi"],"sources":["C:/Users/kb/Downloads/billBoard/billboard/node_modules/@mui/x-data-grid/hooks/core/useGridStateInitialization.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridApiMethod } from '../utils';\nimport { isFunction } from '../../utils/utils';\nexport const useGridStateInitialization = apiRef => {\n  const controlStateMapRef = React.useRef({});\n  const [, rawForceUpdate] = React.useState();\n  const registerControlState = React.useCallback(controlStateItem => {\n    controlStateMapRef.current[controlStateItem.stateId] = controlStateItem;\n  }, []);\n  const setState = React.useCallback((state, reason) => {\n    let newState;\n    if (isFunction(state)) {\n      newState = state(apiRef.current.state);\n    } else {\n      newState = state;\n    }\n    if (apiRef.current.state === newState) {\n      return false;\n    }\n    let ignoreSetState = false;\n\n    // Apply the control state constraints\n    const updatedControlStateIds = [];\n    Object.keys(controlStateMapRef.current).forEach(stateId => {\n      const controlState = controlStateMapRef.current[stateId];\n      const oldSubState = controlState.stateSelector(apiRef.current.state, apiRef.current.instanceId);\n      const newSubState = controlState.stateSelector(newState, apiRef.current.instanceId);\n      if (newSubState === oldSubState) {\n        return;\n      }\n      updatedControlStateIds.push({\n        stateId: controlState.stateId,\n        hasPropChanged: newSubState !== controlState.propModel\n      });\n\n      // The state is controlled, the prop should always win\n      if (controlState.propModel !== undefined && newSubState !== controlState.propModel) {\n        ignoreSetState = true;\n      }\n    });\n    if (updatedControlStateIds.length > 1) {\n      // Each hook modify its own state, and it should not leak\n      // Events are here to forward to other hooks and apply changes.\n      // You are trying to update several states in a no isolated way.\n      throw new Error(`You're not allowed to update several sub-state in one transaction. You already updated ${updatedControlStateIds[0].stateId}, therefore, you're not allowed to update ${updatedControlStateIds.map(el => el.stateId).join(', ')} in the same transaction.`);\n    }\n    if (!ignoreSetState) {\n      // We always assign it as we mutate rows for perf reason.\n      apiRef.current.state = newState;\n      if (apiRef.current.publishEvent) {\n        apiRef.current.publishEvent('stateChange', newState);\n      }\n      apiRef.current.store.update(newState);\n    }\n    if (updatedControlStateIds.length === 1) {\n      const {\n        stateId,\n        hasPropChanged\n      } = updatedControlStateIds[0];\n      const controlState = controlStateMapRef.current[stateId];\n      const model = controlState.stateSelector(newState, apiRef.current.instanceId);\n      if (controlState.propOnChange && hasPropChanged) {\n        controlState.propOnChange(model, {\n          reason,\n          api: apiRef.current\n        });\n      }\n      if (!ignoreSetState) {\n        apiRef.current.publishEvent(controlState.changeEvent, model, {\n          reason\n        });\n      }\n    }\n    return !ignoreSetState;\n  }, [apiRef]);\n  const updateControlState = React.useCallback((key, state, reason) => {\n    return apiRef.current.setState(previousState => {\n      return _extends({}, previousState, {\n        [key]: state(previousState[key])\n      });\n    }, reason);\n  }, [apiRef]);\n  const forceUpdate = React.useCallback(() => rawForceUpdate(() => apiRef.current.state), [apiRef]);\n  const publicStateApi = {\n    setState,\n    forceUpdate\n  };\n  const privateStateApi = {\n    updateControlState,\n    registerControlState\n  };\n  useGridApiMethod(apiRef, publicStateApi, 'public');\n  useGridApiMethod(apiRef, privateStateApi, 'private');\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}