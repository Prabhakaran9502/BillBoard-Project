{"ast":null,"code":"import * as React from 'react';\nimport useForkRef from '@mui/utils/useForkRef';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport useEnhancedEffect from '@mui/utils/useEnhancedEffect';\nimport useId from '@mui/utils/useId';\nimport { getSectionValueNow, getSectionValueText, parseSelectedSections } from './useField.utils';\nimport { getActiveElement } from '../../utils/utils';\nimport { usePickersTranslations } from '../../../hooks/usePickersTranslations';\nimport { useUtils } from '../useUtils';\nexport const useFieldV7TextField = params => {\n  const {\n    internalProps: {\n      disabled,\n      readOnly = false\n    },\n    forwardedProps: {\n      sectionListRef: inSectionListRef,\n      onBlur,\n      onClick,\n      onFocus,\n      onInput,\n      onPaste,\n      focused: focusedProp,\n      autoFocus = false\n    },\n    fieldValueManager,\n    applyCharacterEditing,\n    resetCharacterQuery,\n    setSelectedSections,\n    parsedSelectedSections,\n    state,\n    clearActiveSection,\n    clearValue,\n    updateSectionValue,\n    updateValueFromValueStr,\n    sectionOrder,\n    areAllSectionsEmpty,\n    sectionsValueBoundaries\n  } = params;\n  const sectionListRef = React.useRef(null);\n  const handleSectionListRef = useForkRef(inSectionListRef, sectionListRef);\n  const translations = usePickersTranslations();\n  const utils = useUtils();\n  const id = useId();\n  const [focused, setFocused] = React.useState(false);\n  const interactions = React.useMemo(() => ({\n    syncSelectionToDOM: () => {\n      if (!sectionListRef.current) {\n        return;\n      }\n\n      const selection = document.getSelection();\n\n      if (!selection) {\n        return;\n      }\n\n      if (parsedSelectedSections == null) {\n        // If the selection contains an element inside the field, we reset it.\n        if (selection.rangeCount > 0 && sectionListRef.current.getRoot().contains(selection.getRangeAt(0).startContainer)) {\n          selection.removeAllRanges();\n        }\n\n        if (focused) {\n          sectionListRef.current.getRoot().blur();\n        }\n\n        return;\n      } // On multi input range pickers we want to update selection range only for the active input\n\n\n      if (!sectionListRef.current.getRoot().contains(getActiveElement(document))) {\n        return;\n      }\n\n      const range = new window.Range();\n      let target;\n\n      if (parsedSelectedSections === 'all') {\n        target = sectionListRef.current.getRoot();\n      } else {\n        const section = state.sections[parsedSelectedSections];\n\n        if (section.type === 'empty') {\n          target = sectionListRef.current.getSectionContainer(parsedSelectedSections);\n        } else {\n          target = sectionListRef.current.getSectionContent(parsedSelectedSections);\n        }\n      }\n\n      range.selectNodeContents(target);\n      target.focus();\n      selection.removeAllRanges();\n      selection.addRange(range);\n    },\n    getActiveSectionIndexFromDOM: () => {\n      const activeElement = getActiveElement(document);\n\n      if (!activeElement || !sectionListRef.current || !sectionListRef.current.getRoot().contains(activeElement)) {\n        return null;\n      }\n\n      return sectionListRef.current.getSectionIndexFromDOMElement(activeElement);\n    },\n    focusField: function () {\n      let newSelectedSections = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n      if (!sectionListRef.current) {\n        return;\n      }\n\n      const newParsedSelectedSections = parseSelectedSections(newSelectedSections, state.sections);\n      setFocused(true);\n      sectionListRef.current.getSectionContent(newParsedSelectedSections).focus();\n    },\n    setSelectedSections: newSelectedSections => {\n      if (!sectionListRef.current) {\n        return;\n      }\n\n      const newParsedSelectedSections = parseSelectedSections(newSelectedSections, state.sections);\n      const newActiveSectionIndex = newParsedSelectedSections === 'all' ? 0 : newParsedSelectedSections;\n      setFocused(newActiveSectionIndex !== null);\n      setSelectedSections(newSelectedSections);\n    },\n    isFieldFocused: () => {\n      const activeElement = getActiveElement(document);\n      return !!sectionListRef.current && sectionListRef.current.getRoot().contains(activeElement);\n    }\n  }), [parsedSelectedSections, setSelectedSections, state.sections, focused]);\n  /**\n   * If a section content has been updated with a value we don't want to keep,\n   * Then we need to imperatively revert it (we can't let React do it because the value did not change in his internal representation).\n   */\n\n  const revertDOMSectionChange = useEventCallback(sectionIndex => {\n    if (!sectionListRef.current) {\n      return;\n    }\n\n    const section = state.sections[sectionIndex];\n    sectionListRef.current.getSectionContent(sectionIndex).innerHTML = section.value || section.placeholder;\n    interactions.syncSelectionToDOM();\n  });\n  const handleContainerClick = useEventCallback(function (event) {\n    // The click event on the clear button would propagate to the input, trigger this handler and result in a wrong section selection.\n    // We avoid this by checking if the call of `handleContainerClick` is actually intended, or a side effect.\n    if (event.isDefaultPrevented() || !sectionListRef.current) {\n      return;\n    }\n\n    setFocused(true);\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    onClick?.(event, ...args);\n\n    if (parsedSelectedSections === 'all') {\n      setTimeout(() => {\n        const cursorPosition = document.getSelection().getRangeAt(0).startOffset;\n\n        if (cursorPosition === 0) {\n          setSelectedSections(sectionOrder.startIndex);\n          return;\n        }\n\n        let sectionIndex = 0;\n        let cursorOnStartOfSection = 0;\n\n        while (cursorOnStartOfSection < cursorPosition && sectionIndex < state.sections.length) {\n          const section = state.sections[sectionIndex];\n          sectionIndex += 1;\n          cursorOnStartOfSection += `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`.length;\n        }\n\n        setSelectedSections(sectionIndex - 1);\n      });\n    } else if (!focused) {\n      setFocused(true);\n      setSelectedSections(sectionOrder.startIndex);\n    } else {\n      const hasClickedOnASection = sectionListRef.current.getRoot().contains(event.target);\n\n      if (!hasClickedOnASection) {\n        setSelectedSections(sectionOrder.startIndex);\n      }\n    }\n  });\n  const handleContainerInput = useEventCallback(event => {\n    onInput?.(event);\n\n    if (!sectionListRef.current || parsedSelectedSections !== 'all') {\n      return;\n    }\n\n    const target = event.target;\n    const keyPressed = target.textContent ?? '';\n    sectionListRef.current.getRoot().innerHTML = state.sections.map(section => `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`).join('');\n    interactions.syncSelectionToDOM();\n\n    if (keyPressed.length === 0 || keyPressed.charCodeAt(0) === 10) {\n      resetCharacterQuery();\n      clearValue();\n      setSelectedSections('all');\n    } else if (keyPressed.length > 1) {\n      updateValueFromValueStr(keyPressed);\n    } else {\n      applyCharacterEditing({\n        keyPressed,\n        sectionIndex: 0\n      });\n    }\n  });\n  const handleContainerPaste = useEventCallback(event => {\n    onPaste?.(event);\n\n    if (readOnly || parsedSelectedSections !== 'all') {\n      event.preventDefault();\n      return;\n    }\n\n    const pastedValue = event.clipboardData.getData('text');\n    event.preventDefault();\n    resetCharacterQuery();\n    updateValueFromValueStr(pastedValue);\n  });\n  const handleContainerFocus = useEventCallback(function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    onFocus?.(...args);\n\n    if (focused || !sectionListRef.current) {\n      return;\n    }\n\n    setFocused(true);\n    const isFocusInsideASection = sectionListRef.current.getSectionIndexFromDOMElement(getActiveElement(document)) != null;\n\n    if (!isFocusInsideASection) {\n      setSelectedSections(sectionOrder.startIndex);\n    }\n  });\n  const handleContainerBlur = useEventCallback(function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    onBlur?.(...args);\n    setTimeout(() => {\n      if (!sectionListRef.current) {\n        return;\n      }\n\n      const activeElement = getActiveElement(document);\n      const shouldBlur = !sectionListRef.current.getRoot().contains(activeElement);\n\n      if (shouldBlur) {\n        setFocused(false);\n        setSelectedSections(null);\n      }\n    });\n  });\n  const getInputContainerClickHandler = useEventCallback(sectionIndex => event => {\n    // The click event on the clear button would propagate to the input, trigger this handler and result in a wrong section selection.\n    // We avoid this by checking if the call to this function is actually intended, or a side effect.\n    if (event.isDefaultPrevented()) {\n      return;\n    }\n\n    setSelectedSections(sectionIndex);\n  });\n  const handleInputContentMouseUp = useEventCallback(event => {\n    // Without this, the browser will remove the selected when clicking inside an already-selected section.\n    event.preventDefault();\n  });\n  const getInputContentFocusHandler = useEventCallback(sectionIndex => () => {\n    setSelectedSections(sectionIndex);\n  });\n  const handleInputContentPaste = useEventCallback(event => {\n    // prevent default to avoid the input `onInput` handler being called\n    event.preventDefault();\n\n    if (readOnly || typeof parsedSelectedSections !== 'number') {\n      return;\n    }\n\n    const activeSection = state.sections[parsedSelectedSections];\n    const pastedValue = event.clipboardData.getData('text');\n    const lettersOnly = /^[a-zA-Z]+$/.test(pastedValue);\n    const digitsOnly = /^[0-9]+$/.test(pastedValue);\n    const digitsAndLetterOnly = /^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(pastedValue);\n    const isValidPastedValue = activeSection.contentType === 'letter' && lettersOnly || activeSection.contentType === 'digit' && digitsOnly || activeSection.contentType === 'digit-with-letter' && digitsAndLetterOnly;\n\n    if (isValidPastedValue) {\n      resetCharacterQuery();\n      updateSectionValue({\n        activeSection,\n        newSectionValue: pastedValue,\n        shouldGoToNextSection: true\n      });\n    } // If the pasted value corresponds to a single section, but not the expected type, we skip the modification\n    else if (!lettersOnly && !digitsOnly) {\n      resetCharacterQuery();\n      updateValueFromValueStr(pastedValue);\n    }\n  });\n  const handleInputContentDragOver = useEventCallback(event => {\n    event.preventDefault();\n    event.dataTransfer.dropEffect = 'none';\n  });\n  const handleInputContentInput = useEventCallback(event => {\n    if (!sectionListRef.current) {\n      return;\n    }\n\n    const target = event.target;\n    const keyPressed = target.textContent ?? '';\n    const sectionIndex = sectionListRef.current.getSectionIndexFromDOMElement(target);\n    const section = state.sections[sectionIndex];\n\n    if (readOnly || !sectionListRef.current) {\n      revertDOMSectionChange(sectionIndex);\n      return;\n    }\n\n    if (keyPressed.length === 0) {\n      if (section.value === '') {\n        revertDOMSectionChange(sectionIndex);\n        return;\n      }\n\n      const inputType = event.nativeEvent.inputType;\n\n      if (inputType === 'insertParagraph' || inputType === 'insertLineBreak') {\n        revertDOMSectionChange(sectionIndex);\n        return;\n      }\n\n      resetCharacterQuery();\n      clearActiveSection();\n      return;\n    }\n\n    applyCharacterEditing({\n      keyPressed,\n      sectionIndex\n    }); // The DOM value needs to remain the one React is expecting.\n\n    revertDOMSectionChange(sectionIndex);\n  });\n  useEnhancedEffect(() => {\n    if (!focused || !sectionListRef.current) {\n      return;\n    }\n\n    if (parsedSelectedSections === 'all') {\n      sectionListRef.current.getRoot().focus();\n    } else if (typeof parsedSelectedSections === 'number') {\n      const domElement = sectionListRef.current.getSectionContent(parsedSelectedSections);\n\n      if (domElement) {\n        domElement.focus();\n      }\n    }\n  }, [parsedSelectedSections, focused]);\n  const sectionBoundaries = React.useMemo(() => {\n    return state.sections.reduce((acc, next) => {\n      acc[next.type] = sectionsValueBoundaries[next.type]({\n        currentDate: null,\n        contentType: next.contentType,\n        format: next.format\n      });\n      return acc;\n    }, {});\n  }, [sectionsValueBoundaries, state.sections]);\n  const isContainerEditable = parsedSelectedSections === 'all';\n  const elements = React.useMemo(() => {\n    return state.sections.map((section, index) => {\n      const isEditable = !isContainerEditable && !disabled && !readOnly;\n      return {\n        container: {\n          'data-sectionindex': index,\n          onClick: getInputContainerClickHandler(index)\n        },\n        content: {\n          tabIndex: isContainerEditable || index > 0 ? -1 : 0,\n          contentEditable: !isContainerEditable && !disabled && !readOnly,\n          role: 'spinbutton',\n          id: `${id}-${section.type}`,\n          'aria-labelledby': `${id}-${section.type}`,\n          'aria-readonly': readOnly,\n          'aria-valuenow': getSectionValueNow(section, utils),\n          'aria-valuemin': sectionBoundaries[section.type].minimum,\n          'aria-valuemax': sectionBoundaries[section.type].maximum,\n          'aria-valuetext': section.value ? getSectionValueText(section, utils) : translations.empty,\n          'aria-label': translations[section.type],\n          'aria-disabled': disabled,\n          spellCheck: isEditable ? false : undefined,\n          autoCapitalize: isEditable ? 'off' : undefined,\n          autoCorrect: isEditable ? 'off' : undefined,\n          [parseInt(React.version, 10) >= 17 ? 'enterKeyHint' : 'enterkeyhint']: isEditable ? 'next' : undefined,\n          children: section.value || section.placeholder,\n          onInput: handleInputContentInput,\n          onPaste: handleInputContentPaste,\n          onFocus: getInputContentFocusHandler(index),\n          onDragOver: handleInputContentDragOver,\n          onMouseUp: handleInputContentMouseUp,\n          inputMode: section.contentType === 'letter' ? 'text' : 'numeric'\n        },\n        before: {\n          children: section.startSeparator\n        },\n        after: {\n          children: section.endSeparator\n        }\n      };\n    });\n  }, [state.sections, getInputContentFocusHandler, handleInputContentPaste, handleInputContentDragOver, handleInputContentInput, getInputContainerClickHandler, handleInputContentMouseUp, disabled, readOnly, isContainerEditable, translations, utils, sectionBoundaries, id]);\n  const handleValueStrChange = useEventCallback(event => {\n    updateValueFromValueStr(event.target.value);\n  });\n  const valueStr = React.useMemo(() => areAllSectionsEmpty ? '' : fieldValueManager.getV7HiddenInputValueFromSections(state.sections), [areAllSectionsEmpty, state.sections, fieldValueManager]);\n  React.useEffect(() => {\n    if (sectionListRef.current == null) {\n      throw new Error(['MUI X: The `sectionListRef` prop has not been initialized by `PickersSectionList`', 'You probably tried to pass a component to the `textField` slot that contains an `<input />` element instead of a `PickersSectionList`.', '', 'If you want to keep using an `<input />` HTML element for the editing, please remove the `enableAccessibleFieldDOMStructure` prop from your picker or field component:', '', '<DatePicker slots={{ textField: MyCustomTextField }} />', '', 'Learn more about the field accessible DOM structure on the MUI documentation: https://mui.com/x/react-date-pickers/fields/#fields-to-edit-a-single-element'].join('\\n'));\n    }\n\n    if (autoFocus && sectionListRef.current) {\n      sectionListRef.current.getSectionContent(sectionOrder.startIndex).focus();\n    }\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return {\n    interactions,\n    returnedValue: {\n      // Forwarded\n      autoFocus,\n      readOnly,\n      focused: focusedProp ?? focused,\n      sectionListRef: handleSectionListRef,\n      onBlur: handleContainerBlur,\n      onClick: handleContainerClick,\n      onFocus: handleContainerFocus,\n      onInput: handleContainerInput,\n      onPaste: handleContainerPaste,\n      // Additional\n      enableAccessibleFieldDOMStructure: true,\n      elements,\n      // TODO v7: Try to set to undefined when there is a section selected.\n      tabIndex: parsedSelectedSections === 0 ? -1 : 0,\n      contentEditable: isContainerEditable,\n      value: valueStr,\n      onChange: handleValueStrChange,\n      areAllSectionsEmpty\n    }\n  };\n};","map":{"version":3,"names":["React","useForkRef","useEventCallback","useEnhancedEffect","useId","getSectionValueNow","getSectionValueText","parseSelectedSections","getActiveElement","usePickersTranslations","useUtils","useFieldV7TextField","params","internalProps","disabled","readOnly","forwardedProps","sectionListRef","inSectionListRef","onBlur","onClick","onFocus","onInput","onPaste","focused","focusedProp","autoFocus","fieldValueManager","applyCharacterEditing","resetCharacterQuery","setSelectedSections","parsedSelectedSections","state","clearActiveSection","clearValue","updateSectionValue","updateValueFromValueStr","sectionOrder","areAllSectionsEmpty","sectionsValueBoundaries","useRef","handleSectionListRef","translations","utils","id","setFocused","useState","interactions","useMemo","syncSelectionToDOM","current","selection","document","getSelection","rangeCount","getRoot","contains","getRangeAt","startContainer","removeAllRanges","blur","range","window","Range","target","section","sections","type","getSectionContainer","getSectionContent","selectNodeContents","focus","addRange","getActiveSectionIndexFromDOM","activeElement","getSectionIndexFromDOMElement","focusField","newSelectedSections","newParsedSelectedSections","newActiveSectionIndex","isFieldFocused","revertDOMSectionChange","sectionIndex","innerHTML","value","placeholder","handleContainerClick","event","isDefaultPrevented","args","setTimeout","cursorPosition","startOffset","startIndex","cursorOnStartOfSection","length","startSeparator","endSeparator","hasClickedOnASection","handleContainerInput","keyPressed","textContent","map","join","charCodeAt","handleContainerPaste","preventDefault","pastedValue","clipboardData","getData","handleContainerFocus","isFocusInsideASection","handleContainerBlur","shouldBlur","getInputContainerClickHandler","handleInputContentMouseUp","getInputContentFocusHandler","handleInputContentPaste","activeSection","lettersOnly","test","digitsOnly","digitsAndLetterOnly","isValidPastedValue","contentType","newSectionValue","shouldGoToNextSection","handleInputContentDragOver","dataTransfer","dropEffect","handleInputContentInput","inputType","nativeEvent","domElement","sectionBoundaries","reduce","acc","next","currentDate","format","isContainerEditable","elements","index","isEditable","container","content","tabIndex","contentEditable","role","minimum","maximum","empty","spellCheck","undefined","autoCapitalize","autoCorrect","parseInt","version","children","onDragOver","onMouseUp","inputMode","before","after","handleValueStrChange","valueStr","getV7HiddenInputValueFromSections","useEffect","Error","returnedValue","enableAccessibleFieldDOMStructure","onChange"],"sources":["C:/Users/kb/Downloads/billBoard/billboard/node_modules/@mui/x-date-pickers/internals/hooks/useField/useFieldV7TextField.js"],"sourcesContent":["import * as React from 'react';\nimport useForkRef from '@mui/utils/useForkRef';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport useEnhancedEffect from '@mui/utils/useEnhancedEffect';\nimport useId from '@mui/utils/useId';\nimport { getSectionValueNow, getSectionValueText, parseSelectedSections } from './useField.utils';\nimport { getActiveElement } from '../../utils/utils';\nimport { usePickersTranslations } from '../../../hooks/usePickersTranslations';\nimport { useUtils } from '../useUtils';\nexport const useFieldV7TextField = params => {\n  const {\n    internalProps: {\n      disabled,\n      readOnly = false\n    },\n    forwardedProps: {\n      sectionListRef: inSectionListRef,\n      onBlur,\n      onClick,\n      onFocus,\n      onInput,\n      onPaste,\n      focused: focusedProp,\n      autoFocus = false\n    },\n    fieldValueManager,\n    applyCharacterEditing,\n    resetCharacterQuery,\n    setSelectedSections,\n    parsedSelectedSections,\n    state,\n    clearActiveSection,\n    clearValue,\n    updateSectionValue,\n    updateValueFromValueStr,\n    sectionOrder,\n    areAllSectionsEmpty,\n    sectionsValueBoundaries\n  } = params;\n  const sectionListRef = React.useRef(null);\n  const handleSectionListRef = useForkRef(inSectionListRef, sectionListRef);\n  const translations = usePickersTranslations();\n  const utils = useUtils();\n  const id = useId();\n  const [focused, setFocused] = React.useState(false);\n  const interactions = React.useMemo(() => ({\n    syncSelectionToDOM: () => {\n      if (!sectionListRef.current) {\n        return;\n      }\n      const selection = document.getSelection();\n      if (!selection) {\n        return;\n      }\n      if (parsedSelectedSections == null) {\n        // If the selection contains an element inside the field, we reset it.\n        if (selection.rangeCount > 0 && sectionListRef.current.getRoot().contains(selection.getRangeAt(0).startContainer)) {\n          selection.removeAllRanges();\n        }\n        if (focused) {\n          sectionListRef.current.getRoot().blur();\n        }\n        return;\n      }\n\n      // On multi input range pickers we want to update selection range only for the active input\n      if (!sectionListRef.current.getRoot().contains(getActiveElement(document))) {\n        return;\n      }\n      const range = new window.Range();\n      let target;\n      if (parsedSelectedSections === 'all') {\n        target = sectionListRef.current.getRoot();\n      } else {\n        const section = state.sections[parsedSelectedSections];\n        if (section.type === 'empty') {\n          target = sectionListRef.current.getSectionContainer(parsedSelectedSections);\n        } else {\n          target = sectionListRef.current.getSectionContent(parsedSelectedSections);\n        }\n      }\n      range.selectNodeContents(target);\n      target.focus();\n      selection.removeAllRanges();\n      selection.addRange(range);\n    },\n    getActiveSectionIndexFromDOM: () => {\n      const activeElement = getActiveElement(document);\n      if (!activeElement || !sectionListRef.current || !sectionListRef.current.getRoot().contains(activeElement)) {\n        return null;\n      }\n      return sectionListRef.current.getSectionIndexFromDOMElement(activeElement);\n    },\n    focusField: (newSelectedSections = 0) => {\n      if (!sectionListRef.current) {\n        return;\n      }\n      const newParsedSelectedSections = parseSelectedSections(newSelectedSections, state.sections);\n      setFocused(true);\n      sectionListRef.current.getSectionContent(newParsedSelectedSections).focus();\n    },\n    setSelectedSections: newSelectedSections => {\n      if (!sectionListRef.current) {\n        return;\n      }\n      const newParsedSelectedSections = parseSelectedSections(newSelectedSections, state.sections);\n      const newActiveSectionIndex = newParsedSelectedSections === 'all' ? 0 : newParsedSelectedSections;\n      setFocused(newActiveSectionIndex !== null);\n      setSelectedSections(newSelectedSections);\n    },\n    isFieldFocused: () => {\n      const activeElement = getActiveElement(document);\n      return !!sectionListRef.current && sectionListRef.current.getRoot().contains(activeElement);\n    }\n  }), [parsedSelectedSections, setSelectedSections, state.sections, focused]);\n\n  /**\n   * If a section content has been updated with a value we don't want to keep,\n   * Then we need to imperatively revert it (we can't let React do it because the value did not change in his internal representation).\n   */\n  const revertDOMSectionChange = useEventCallback(sectionIndex => {\n    if (!sectionListRef.current) {\n      return;\n    }\n    const section = state.sections[sectionIndex];\n    sectionListRef.current.getSectionContent(sectionIndex).innerHTML = section.value || section.placeholder;\n    interactions.syncSelectionToDOM();\n  });\n  const handleContainerClick = useEventCallback((event, ...args) => {\n    // The click event on the clear button would propagate to the input, trigger this handler and result in a wrong section selection.\n    // We avoid this by checking if the call of `handleContainerClick` is actually intended, or a side effect.\n    if (event.isDefaultPrevented() || !sectionListRef.current) {\n      return;\n    }\n    setFocused(true);\n    onClick?.(event, ...args);\n    if (parsedSelectedSections === 'all') {\n      setTimeout(() => {\n        const cursorPosition = document.getSelection().getRangeAt(0).startOffset;\n        if (cursorPosition === 0) {\n          setSelectedSections(sectionOrder.startIndex);\n          return;\n        }\n        let sectionIndex = 0;\n        let cursorOnStartOfSection = 0;\n        while (cursorOnStartOfSection < cursorPosition && sectionIndex < state.sections.length) {\n          const section = state.sections[sectionIndex];\n          sectionIndex += 1;\n          cursorOnStartOfSection += `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`.length;\n        }\n        setSelectedSections(sectionIndex - 1);\n      });\n    } else if (!focused) {\n      setFocused(true);\n      setSelectedSections(sectionOrder.startIndex);\n    } else {\n      const hasClickedOnASection = sectionListRef.current.getRoot().contains(event.target);\n      if (!hasClickedOnASection) {\n        setSelectedSections(sectionOrder.startIndex);\n      }\n    }\n  });\n  const handleContainerInput = useEventCallback(event => {\n    onInput?.(event);\n    if (!sectionListRef.current || parsedSelectedSections !== 'all') {\n      return;\n    }\n    const target = event.target;\n    const keyPressed = target.textContent ?? '';\n    sectionListRef.current.getRoot().innerHTML = state.sections.map(section => `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`).join('');\n    interactions.syncSelectionToDOM();\n    if (keyPressed.length === 0 || keyPressed.charCodeAt(0) === 10) {\n      resetCharacterQuery();\n      clearValue();\n      setSelectedSections('all');\n    } else if (keyPressed.length > 1) {\n      updateValueFromValueStr(keyPressed);\n    } else {\n      applyCharacterEditing({\n        keyPressed,\n        sectionIndex: 0\n      });\n    }\n  });\n  const handleContainerPaste = useEventCallback(event => {\n    onPaste?.(event);\n    if (readOnly || parsedSelectedSections !== 'all') {\n      event.preventDefault();\n      return;\n    }\n    const pastedValue = event.clipboardData.getData('text');\n    event.preventDefault();\n    resetCharacterQuery();\n    updateValueFromValueStr(pastedValue);\n  });\n  const handleContainerFocus = useEventCallback((...args) => {\n    onFocus?.(...args);\n    if (focused || !sectionListRef.current) {\n      return;\n    }\n    setFocused(true);\n    const isFocusInsideASection = sectionListRef.current.getSectionIndexFromDOMElement(getActiveElement(document)) != null;\n    if (!isFocusInsideASection) {\n      setSelectedSections(sectionOrder.startIndex);\n    }\n  });\n  const handleContainerBlur = useEventCallback((...args) => {\n    onBlur?.(...args);\n    setTimeout(() => {\n      if (!sectionListRef.current) {\n        return;\n      }\n      const activeElement = getActiveElement(document);\n      const shouldBlur = !sectionListRef.current.getRoot().contains(activeElement);\n      if (shouldBlur) {\n        setFocused(false);\n        setSelectedSections(null);\n      }\n    });\n  });\n  const getInputContainerClickHandler = useEventCallback(sectionIndex => event => {\n    // The click event on the clear button would propagate to the input, trigger this handler and result in a wrong section selection.\n    // We avoid this by checking if the call to this function is actually intended, or a side effect.\n    if (event.isDefaultPrevented()) {\n      return;\n    }\n    setSelectedSections(sectionIndex);\n  });\n  const handleInputContentMouseUp = useEventCallback(event => {\n    // Without this, the browser will remove the selected when clicking inside an already-selected section.\n    event.preventDefault();\n  });\n  const getInputContentFocusHandler = useEventCallback(sectionIndex => () => {\n    setSelectedSections(sectionIndex);\n  });\n  const handleInputContentPaste = useEventCallback(event => {\n    // prevent default to avoid the input `onInput` handler being called\n    event.preventDefault();\n    if (readOnly || typeof parsedSelectedSections !== 'number') {\n      return;\n    }\n    const activeSection = state.sections[parsedSelectedSections];\n    const pastedValue = event.clipboardData.getData('text');\n    const lettersOnly = /^[a-zA-Z]+$/.test(pastedValue);\n    const digitsOnly = /^[0-9]+$/.test(pastedValue);\n    const digitsAndLetterOnly = /^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(pastedValue);\n    const isValidPastedValue = activeSection.contentType === 'letter' && lettersOnly || activeSection.contentType === 'digit' && digitsOnly || activeSection.contentType === 'digit-with-letter' && digitsAndLetterOnly;\n    if (isValidPastedValue) {\n      resetCharacterQuery();\n      updateSectionValue({\n        activeSection,\n        newSectionValue: pastedValue,\n        shouldGoToNextSection: true\n      });\n    }\n    // If the pasted value corresponds to a single section, but not the expected type, we skip the modification\n    else if (!lettersOnly && !digitsOnly) {\n      resetCharacterQuery();\n      updateValueFromValueStr(pastedValue);\n    }\n  });\n  const handleInputContentDragOver = useEventCallback(event => {\n    event.preventDefault();\n    event.dataTransfer.dropEffect = 'none';\n  });\n  const handleInputContentInput = useEventCallback(event => {\n    if (!sectionListRef.current) {\n      return;\n    }\n    const target = event.target;\n    const keyPressed = target.textContent ?? '';\n    const sectionIndex = sectionListRef.current.getSectionIndexFromDOMElement(target);\n    const section = state.sections[sectionIndex];\n    if (readOnly || !sectionListRef.current) {\n      revertDOMSectionChange(sectionIndex);\n      return;\n    }\n    if (keyPressed.length === 0) {\n      if (section.value === '') {\n        revertDOMSectionChange(sectionIndex);\n        return;\n      }\n      const inputType = event.nativeEvent.inputType;\n      if (inputType === 'insertParagraph' || inputType === 'insertLineBreak') {\n        revertDOMSectionChange(sectionIndex);\n        return;\n      }\n      resetCharacterQuery();\n      clearActiveSection();\n      return;\n    }\n    applyCharacterEditing({\n      keyPressed,\n      sectionIndex\n    });\n\n    // The DOM value needs to remain the one React is expecting.\n    revertDOMSectionChange(sectionIndex);\n  });\n  useEnhancedEffect(() => {\n    if (!focused || !sectionListRef.current) {\n      return;\n    }\n    if (parsedSelectedSections === 'all') {\n      sectionListRef.current.getRoot().focus();\n    } else if (typeof parsedSelectedSections === 'number') {\n      const domElement = sectionListRef.current.getSectionContent(parsedSelectedSections);\n      if (domElement) {\n        domElement.focus();\n      }\n    }\n  }, [parsedSelectedSections, focused]);\n  const sectionBoundaries = React.useMemo(() => {\n    return state.sections.reduce((acc, next) => {\n      acc[next.type] = sectionsValueBoundaries[next.type]({\n        currentDate: null,\n        contentType: next.contentType,\n        format: next.format\n      });\n      return acc;\n    }, {});\n  }, [sectionsValueBoundaries, state.sections]);\n  const isContainerEditable = parsedSelectedSections === 'all';\n  const elements = React.useMemo(() => {\n    return state.sections.map((section, index) => {\n      const isEditable = !isContainerEditable && !disabled && !readOnly;\n      return {\n        container: {\n          'data-sectionindex': index,\n          onClick: getInputContainerClickHandler(index)\n        },\n        content: {\n          tabIndex: isContainerEditable || index > 0 ? -1 : 0,\n          contentEditable: !isContainerEditable && !disabled && !readOnly,\n          role: 'spinbutton',\n          id: `${id}-${section.type}`,\n          'aria-labelledby': `${id}-${section.type}`,\n          'aria-readonly': readOnly,\n          'aria-valuenow': getSectionValueNow(section, utils),\n          'aria-valuemin': sectionBoundaries[section.type].minimum,\n          'aria-valuemax': sectionBoundaries[section.type].maximum,\n          'aria-valuetext': section.value ? getSectionValueText(section, utils) : translations.empty,\n          'aria-label': translations[section.type],\n          'aria-disabled': disabled,\n          spellCheck: isEditable ? false : undefined,\n          autoCapitalize: isEditable ? 'off' : undefined,\n          autoCorrect: isEditable ? 'off' : undefined,\n          [parseInt(React.version, 10) >= 17 ? 'enterKeyHint' : 'enterkeyhint']: isEditable ? 'next' : undefined,\n          children: section.value || section.placeholder,\n          onInput: handleInputContentInput,\n          onPaste: handleInputContentPaste,\n          onFocus: getInputContentFocusHandler(index),\n          onDragOver: handleInputContentDragOver,\n          onMouseUp: handleInputContentMouseUp,\n          inputMode: section.contentType === 'letter' ? 'text' : 'numeric'\n        },\n        before: {\n          children: section.startSeparator\n        },\n        after: {\n          children: section.endSeparator\n        }\n      };\n    });\n  }, [state.sections, getInputContentFocusHandler, handleInputContentPaste, handleInputContentDragOver, handleInputContentInput, getInputContainerClickHandler, handleInputContentMouseUp, disabled, readOnly, isContainerEditable, translations, utils, sectionBoundaries, id]);\n  const handleValueStrChange = useEventCallback(event => {\n    updateValueFromValueStr(event.target.value);\n  });\n  const valueStr = React.useMemo(() => areAllSectionsEmpty ? '' : fieldValueManager.getV7HiddenInputValueFromSections(state.sections), [areAllSectionsEmpty, state.sections, fieldValueManager]);\n  React.useEffect(() => {\n    if (sectionListRef.current == null) {\n      throw new Error(['MUI X: The `sectionListRef` prop has not been initialized by `PickersSectionList`', 'You probably tried to pass a component to the `textField` slot that contains an `<input />` element instead of a `PickersSectionList`.', '', 'If you want to keep using an `<input />` HTML element for the editing, please remove the `enableAccessibleFieldDOMStructure` prop from your picker or field component:', '', '<DatePicker slots={{ textField: MyCustomTextField }} />', '', 'Learn more about the field accessible DOM structure on the MUI documentation: https://mui.com/x/react-date-pickers/fields/#fields-to-edit-a-single-element'].join('\\n'));\n    }\n    if (autoFocus && sectionListRef.current) {\n      sectionListRef.current.getSectionContent(sectionOrder.startIndex).focus();\n    }\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return {\n    interactions,\n    returnedValue: {\n      // Forwarded\n      autoFocus,\n      readOnly,\n      focused: focusedProp ?? focused,\n      sectionListRef: handleSectionListRef,\n      onBlur: handleContainerBlur,\n      onClick: handleContainerClick,\n      onFocus: handleContainerFocus,\n      onInput: handleContainerInput,\n      onPaste: handleContainerPaste,\n      // Additional\n      enableAccessibleFieldDOMStructure: true,\n      elements,\n      // TODO v7: Try to set to undefined when there is a section selected.\n      tabIndex: parsedSelectedSections === 0 ? -1 : 0,\n      contentEditable: isContainerEditable,\n      value: valueStr,\n      onChange: handleValueStrChange,\n      areAllSectionsEmpty\n    }\n  };\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}