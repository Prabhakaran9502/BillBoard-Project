{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridRowCountSelector, gridRowsLookupSelector, gridRowTreeSelector, gridRowGroupingNameSelector, gridRowTreeDepthsSelector, gridDataRowIdsSelector, gridRowsDataRowIdToIdLookupSelector, gridRowMaximumTreeDepthSelector } from './gridRowsSelector';\nimport { useTimeout } from '../../utils/useTimeout';\nimport { GridSignature, useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { gridSortedRowIdsSelector } from '../sorting/gridSortingSelector';\nimport { gridFilteredRowsLookupSelector } from '../filter/gridFilterSelector';\nimport { getTreeNodeDescendants, createRowsInternalCache, getRowsStateFromCache, isAutoGeneratedRow, GRID_ROOT_GROUP_ID, GRID_ID_AUTOGENERATED, updateCacheWithNewRows, getTopLevelRowCount, getRowIdFromRowModel } from './gridRowsUtils';\nimport { useGridRegisterPipeApplier } from '../../core/pipeProcessing';\nexport const rowsStateInitializer = (state, props, apiRef) => {\n  apiRef.current.caches.rows = createRowsInternalCache({\n    rows: props.rows,\n    getRowId: props.getRowId,\n    loading: props.loading,\n    rowCount: props.rowCount\n  });\n  return _extends({}, state, {\n    rows: getRowsStateFromCache({\n      apiRef,\n      rowCountProp: props.rowCount,\n      loadingProp: props.loading,\n      previousTree: null,\n      previousTreeDepths: null\n    })\n  });\n};\nexport const useGridRows = (apiRef, props) => {\n  if (process.env.NODE_ENV !== 'production') {\n    try {\n      // Freeze the `rows` prop so developers have a fast failure if they try to use Array.prototype.push().\n      Object.freeze(props.rows);\n    } catch (error) {// Sometimes, it's impossible to freeze, so we give up on it.\n    }\n  }\n\n  const logger = useGridLogger(apiRef, 'useGridRows');\n  const currentPage = useGridVisibleRows(apiRef, props);\n  const lastUpdateMs = React.useRef(Date.now());\n  const lastRowCount = React.useRef(props.rowCount);\n  const timeout = useTimeout();\n  const getRow = React.useCallback(id => {\n    const model = gridRowsLookupSelector(apiRef)[id];\n\n    if (model) {\n      return model;\n    }\n\n    const node = apiRef.current.getRowNode(id);\n\n    if (node && isAutoGeneratedRow(node)) {\n      return {\n        [GRID_ID_AUTOGENERATED]: id\n      };\n    }\n\n    return null;\n  }, [apiRef]);\n  const getRowIdProp = props.getRowId;\n  const getRowId = React.useCallback(row => {\n    if (GRID_ID_AUTOGENERATED in row) {\n      return row[GRID_ID_AUTOGENERATED];\n    }\n\n    if (getRowIdProp) {\n      return getRowIdProp(row);\n    }\n\n    return row.id;\n  }, [getRowIdProp]);\n  const lookup = React.useMemo(() => currentPage.rows.reduce((acc, _ref, index) => {\n    let {\n      id\n    } = _ref;\n    acc[id] = index;\n    return acc;\n  }, {}), [currentPage.rows]);\n  const throttledRowsChange = React.useCallback(_ref2 => {\n    let {\n      cache,\n      throttle\n    } = _ref2;\n\n    const run = () => {\n      lastUpdateMs.current = Date.now();\n      apiRef.current.setState(state => _extends({}, state, {\n        rows: getRowsStateFromCache({\n          apiRef,\n          rowCountProp: props.rowCount,\n          loadingProp: props.loading,\n          previousTree: gridRowTreeSelector(apiRef),\n          previousTreeDepths: gridRowTreeDepthsSelector(apiRef)\n        })\n      }));\n      apiRef.current.publishEvent('rowsSet');\n      apiRef.current.forceUpdate();\n    };\n\n    timeout.clear();\n    apiRef.current.caches.rows = cache;\n\n    if (!throttle) {\n      run();\n      return;\n    }\n\n    const throttleRemainingTimeMs = props.throttleRowsMs - (Date.now() - lastUpdateMs.current);\n\n    if (throttleRemainingTimeMs > 0) {\n      timeout.start(throttleRemainingTimeMs, run);\n      return;\n    }\n\n    run();\n  }, [props.throttleRowsMs, props.rowCount, props.loading, apiRef, timeout]);\n  /**\n   * API METHODS\n   */\n\n  const setRows = React.useCallback(rows => {\n    logger.debug(`Updating all rows, new length ${rows.length}`);\n    const cache = createRowsInternalCache({\n      rows,\n      getRowId: props.getRowId,\n      loading: props.loading,\n      rowCount: props.rowCount\n    });\n    const prevCache = apiRef.current.caches.rows;\n    cache.rowsBeforePartialUpdates = prevCache.rowsBeforePartialUpdates;\n    throttledRowsChange({\n      cache,\n      throttle: true\n    });\n  }, [logger, props.getRowId, props.loading, props.rowCount, throttledRowsChange, apiRef]);\n  const updateRows = React.useCallback(updates => {\n    if (props.signature === GridSignature.DataGrid && updates.length > 1) {\n      throw new Error(['MUI X: You cannot update several rows at once in `apiRef.current.updateRows` on the DataGrid.', 'You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature.'].join('\\n'));\n    }\n\n    const nonPinnedRowsUpdates = [];\n    updates.forEach(update => {\n      const id = getRowIdFromRowModel(update, props.getRowId, 'A row was provided without id when calling updateRows():');\n      const rowNode = apiRef.current.getRowNode(id);\n\n      if (rowNode?.type === 'pinnedRow') {\n        // @ts-ignore because otherwise `release:build` doesn't work\n        const pinnedRowsCache = apiRef.current.caches.pinnedRows;\n        const prevModel = pinnedRowsCache.idLookup[id];\n\n        if (prevModel) {\n          pinnedRowsCache.idLookup[id] = _extends({}, prevModel, update);\n        }\n      } else {\n        nonPinnedRowsUpdates.push(update);\n      }\n    });\n    const cache = updateCacheWithNewRows({\n      updates: nonPinnedRowsUpdates,\n      getRowId: props.getRowId,\n      previousCache: apiRef.current.caches.rows\n    });\n    throttledRowsChange({\n      cache,\n      throttle: true\n    });\n  }, [props.signature, props.getRowId, throttledRowsChange, apiRef]);\n  const getRowModels = React.useCallback(() => {\n    const dataRows = gridDataRowIdsSelector(apiRef);\n    const idRowsLookup = gridRowsLookupSelector(apiRef);\n    return new Map(dataRows.map(id => [id, idRowsLookup[id] ?? {}]));\n  }, [apiRef]);\n  const getRowsCount = React.useCallback(() => gridRowCountSelector(apiRef), [apiRef]);\n  const getAllRowIds = React.useCallback(() => gridDataRowIdsSelector(apiRef), [apiRef]);\n  const getRowIndexRelativeToVisibleRows = React.useCallback(id => lookup[id], [lookup]);\n  const setRowChildrenExpansion = React.useCallback((id, isExpanded) => {\n    const currentNode = apiRef.current.getRowNode(id);\n\n    if (!currentNode) {\n      throw new Error(`MUI X: No row with id #${id} found.`);\n    }\n\n    if (currentNode.type !== 'group') {\n      throw new Error('MUI X: Only group nodes can be expanded or collapsed.');\n    }\n\n    const newNode = _extends({}, currentNode, {\n      childrenExpanded: isExpanded\n    });\n\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          tree: _extends({}, state.rows.tree, {\n            [id]: newNode\n          })\n        })\n      });\n    });\n    apiRef.current.forceUpdate();\n    apiRef.current.publishEvent('rowExpansionChange', newNode);\n  }, [apiRef]);\n  const getRowNode = React.useCallback(id => gridRowTreeSelector(apiRef)[id] ?? null, [apiRef]);\n  const getRowGroupChildren = React.useCallback(_ref3 => {\n    let {\n      skipAutoGeneratedRows = true,\n      groupId,\n      applySorting,\n      applyFiltering\n    } = _ref3;\n    const tree = gridRowTreeSelector(apiRef);\n    let children;\n\n    if (applySorting) {\n      const groupNode = tree[groupId];\n\n      if (!groupNode) {\n        return [];\n      }\n\n      const sortedRowIds = gridSortedRowIdsSelector(apiRef);\n      children = [];\n      const startIndex = sortedRowIds.findIndex(id => id === groupId) + 1;\n\n      for (let index = startIndex; index < sortedRowIds.length && tree[sortedRowIds[index]].depth > groupNode.depth; index += 1) {\n        const id = sortedRowIds[index];\n\n        if (!skipAutoGeneratedRows || !isAutoGeneratedRow(tree[id])) {\n          children.push(id);\n        }\n      }\n    } else {\n      children = getTreeNodeDescendants(tree, groupId, skipAutoGeneratedRows);\n    }\n\n    if (applyFiltering) {\n      const filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef);\n      children = children.filter(childId => filteredRowsLookup[childId] !== false);\n    }\n\n    return children;\n  }, [apiRef]);\n  const setRowIndex = React.useCallback((rowId, targetIndex) => {\n    const node = apiRef.current.getRowNode(rowId);\n\n    if (!node) {\n      throw new Error(`MUI X: No row with id #${rowId} found.`);\n    }\n\n    if (node.parent !== GRID_ROOT_GROUP_ID) {\n      throw new Error(`MUI X: The row reordering do not support reordering of grouped rows yet.`);\n    }\n\n    if (node.type !== 'leaf') {\n      throw new Error(`MUI X: The row reordering do not support reordering of footer or grouping rows.`);\n    }\n\n    apiRef.current.setState(state => {\n      const group = gridRowTreeSelector(state, apiRef.current.instanceId)[GRID_ROOT_GROUP_ID];\n      const allRows = group.children;\n      const oldIndex = allRows.findIndex(row => row === rowId);\n\n      if (oldIndex === -1 || oldIndex === targetIndex) {\n        return state;\n      }\n\n      logger.debug(`Moving row ${rowId} to index ${targetIndex}`);\n      const updatedRows = [...allRows];\n      updatedRows.splice(targetIndex, 0, updatedRows.splice(oldIndex, 1)[0]);\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          tree: _extends({}, state.rows.tree, {\n            [GRID_ROOT_GROUP_ID]: _extends({}, group, {\n              children: updatedRows\n            })\n          })\n        })\n      });\n    });\n    apiRef.current.publishEvent('rowsSet');\n  }, [apiRef, logger]);\n  const replaceRows = React.useCallback((firstRowToRender, newRows) => {\n    if (props.signature === GridSignature.DataGrid && newRows.length > 1) {\n      throw new Error(['MUI X: You cannot replace rows using `apiRef.current.unstable_replaceRows` on the DataGrid.', 'You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature.'].join('\\n'));\n    }\n\n    if (newRows.length === 0) {\n      return;\n    }\n\n    const treeDepth = gridRowMaximumTreeDepthSelector(apiRef);\n\n    if (treeDepth > 1) {\n      throw new Error('`apiRef.current.unstable_replaceRows` is not compatible with tree data and row grouping');\n    }\n\n    const tree = _extends({}, gridRowTreeSelector(apiRef));\n\n    const dataRowIdToModelLookup = _extends({}, gridRowsLookupSelector(apiRef));\n\n    const dataRowIdToIdLookup = _extends({}, gridRowsDataRowIdToIdLookupSelector(apiRef));\n\n    const rootGroup = tree[GRID_ROOT_GROUP_ID];\n    const rootGroupChildren = [...rootGroup.children];\n    const seenIds = new Set();\n\n    for (let i = 0; i < newRows.length; i += 1) {\n      const rowModel = newRows[i];\n      const rowId = getRowIdFromRowModel(rowModel, props.getRowId, 'A row was provided without id when calling replaceRows().');\n      const [removedRowId] = rootGroupChildren.splice(firstRowToRender + i, 1, rowId);\n\n      if (!seenIds.has(removedRowId)) {\n        delete dataRowIdToModelLookup[removedRowId];\n        delete dataRowIdToIdLookup[removedRowId];\n        delete tree[removedRowId];\n      }\n\n      const rowTreeNodeConfig = {\n        id: rowId,\n        depth: 0,\n        parent: GRID_ROOT_GROUP_ID,\n        type: 'leaf',\n        groupingKey: null\n      };\n      dataRowIdToModelLookup[rowId] = rowModel;\n      dataRowIdToIdLookup[rowId] = rowId;\n      tree[rowId] = rowTreeNodeConfig;\n      seenIds.add(rowId);\n    }\n\n    tree[GRID_ROOT_GROUP_ID] = _extends({}, rootGroup, {\n      children: rootGroupChildren\n    }); // Removes potential remaining skeleton rows from the dataRowIds.\n\n    const dataRowIds = rootGroupChildren.filter(childId => tree[childId]?.type === 'leaf');\n    apiRef.current.caches.rows.dataRowIdToModelLookup = dataRowIdToModelLookup;\n    apiRef.current.caches.rows.dataRowIdToIdLookup = dataRowIdToIdLookup;\n    apiRef.current.setState(state => _extends({}, state, {\n      rows: _extends({}, state.rows, {\n        dataRowIdToModelLookup,\n        dataRowIdToIdLookup,\n        dataRowIds,\n        tree\n      })\n    }));\n    apiRef.current.publishEvent('rowsSet');\n  }, [apiRef, props.signature, props.getRowId]);\n  const rowApi = {\n    getRow,\n    getRowId,\n    getRowModels,\n    getRowsCount,\n    getAllRowIds,\n    setRows,\n    updateRows,\n    getRowNode,\n    getRowIndexRelativeToVisibleRows,\n    unstable_replaceRows: replaceRows\n  };\n  const rowProApi = {\n    setRowIndex,\n    setRowChildrenExpansion,\n    getRowGroupChildren\n  };\n  /**\n   * EVENTS\n   */\n\n  const groupRows = React.useCallback(() => {\n    logger.info(`Row grouping pre-processing have changed, regenerating the row tree`);\n    let cache;\n\n    if (apiRef.current.caches.rows.rowsBeforePartialUpdates === props.rows) {\n      // The `props.rows` did not change since the last row grouping\n      // We can use the current rows cache which contains the partial updates done recently.\n      cache = _extends({}, apiRef.current.caches.rows, {\n        updates: {\n          type: 'full',\n          rows: gridDataRowIdsSelector(apiRef)\n        }\n      });\n    } else {\n      // The `props.rows` has changed since the last row grouping\n      // We must use the new `props.rows` on the new grouping\n      // This occurs because this event is triggered before the `useEffect` on the rows when both the grouping pre-processing and the rows changes on the same render\n      cache = createRowsInternalCache({\n        rows: props.rows,\n        getRowId: props.getRowId,\n        loading: props.loading,\n        rowCount: props.rowCount\n      });\n    }\n\n    throttledRowsChange({\n      cache,\n      throttle: false\n    });\n  }, [logger, apiRef, props.rows, props.getRowId, props.loading, props.rowCount, throttledRowsChange]);\n  const handleStrategyProcessorChange = React.useCallback(methodName => {\n    if (methodName === 'rowTreeCreation') {\n      groupRows();\n    }\n  }, [groupRows]);\n  const handleStrategyActivityChange = React.useCallback(() => {\n    // `rowTreeCreation` is the only processor ran when `strategyAvailabilityChange` is fired.\n    // All the other processors listen to `rowsSet` which will be published by the `groupRows` method below.\n    if (apiRef.current.getActiveStrategy('rowTree') !== gridRowGroupingNameSelector(apiRef)) {\n      groupRows();\n    }\n  }, [apiRef, groupRows]);\n  useGridApiEventHandler(apiRef, 'activeStrategyProcessorChange', handleStrategyProcessorChange);\n  useGridApiEventHandler(apiRef, 'strategyAvailabilityChange', handleStrategyActivityChange);\n  /**\n   * APPLIERS\n   */\n\n  const applyHydrateRowsProcessor = React.useCallback(() => {\n    apiRef.current.setState(state => {\n      const response = apiRef.current.unstable_applyPipeProcessors('hydrateRows', {\n        tree: gridRowTreeSelector(state, apiRef.current.instanceId),\n        treeDepths: gridRowTreeDepthsSelector(state, apiRef.current.instanceId),\n        dataRowIds: gridDataRowIdsSelector(state, apiRef.current.instanceId),\n        dataRowIdToModelLookup: gridRowsLookupSelector(state, apiRef.current.instanceId),\n        dataRowIdToIdLookup: gridRowsDataRowIdToIdLookupSelector(state, apiRef.current.instanceId)\n      });\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, response, {\n          totalTopLevelRowCount: getTopLevelRowCount({\n            tree: response.tree,\n            rowCountProp: props.rowCount\n          })\n        })\n      });\n    });\n    apiRef.current.publishEvent('rowsSet');\n    apiRef.current.forceUpdate();\n  }, [apiRef, props.rowCount]);\n  useGridRegisterPipeApplier(apiRef, 'hydrateRows', applyHydrateRowsProcessor);\n  useGridApiMethod(apiRef, rowApi, 'public');\n  useGridApiMethod(apiRef, rowProApi, props.signature === GridSignature.DataGrid ? 'private' : 'public'); // The effect do not track any value defined synchronously during the 1st render by hooks called after `useGridRows`\n  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one\n\n  const isFirstRender = React.useRef(true);\n  React.useEffect(() => {\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      return;\n    }\n\n    let isRowCountPropUpdated = false;\n\n    if (props.rowCount !== lastRowCount.current) {\n      isRowCountPropUpdated = true;\n      lastRowCount.current = props.rowCount;\n    }\n\n    const areNewRowsAlreadyInState = apiRef.current.caches.rows.rowsBeforePartialUpdates === props.rows;\n    const isNewLoadingAlreadyInState = apiRef.current.caches.rows.loadingPropBeforePartialUpdates === props.loading;\n    const isNewRowCountAlreadyInState = apiRef.current.caches.rows.rowCountPropBeforePartialUpdates === props.rowCount; // The new rows have already been applied (most likely in the `'rowGroupsPreProcessingChange'` listener)\n\n    if (areNewRowsAlreadyInState) {\n      // If the loading prop has changed, we need to update its value in the state because it won't be done by `throttledRowsChange`\n      if (!isNewLoadingAlreadyInState) {\n        apiRef.current.setState(state => _extends({}, state, {\n          rows: _extends({}, state.rows, {\n            loading: props.loading\n          })\n        }));\n        apiRef.current.caches.rows.loadingPropBeforePartialUpdates = props.loading;\n        apiRef.current.forceUpdate();\n      }\n\n      if (!isNewRowCountAlreadyInState) {\n        apiRef.current.setState(state => _extends({}, state, {\n          rows: _extends({}, state.rows, {\n            totalRowCount: Math.max(props.rowCount || 0, state.rows.totalRowCount),\n            totalTopLevelRowCount: Math.max(props.rowCount || 0, state.rows.totalTopLevelRowCount)\n          })\n        }));\n        apiRef.current.caches.rows.rowCountPropBeforePartialUpdates = props.rowCount;\n        apiRef.current.forceUpdate();\n      }\n\n      if (!isRowCountPropUpdated) {\n        return;\n      }\n    }\n\n    logger.debug(`Updating all rows, new length ${props.rows.length}`);\n    throttledRowsChange({\n      cache: createRowsInternalCache({\n        rows: props.rows,\n        getRowId: props.getRowId,\n        loading: props.loading,\n        rowCount: props.rowCount\n      }),\n      throttle: false\n    });\n  }, [props.rows, props.rowCount, props.getRowId, props.loading, logger, throttledRowsChange, apiRef]);\n};","map":{"version":3,"names":["_extends","React","useGridApiMethod","useGridLogger","gridRowCountSelector","gridRowsLookupSelector","gridRowTreeSelector","gridRowGroupingNameSelector","gridRowTreeDepthsSelector","gridDataRowIdsSelector","gridRowsDataRowIdToIdLookupSelector","gridRowMaximumTreeDepthSelector","useTimeout","GridSignature","useGridApiEventHandler","useGridVisibleRows","gridSortedRowIdsSelector","gridFilteredRowsLookupSelector","getTreeNodeDescendants","createRowsInternalCache","getRowsStateFromCache","isAutoGeneratedRow","GRID_ROOT_GROUP_ID","GRID_ID_AUTOGENERATED","updateCacheWithNewRows","getTopLevelRowCount","getRowIdFromRowModel","useGridRegisterPipeApplier","rowsStateInitializer","state","props","apiRef","current","caches","rows","getRowId","loading","rowCount","rowCountProp","loadingProp","previousTree","previousTreeDepths","useGridRows","process","env","NODE_ENV","Object","freeze","error","logger","currentPage","lastUpdateMs","useRef","Date","now","lastRowCount","timeout","getRow","useCallback","id","model","node","getRowNode","getRowIdProp","row","lookup","useMemo","reduce","acc","index","throttledRowsChange","cache","throttle","run","setState","publishEvent","forceUpdate","clear","throttleRemainingTimeMs","throttleRowsMs","start","setRows","debug","length","prevCache","rowsBeforePartialUpdates","updateRows","updates","signature","DataGrid","Error","join","nonPinnedRowsUpdates","forEach","update","rowNode","type","pinnedRowsCache","pinnedRows","prevModel","idLookup","push","previousCache","getRowModels","dataRows","idRowsLookup","Map","map","getRowsCount","getAllRowIds","getRowIndexRelativeToVisibleRows","setRowChildrenExpansion","isExpanded","currentNode","newNode","childrenExpanded","tree","getRowGroupChildren","skipAutoGeneratedRows","groupId","applySorting","applyFiltering","children","groupNode","sortedRowIds","startIndex","findIndex","depth","filteredRowsLookup","filter","childId","setRowIndex","rowId","targetIndex","parent","group","instanceId","allRows","oldIndex","updatedRows","splice","replaceRows","firstRowToRender","newRows","treeDepth","dataRowIdToModelLookup","dataRowIdToIdLookup","rootGroup","rootGroupChildren","seenIds","Set","i","rowModel","removedRowId","has","rowTreeNodeConfig","groupingKey","add","dataRowIds","rowApi","unstable_replaceRows","rowProApi","groupRows","info","handleStrategyProcessorChange","methodName","handleStrategyActivityChange","getActiveStrategy","applyHydrateRowsProcessor","response","unstable_applyPipeProcessors","treeDepths","totalTopLevelRowCount","isFirstRender","useEffect","isRowCountPropUpdated","areNewRowsAlreadyInState","isNewLoadingAlreadyInState","loadingPropBeforePartialUpdates","isNewRowCountAlreadyInState","rowCountPropBeforePartialUpdates","totalRowCount","Math","max"],"sources":["C:/Users/kb/node_modules/@mui/x-data-grid/hooks/features/rows/useGridRows.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridRowCountSelector, gridRowsLookupSelector, gridRowTreeSelector, gridRowGroupingNameSelector, gridRowTreeDepthsSelector, gridDataRowIdsSelector, gridRowsDataRowIdToIdLookupSelector, gridRowMaximumTreeDepthSelector } from './gridRowsSelector';\nimport { useTimeout } from '../../utils/useTimeout';\nimport { GridSignature, useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { gridSortedRowIdsSelector } from '../sorting/gridSortingSelector';\nimport { gridFilteredRowsLookupSelector } from '../filter/gridFilterSelector';\nimport { getTreeNodeDescendants, createRowsInternalCache, getRowsStateFromCache, isAutoGeneratedRow, GRID_ROOT_GROUP_ID, GRID_ID_AUTOGENERATED, updateCacheWithNewRows, getTopLevelRowCount, getRowIdFromRowModel } from './gridRowsUtils';\nimport { useGridRegisterPipeApplier } from '../../core/pipeProcessing';\nexport const rowsStateInitializer = (state, props, apiRef) => {\n  apiRef.current.caches.rows = createRowsInternalCache({\n    rows: props.rows,\n    getRowId: props.getRowId,\n    loading: props.loading,\n    rowCount: props.rowCount\n  });\n  return _extends({}, state, {\n    rows: getRowsStateFromCache({\n      apiRef,\n      rowCountProp: props.rowCount,\n      loadingProp: props.loading,\n      previousTree: null,\n      previousTreeDepths: null\n    })\n  });\n};\nexport const useGridRows = (apiRef, props) => {\n  if (process.env.NODE_ENV !== 'production') {\n    try {\n      // Freeze the `rows` prop so developers have a fast failure if they try to use Array.prototype.push().\n      Object.freeze(props.rows);\n    } catch (error) {\n      // Sometimes, it's impossible to freeze, so we give up on it.\n    }\n  }\n  const logger = useGridLogger(apiRef, 'useGridRows');\n  const currentPage = useGridVisibleRows(apiRef, props);\n  const lastUpdateMs = React.useRef(Date.now());\n  const lastRowCount = React.useRef(props.rowCount);\n  const timeout = useTimeout();\n  const getRow = React.useCallback(id => {\n    const model = gridRowsLookupSelector(apiRef)[id];\n    if (model) {\n      return model;\n    }\n    const node = apiRef.current.getRowNode(id);\n    if (node && isAutoGeneratedRow(node)) {\n      return {\n        [GRID_ID_AUTOGENERATED]: id\n      };\n    }\n    return null;\n  }, [apiRef]);\n  const getRowIdProp = props.getRowId;\n  const getRowId = React.useCallback(row => {\n    if (GRID_ID_AUTOGENERATED in row) {\n      return row[GRID_ID_AUTOGENERATED];\n    }\n    if (getRowIdProp) {\n      return getRowIdProp(row);\n    }\n    return row.id;\n  }, [getRowIdProp]);\n  const lookup = React.useMemo(() => currentPage.rows.reduce((acc, {\n    id\n  }, index) => {\n    acc[id] = index;\n    return acc;\n  }, {}), [currentPage.rows]);\n  const throttledRowsChange = React.useCallback(({\n    cache,\n    throttle\n  }) => {\n    const run = () => {\n      lastUpdateMs.current = Date.now();\n      apiRef.current.setState(state => _extends({}, state, {\n        rows: getRowsStateFromCache({\n          apiRef,\n          rowCountProp: props.rowCount,\n          loadingProp: props.loading,\n          previousTree: gridRowTreeSelector(apiRef),\n          previousTreeDepths: gridRowTreeDepthsSelector(apiRef)\n        })\n      }));\n      apiRef.current.publishEvent('rowsSet');\n      apiRef.current.forceUpdate();\n    };\n    timeout.clear();\n    apiRef.current.caches.rows = cache;\n    if (!throttle) {\n      run();\n      return;\n    }\n    const throttleRemainingTimeMs = props.throttleRowsMs - (Date.now() - lastUpdateMs.current);\n    if (throttleRemainingTimeMs > 0) {\n      timeout.start(throttleRemainingTimeMs, run);\n      return;\n    }\n    run();\n  }, [props.throttleRowsMs, props.rowCount, props.loading, apiRef, timeout]);\n\n  /**\n   * API METHODS\n   */\n  const setRows = React.useCallback(rows => {\n    logger.debug(`Updating all rows, new length ${rows.length}`);\n    const cache = createRowsInternalCache({\n      rows,\n      getRowId: props.getRowId,\n      loading: props.loading,\n      rowCount: props.rowCount\n    });\n    const prevCache = apiRef.current.caches.rows;\n    cache.rowsBeforePartialUpdates = prevCache.rowsBeforePartialUpdates;\n    throttledRowsChange({\n      cache,\n      throttle: true\n    });\n  }, [logger, props.getRowId, props.loading, props.rowCount, throttledRowsChange, apiRef]);\n  const updateRows = React.useCallback(updates => {\n    if (props.signature === GridSignature.DataGrid && updates.length > 1) {\n      throw new Error(['MUI X: You cannot update several rows at once in `apiRef.current.updateRows` on the DataGrid.', 'You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature.'].join('\\n'));\n    }\n    const nonPinnedRowsUpdates = [];\n    updates.forEach(update => {\n      const id = getRowIdFromRowModel(update, props.getRowId, 'A row was provided without id when calling updateRows():');\n      const rowNode = apiRef.current.getRowNode(id);\n      if (rowNode?.type === 'pinnedRow') {\n        // @ts-ignore because otherwise `release:build` doesn't work\n        const pinnedRowsCache = apiRef.current.caches.pinnedRows;\n        const prevModel = pinnedRowsCache.idLookup[id];\n        if (prevModel) {\n          pinnedRowsCache.idLookup[id] = _extends({}, prevModel, update);\n        }\n      } else {\n        nonPinnedRowsUpdates.push(update);\n      }\n    });\n    const cache = updateCacheWithNewRows({\n      updates: nonPinnedRowsUpdates,\n      getRowId: props.getRowId,\n      previousCache: apiRef.current.caches.rows\n    });\n    throttledRowsChange({\n      cache,\n      throttle: true\n    });\n  }, [props.signature, props.getRowId, throttledRowsChange, apiRef]);\n  const getRowModels = React.useCallback(() => {\n    const dataRows = gridDataRowIdsSelector(apiRef);\n    const idRowsLookup = gridRowsLookupSelector(apiRef);\n    return new Map(dataRows.map(id => [id, idRowsLookup[id] ?? {}]));\n  }, [apiRef]);\n  const getRowsCount = React.useCallback(() => gridRowCountSelector(apiRef), [apiRef]);\n  const getAllRowIds = React.useCallback(() => gridDataRowIdsSelector(apiRef), [apiRef]);\n  const getRowIndexRelativeToVisibleRows = React.useCallback(id => lookup[id], [lookup]);\n  const setRowChildrenExpansion = React.useCallback((id, isExpanded) => {\n    const currentNode = apiRef.current.getRowNode(id);\n    if (!currentNode) {\n      throw new Error(`MUI X: No row with id #${id} found.`);\n    }\n    if (currentNode.type !== 'group') {\n      throw new Error('MUI X: Only group nodes can be expanded or collapsed.');\n    }\n    const newNode = _extends({}, currentNode, {\n      childrenExpanded: isExpanded\n    });\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          tree: _extends({}, state.rows.tree, {\n            [id]: newNode\n          })\n        })\n      });\n    });\n    apiRef.current.forceUpdate();\n    apiRef.current.publishEvent('rowExpansionChange', newNode);\n  }, [apiRef]);\n  const getRowNode = React.useCallback(id => gridRowTreeSelector(apiRef)[id] ?? null, [apiRef]);\n  const getRowGroupChildren = React.useCallback(({\n    skipAutoGeneratedRows = true,\n    groupId,\n    applySorting,\n    applyFiltering\n  }) => {\n    const tree = gridRowTreeSelector(apiRef);\n    let children;\n    if (applySorting) {\n      const groupNode = tree[groupId];\n      if (!groupNode) {\n        return [];\n      }\n      const sortedRowIds = gridSortedRowIdsSelector(apiRef);\n      children = [];\n      const startIndex = sortedRowIds.findIndex(id => id === groupId) + 1;\n      for (let index = startIndex; index < sortedRowIds.length && tree[sortedRowIds[index]].depth > groupNode.depth; index += 1) {\n        const id = sortedRowIds[index];\n        if (!skipAutoGeneratedRows || !isAutoGeneratedRow(tree[id])) {\n          children.push(id);\n        }\n      }\n    } else {\n      children = getTreeNodeDescendants(tree, groupId, skipAutoGeneratedRows);\n    }\n    if (applyFiltering) {\n      const filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef);\n      children = children.filter(childId => filteredRowsLookup[childId] !== false);\n    }\n    return children;\n  }, [apiRef]);\n  const setRowIndex = React.useCallback((rowId, targetIndex) => {\n    const node = apiRef.current.getRowNode(rowId);\n    if (!node) {\n      throw new Error(`MUI X: No row with id #${rowId} found.`);\n    }\n    if (node.parent !== GRID_ROOT_GROUP_ID) {\n      throw new Error(`MUI X: The row reordering do not support reordering of grouped rows yet.`);\n    }\n    if (node.type !== 'leaf') {\n      throw new Error(`MUI X: The row reordering do not support reordering of footer or grouping rows.`);\n    }\n    apiRef.current.setState(state => {\n      const group = gridRowTreeSelector(state, apiRef.current.instanceId)[GRID_ROOT_GROUP_ID];\n      const allRows = group.children;\n      const oldIndex = allRows.findIndex(row => row === rowId);\n      if (oldIndex === -1 || oldIndex === targetIndex) {\n        return state;\n      }\n      logger.debug(`Moving row ${rowId} to index ${targetIndex}`);\n      const updatedRows = [...allRows];\n      updatedRows.splice(targetIndex, 0, updatedRows.splice(oldIndex, 1)[0]);\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          tree: _extends({}, state.rows.tree, {\n            [GRID_ROOT_GROUP_ID]: _extends({}, group, {\n              children: updatedRows\n            })\n          })\n        })\n      });\n    });\n    apiRef.current.publishEvent('rowsSet');\n  }, [apiRef, logger]);\n  const replaceRows = React.useCallback((firstRowToRender, newRows) => {\n    if (props.signature === GridSignature.DataGrid && newRows.length > 1) {\n      throw new Error(['MUI X: You cannot replace rows using `apiRef.current.unstable_replaceRows` on the DataGrid.', 'You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature.'].join('\\n'));\n    }\n    if (newRows.length === 0) {\n      return;\n    }\n    const treeDepth = gridRowMaximumTreeDepthSelector(apiRef);\n    if (treeDepth > 1) {\n      throw new Error('`apiRef.current.unstable_replaceRows` is not compatible with tree data and row grouping');\n    }\n    const tree = _extends({}, gridRowTreeSelector(apiRef));\n    const dataRowIdToModelLookup = _extends({}, gridRowsLookupSelector(apiRef));\n    const dataRowIdToIdLookup = _extends({}, gridRowsDataRowIdToIdLookupSelector(apiRef));\n    const rootGroup = tree[GRID_ROOT_GROUP_ID];\n    const rootGroupChildren = [...rootGroup.children];\n    const seenIds = new Set();\n    for (let i = 0; i < newRows.length; i += 1) {\n      const rowModel = newRows[i];\n      const rowId = getRowIdFromRowModel(rowModel, props.getRowId, 'A row was provided without id when calling replaceRows().');\n      const [removedRowId] = rootGroupChildren.splice(firstRowToRender + i, 1, rowId);\n      if (!seenIds.has(removedRowId)) {\n        delete dataRowIdToModelLookup[removedRowId];\n        delete dataRowIdToIdLookup[removedRowId];\n        delete tree[removedRowId];\n      }\n      const rowTreeNodeConfig = {\n        id: rowId,\n        depth: 0,\n        parent: GRID_ROOT_GROUP_ID,\n        type: 'leaf',\n        groupingKey: null\n      };\n      dataRowIdToModelLookup[rowId] = rowModel;\n      dataRowIdToIdLookup[rowId] = rowId;\n      tree[rowId] = rowTreeNodeConfig;\n      seenIds.add(rowId);\n    }\n    tree[GRID_ROOT_GROUP_ID] = _extends({}, rootGroup, {\n      children: rootGroupChildren\n    });\n\n    // Removes potential remaining skeleton rows from the dataRowIds.\n    const dataRowIds = rootGroupChildren.filter(childId => tree[childId]?.type === 'leaf');\n    apiRef.current.caches.rows.dataRowIdToModelLookup = dataRowIdToModelLookup;\n    apiRef.current.caches.rows.dataRowIdToIdLookup = dataRowIdToIdLookup;\n    apiRef.current.setState(state => _extends({}, state, {\n      rows: _extends({}, state.rows, {\n        dataRowIdToModelLookup,\n        dataRowIdToIdLookup,\n        dataRowIds,\n        tree\n      })\n    }));\n    apiRef.current.publishEvent('rowsSet');\n  }, [apiRef, props.signature, props.getRowId]);\n  const rowApi = {\n    getRow,\n    getRowId,\n    getRowModels,\n    getRowsCount,\n    getAllRowIds,\n    setRows,\n    updateRows,\n    getRowNode,\n    getRowIndexRelativeToVisibleRows,\n    unstable_replaceRows: replaceRows\n  };\n  const rowProApi = {\n    setRowIndex,\n    setRowChildrenExpansion,\n    getRowGroupChildren\n  };\n\n  /**\n   * EVENTS\n   */\n  const groupRows = React.useCallback(() => {\n    logger.info(`Row grouping pre-processing have changed, regenerating the row tree`);\n    let cache;\n    if (apiRef.current.caches.rows.rowsBeforePartialUpdates === props.rows) {\n      // The `props.rows` did not change since the last row grouping\n      // We can use the current rows cache which contains the partial updates done recently.\n      cache = _extends({}, apiRef.current.caches.rows, {\n        updates: {\n          type: 'full',\n          rows: gridDataRowIdsSelector(apiRef)\n        }\n      });\n    } else {\n      // The `props.rows` has changed since the last row grouping\n      // We must use the new `props.rows` on the new grouping\n      // This occurs because this event is triggered before the `useEffect` on the rows when both the grouping pre-processing and the rows changes on the same render\n      cache = createRowsInternalCache({\n        rows: props.rows,\n        getRowId: props.getRowId,\n        loading: props.loading,\n        rowCount: props.rowCount\n      });\n    }\n    throttledRowsChange({\n      cache,\n      throttle: false\n    });\n  }, [logger, apiRef, props.rows, props.getRowId, props.loading, props.rowCount, throttledRowsChange]);\n  const handleStrategyProcessorChange = React.useCallback(methodName => {\n    if (methodName === 'rowTreeCreation') {\n      groupRows();\n    }\n  }, [groupRows]);\n  const handleStrategyActivityChange = React.useCallback(() => {\n    // `rowTreeCreation` is the only processor ran when `strategyAvailabilityChange` is fired.\n    // All the other processors listen to `rowsSet` which will be published by the `groupRows` method below.\n    if (apiRef.current.getActiveStrategy('rowTree') !== gridRowGroupingNameSelector(apiRef)) {\n      groupRows();\n    }\n  }, [apiRef, groupRows]);\n  useGridApiEventHandler(apiRef, 'activeStrategyProcessorChange', handleStrategyProcessorChange);\n  useGridApiEventHandler(apiRef, 'strategyAvailabilityChange', handleStrategyActivityChange);\n\n  /**\n   * APPLIERS\n   */\n  const applyHydrateRowsProcessor = React.useCallback(() => {\n    apiRef.current.setState(state => {\n      const response = apiRef.current.unstable_applyPipeProcessors('hydrateRows', {\n        tree: gridRowTreeSelector(state, apiRef.current.instanceId),\n        treeDepths: gridRowTreeDepthsSelector(state, apiRef.current.instanceId),\n        dataRowIds: gridDataRowIdsSelector(state, apiRef.current.instanceId),\n        dataRowIdToModelLookup: gridRowsLookupSelector(state, apiRef.current.instanceId),\n        dataRowIdToIdLookup: gridRowsDataRowIdToIdLookupSelector(state, apiRef.current.instanceId)\n      });\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, response, {\n          totalTopLevelRowCount: getTopLevelRowCount({\n            tree: response.tree,\n            rowCountProp: props.rowCount\n          })\n        })\n      });\n    });\n    apiRef.current.publishEvent('rowsSet');\n    apiRef.current.forceUpdate();\n  }, [apiRef, props.rowCount]);\n  useGridRegisterPipeApplier(apiRef, 'hydrateRows', applyHydrateRowsProcessor);\n  useGridApiMethod(apiRef, rowApi, 'public');\n  useGridApiMethod(apiRef, rowProApi, props.signature === GridSignature.DataGrid ? 'private' : 'public');\n\n  // The effect do not track any value defined synchronously during the 1st render by hooks called after `useGridRows`\n  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one\n  const isFirstRender = React.useRef(true);\n  React.useEffect(() => {\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      return;\n    }\n    let isRowCountPropUpdated = false;\n    if (props.rowCount !== lastRowCount.current) {\n      isRowCountPropUpdated = true;\n      lastRowCount.current = props.rowCount;\n    }\n    const areNewRowsAlreadyInState = apiRef.current.caches.rows.rowsBeforePartialUpdates === props.rows;\n    const isNewLoadingAlreadyInState = apiRef.current.caches.rows.loadingPropBeforePartialUpdates === props.loading;\n    const isNewRowCountAlreadyInState = apiRef.current.caches.rows.rowCountPropBeforePartialUpdates === props.rowCount;\n\n    // The new rows have already been applied (most likely in the `'rowGroupsPreProcessingChange'` listener)\n    if (areNewRowsAlreadyInState) {\n      // If the loading prop has changed, we need to update its value in the state because it won't be done by `throttledRowsChange`\n      if (!isNewLoadingAlreadyInState) {\n        apiRef.current.setState(state => _extends({}, state, {\n          rows: _extends({}, state.rows, {\n            loading: props.loading\n          })\n        }));\n        apiRef.current.caches.rows.loadingPropBeforePartialUpdates = props.loading;\n        apiRef.current.forceUpdate();\n      }\n      if (!isNewRowCountAlreadyInState) {\n        apiRef.current.setState(state => _extends({}, state, {\n          rows: _extends({}, state.rows, {\n            totalRowCount: Math.max(props.rowCount || 0, state.rows.totalRowCount),\n            totalTopLevelRowCount: Math.max(props.rowCount || 0, state.rows.totalTopLevelRowCount)\n          })\n        }));\n        apiRef.current.caches.rows.rowCountPropBeforePartialUpdates = props.rowCount;\n        apiRef.current.forceUpdate();\n      }\n      if (!isRowCountPropUpdated) {\n        return;\n      }\n    }\n    logger.debug(`Updating all rows, new length ${props.rows.length}`);\n    throttledRowsChange({\n      cache: createRowsInternalCache({\n        rows: props.rows,\n        getRowId: props.getRowId,\n        loading: props.loading,\n        rowCount: props.rowCount\n      }),\n      throttle: false\n    });\n  }, [props.rows, props.rowCount, props.getRowId, props.loading, logger, throttledRowsChange, apiRef]);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}