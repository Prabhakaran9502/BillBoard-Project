{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { GridLogicOperator } from '../../../models';\nimport { getDefaultGridFilterModel } from './gridFilterState';\nimport { buildWarning } from '../../../utils/warning';\nimport { getPublicApiRef } from '../../../utils/getPublicApiRef';\nimport { gridColumnFieldsSelector, gridColumnLookupSelector, gridVisibleColumnFieldsSelector } from '../columns';\nlet hasEval;\n\nfunction getHasEval() {\n  if (hasEval !== undefined) {\n    return hasEval;\n  }\n\n  try {\n    hasEval = new Function('return true')();\n  } catch (_) {\n    hasEval = false;\n  }\n\n  return hasEval;\n}\n/**\n * Adds default values to the optional fields of a filter items.\n * @param {GridFilterItem} item The raw filter item.\n * @param {React.MutableRefObject<GridPrivateApiCommunity>} apiRef The API of the grid.\n * @return {GridFilterItem} The clean filter item with an uniq ID and an always-defined operator.\n * TODO: Make the typing reflect the different between GridFilterInputItem and GridFilterItem.\n */\n\n\nexport const cleanFilterItem = (item, apiRef) => {\n  const cleanItem = _extends({}, item);\n\n  if (cleanItem.id == null) {\n    cleanItem.id = Math.round(Math.random() * 1e5);\n  }\n\n  if (cleanItem.operator == null) {\n    // Selects a default operator\n    // We don't use `apiRef.current.getColumn` because it is not ready during state initialization\n    const column = gridColumnLookupSelector(apiRef)[cleanItem.field];\n    cleanItem.operator = column && column.filterOperators[0].value;\n  }\n\n  return cleanItem;\n};\nconst filterModelDisableMultiColumnsFilteringWarning = buildWarning(['MUI X: The `filterModel` can only contain a single item when the `disableMultipleColumnsFiltering` prop is set to `true`.', 'If you are using the community version of the `DataGrid`, this prop is always `true`.'], 'error');\nconst filterModelMissingItemIdWarning = buildWarning('MUI X: The `id` field is required on `filterModel.items` when you use multiple filters.', 'error');\nconst filterModelMissingItemOperatorWarning = buildWarning('MUI X: The `operator` field is required on `filterModel.items`, one or more of your filtering item has no `operator` provided.', 'error');\nexport const sanitizeFilterModel = (model, disableMultipleColumnsFiltering, apiRef) => {\n  const hasSeveralItems = model.items.length > 1;\n  let items;\n\n  if (hasSeveralItems && disableMultipleColumnsFiltering) {\n    filterModelDisableMultiColumnsFilteringWarning();\n    items = [model.items[0]];\n  } else {\n    items = model.items;\n  }\n\n  const hasItemsWithoutIds = hasSeveralItems && items.some(item => item.id == null);\n  const hasItemWithoutOperator = items.some(item => item.operator == null);\n\n  if (hasItemsWithoutIds) {\n    filterModelMissingItemIdWarning();\n  }\n\n  if (hasItemWithoutOperator) {\n    filterModelMissingItemOperatorWarning();\n  }\n\n  if (hasItemWithoutOperator || hasItemsWithoutIds) {\n    return _extends({}, model, {\n      items: items.map(item => cleanFilterItem(item, apiRef))\n    });\n  }\n\n  if (model.items !== items) {\n    return _extends({}, model, {\n      items\n    });\n  }\n\n  return model;\n};\nexport const mergeStateWithFilterModel = (filterModel, disableMultipleColumnsFiltering, apiRef) => filteringState => _extends({}, filteringState, {\n  filterModel: sanitizeFilterModel(filterModel, disableMultipleColumnsFiltering, apiRef)\n});\nexport const removeDiacritics = value => {\n  if (typeof value === 'string') {\n    return value.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '');\n  }\n\n  return value;\n};\n\nconst getFilterCallbackFromItem = (filterItem, apiRef) => {\n  if (!filterItem.field || !filterItem.operator) {\n    return null;\n  }\n\n  const column = apiRef.current.getColumn(filterItem.field);\n\n  if (!column) {\n    return null;\n  }\n\n  let parsedValue;\n\n  if (column.valueParser) {\n    const parser = column.valueParser;\n    parsedValue = Array.isArray(filterItem.value) ? filterItem.value?.map(x => parser(x, undefined, column, apiRef)) : parser(filterItem.value, undefined, column, apiRef);\n  } else {\n    parsedValue = filterItem.value;\n  }\n\n  const {\n    ignoreDiacritics\n  } = apiRef.current.rootProps;\n\n  if (ignoreDiacritics) {\n    parsedValue = removeDiacritics(parsedValue);\n  }\n\n  const newFilterItem = _extends({}, filterItem, {\n    value: parsedValue\n  });\n\n  const filterOperators = column.filterOperators;\n\n  if (!filterOperators?.length) {\n    throw new Error(`MUI X: No filter operators found for column '${column.field}'.`);\n  }\n\n  const filterOperator = filterOperators.find(operator => operator.value === newFilterItem.operator);\n\n  if (!filterOperator) {\n    throw new Error(`MUI X: No filter operator found for column '${column.field}' and operator value '${newFilterItem.operator}'.`);\n  }\n\n  const publicApiRef = getPublicApiRef(apiRef);\n  const applyFilterOnRow = filterOperator.getApplyFilterFn(newFilterItem, column);\n\n  if (typeof applyFilterOnRow !== 'function') {\n    return null;\n  }\n\n  return {\n    item: newFilterItem,\n    fn: row => {\n      let value = apiRef.current.getRowValue(row, column);\n\n      if (ignoreDiacritics) {\n        value = removeDiacritics(value);\n      }\n\n      return applyFilterOnRow(value, row, column, publicApiRef);\n    }\n  };\n};\n\nlet filterItemsApplierId = 1;\n/**\n * Generates a method to easily check if a row is matching the current filter model.\n * @param {GridFilterModel} filterModel The model with which we want to filter the rows.\n * @param {React.MutableRefObject<GridPrivateApiCommunity>} apiRef The API of the grid.\n * @returns {GridAggregatedFilterItemApplier | null} A method that checks if a row is matching the current filter model. If `null`, we consider that all the rows are matching the filters.\n */\n\nconst buildAggregatedFilterItemsApplier = (filterModel, apiRef, disableEval) => {\n  const {\n    items\n  } = filterModel;\n  const appliers = items.map(item => getFilterCallbackFromItem(item, apiRef)).filter(callback => !!callback);\n\n  if (appliers.length === 0) {\n    return null;\n  }\n\n  if (disableEval || !getHasEval()) {\n    // This is the original logic, which is used if `eval()` is not supported (aka prevented by CSP).\n    return (row, shouldApplyFilter) => {\n      const resultPerItemId = {};\n\n      for (let i = 0; i < appliers.length; i += 1) {\n        const applier = appliers[i];\n\n        if (!shouldApplyFilter || shouldApplyFilter(applier.item.field)) {\n          resultPerItemId[applier.item.id] = applier.fn(row);\n        }\n      }\n\n      return resultPerItemId;\n    };\n  } // We generate a new function with `new Function()` to avoid expensive patterns for JS engines\n  // such as a dynamic object assignment, for example `{ [dynamicKey]: value }`.\n\n\n  const filterItemCore = new Function('appliers', 'row', 'shouldApplyFilter', `\"use strict\";\n${appliers.map((applier, i) => `const shouldApply${i} = !shouldApplyFilter || shouldApplyFilter(${JSON.stringify(applier.item.field)});`).join('\\n')}\n\nconst result$$ = {\n${appliers.map((applier, i) => `  ${JSON.stringify(String(applier.item.id))}: !shouldApply${i} ? false : appliers[${i}].fn(row),`).join('\\n')}\n};\n\nreturn result$$;`.replaceAll('$$', String(filterItemsApplierId)));\n  filterItemsApplierId += 1; // Assign to the arrow function a name to help debugging\n\n  const filterItem = (row, shouldApplyItem) => filterItemCore(appliers, row, shouldApplyItem);\n\n  return filterItem;\n};\n\nexport const shouldQuickFilterExcludeHiddenColumns = filterModel => {\n  return filterModel.quickFilterExcludeHiddenColumns ?? true;\n};\n/**\n * Generates a method to easily check if a row is matching the current quick filter.\n * @param {any[]} filterModel The model with which we want to filter the rows.\n * @param {React.MutableRefObject<GridPrivateApiCommunity>} apiRef The API of the grid.\n * @returns {GridAggregatedFilterItemApplier | null} A method that checks if a row is matching the current filter model. If `null`, we consider that all the rows are matching the filters.\n */\n\nconst buildAggregatedQuickFilterApplier = (filterModel, apiRef) => {\n  const quickFilterValues = filterModel.quickFilterValues?.filter(Boolean) ?? [];\n\n  if (quickFilterValues.length === 0) {\n    return null;\n  }\n\n  const columnFields = shouldQuickFilterExcludeHiddenColumns(filterModel) ? gridVisibleColumnFieldsSelector(apiRef) : gridColumnFieldsSelector(apiRef);\n  const appliersPerField = [];\n  const {\n    ignoreDiacritics\n  } = apiRef.current.rootProps;\n  const publicApiRef = getPublicApiRef(apiRef);\n  columnFields.forEach(field => {\n    const column = apiRef.current.getColumn(field);\n    const getApplyQuickFilterFn = column?.getApplyQuickFilterFn;\n\n    if (getApplyQuickFilterFn) {\n      appliersPerField.push({\n        column,\n        appliers: quickFilterValues.map(quickFilterValue => {\n          const value = ignoreDiacritics ? removeDiacritics(quickFilterValue) : quickFilterValue;\n          return {\n            fn: getApplyQuickFilterFn(value, column, publicApiRef)\n          };\n        })\n      });\n    }\n  });\n  return function isRowMatchingQuickFilter(row, shouldApplyFilter) {\n    const result = {};\n    /* eslint-disable no-labels */\n\n    outer: for (let v = 0; v < quickFilterValues.length; v += 1) {\n      const filterValue = quickFilterValues[v];\n\n      for (let i = 0; i < appliersPerField.length; i += 1) {\n        const {\n          column,\n          appliers\n        } = appliersPerField[i];\n        const {\n          field\n        } = column;\n\n        if (shouldApplyFilter && !shouldApplyFilter(field)) {\n          continue;\n        }\n\n        const applier = appliers[v];\n        let value = apiRef.current.getRowValue(row, column);\n\n        if (applier.fn === null) {\n          continue;\n        }\n\n        if (ignoreDiacritics) {\n          value = removeDiacritics(value);\n        }\n\n        const isMatching = applier.fn(value, row, column, publicApiRef);\n\n        if (isMatching) {\n          result[filterValue] = true;\n          continue outer;\n        }\n      }\n\n      result[filterValue] = false;\n    }\n\n    return result;\n  };\n};\n\nexport const buildAggregatedFilterApplier = (filterModel, apiRef, disableEval) => {\n  const isRowMatchingFilterItems = buildAggregatedFilterItemsApplier(filterModel, apiRef, disableEval);\n  const isRowMatchingQuickFilter = buildAggregatedQuickFilterApplier(filterModel, apiRef);\n  return function isRowMatchingFilters(row, shouldApplyFilter, result) {\n    result.passingFilterItems = isRowMatchingFilterItems?.(row, shouldApplyFilter) ?? null;\n    result.passingQuickFilterValues = isRowMatchingQuickFilter?.(row, shouldApplyFilter) ?? null;\n  };\n};\n\nconst isNotNull = result => result != null;\n\nconst filterModelItems = (cache, apiRef, items) => {\n  if (!cache.cleanedFilterItems) {\n    cache.cleanedFilterItems = items.filter(item => getFilterCallbackFromItem(item, apiRef) !== null);\n  }\n\n  return cache.cleanedFilterItems;\n};\n\nexport const passFilterLogic = (allFilterItemResults, allQuickFilterResults, filterModel, apiRef, cache) => {\n  const cleanedFilterItems = filterModelItems(cache, apiRef, filterModel.items);\n  const cleanedFilterItemResults = allFilterItemResults.filter(isNotNull);\n  const cleanedQuickFilterResults = allQuickFilterResults.filter(isNotNull); // get result for filter items model\n\n  if (cleanedFilterItemResults.length > 0) {\n    // Return true if the item pass with one of the rows\n    const filterItemPredicate = item => {\n      return cleanedFilterItemResults.some(filterItemResult => filterItemResult[item.id]);\n    };\n\n    const logicOperator = filterModel.logicOperator ?? getDefaultGridFilterModel().logicOperator;\n\n    if (logicOperator === GridLogicOperator.And) {\n      const passesAllFilters = cleanedFilterItems.every(filterItemPredicate);\n\n      if (!passesAllFilters) {\n        return false;\n      }\n    } else {\n      const passesSomeFilters = cleanedFilterItems.some(filterItemPredicate);\n\n      if (!passesSomeFilters) {\n        return false;\n      }\n    }\n  } // get result for quick filter model\n\n\n  if (cleanedQuickFilterResults.length > 0 && filterModel.quickFilterValues != null) {\n    // Return true if the item pass with one of the rows\n    const quickFilterValuePredicate = value => {\n      return cleanedQuickFilterResults.some(quickFilterValueResult => quickFilterValueResult[value]);\n    };\n\n    const quickFilterLogicOperator = filterModel.quickFilterLogicOperator ?? getDefaultGridFilterModel().quickFilterLogicOperator;\n\n    if (quickFilterLogicOperator === GridLogicOperator.And) {\n      const passesAllQuickFilterValues = filterModel.quickFilterValues.every(quickFilterValuePredicate);\n\n      if (!passesAllQuickFilterValues) {\n        return false;\n      }\n    } else {\n      const passesSomeQuickFilterValues = filterModel.quickFilterValues.some(quickFilterValuePredicate);\n\n      if (!passesSomeQuickFilterValues) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n};","map":{"version":3,"names":["_extends","GridLogicOperator","getDefaultGridFilterModel","buildWarning","getPublicApiRef","gridColumnFieldsSelector","gridColumnLookupSelector","gridVisibleColumnFieldsSelector","hasEval","getHasEval","undefined","Function","_","cleanFilterItem","item","apiRef","cleanItem","id","Math","round","random","operator","column","field","filterOperators","value","filterModelDisableMultiColumnsFilteringWarning","filterModelMissingItemIdWarning","filterModelMissingItemOperatorWarning","sanitizeFilterModel","model","disableMultipleColumnsFiltering","hasSeveralItems","items","length","hasItemsWithoutIds","some","hasItemWithoutOperator","map","mergeStateWithFilterModel","filterModel","filteringState","removeDiacritics","normalize","replace","getFilterCallbackFromItem","filterItem","current","getColumn","parsedValue","valueParser","parser","Array","isArray","x","ignoreDiacritics","rootProps","newFilterItem","Error","filterOperator","find","publicApiRef","applyFilterOnRow","getApplyFilterFn","fn","row","getRowValue","filterItemsApplierId","buildAggregatedFilterItemsApplier","disableEval","appliers","filter","callback","shouldApplyFilter","resultPerItemId","i","applier","filterItemCore","JSON","stringify","join","String","replaceAll","shouldApplyItem","shouldQuickFilterExcludeHiddenColumns","quickFilterExcludeHiddenColumns","buildAggregatedQuickFilterApplier","quickFilterValues","Boolean","columnFields","appliersPerField","forEach","getApplyQuickFilterFn","push","quickFilterValue","isRowMatchingQuickFilter","result","outer","v","filterValue","isMatching","buildAggregatedFilterApplier","isRowMatchingFilterItems","isRowMatchingFilters","passingFilterItems","passingQuickFilterValues","isNotNull","filterModelItems","cache","cleanedFilterItems","passFilterLogic","allFilterItemResults","allQuickFilterResults","cleanedFilterItemResults","cleanedQuickFilterResults","filterItemPredicate","filterItemResult","logicOperator","And","passesAllFilters","every","passesSomeFilters","quickFilterValuePredicate","quickFilterValueResult","quickFilterLogicOperator","passesAllQuickFilterValues","passesSomeQuickFilterValues"],"sources":["C:/Users/kb/node_modules/@mui/x-data-grid/hooks/features/filter/gridFilterUtils.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { GridLogicOperator } from '../../../models';\nimport { getDefaultGridFilterModel } from './gridFilterState';\nimport { buildWarning } from '../../../utils/warning';\nimport { getPublicApiRef } from '../../../utils/getPublicApiRef';\nimport { gridColumnFieldsSelector, gridColumnLookupSelector, gridVisibleColumnFieldsSelector } from '../columns';\nlet hasEval;\nfunction getHasEval() {\n  if (hasEval !== undefined) {\n    return hasEval;\n  }\n  try {\n    hasEval = new Function('return true')();\n  } catch (_) {\n    hasEval = false;\n  }\n  return hasEval;\n}\n/**\n * Adds default values to the optional fields of a filter items.\n * @param {GridFilterItem} item The raw filter item.\n * @param {React.MutableRefObject<GridPrivateApiCommunity>} apiRef The API of the grid.\n * @return {GridFilterItem} The clean filter item with an uniq ID and an always-defined operator.\n * TODO: Make the typing reflect the different between GridFilterInputItem and GridFilterItem.\n */\nexport const cleanFilterItem = (item, apiRef) => {\n  const cleanItem = _extends({}, item);\n  if (cleanItem.id == null) {\n    cleanItem.id = Math.round(Math.random() * 1e5);\n  }\n  if (cleanItem.operator == null) {\n    // Selects a default operator\n    // We don't use `apiRef.current.getColumn` because it is not ready during state initialization\n    const column = gridColumnLookupSelector(apiRef)[cleanItem.field];\n    cleanItem.operator = column && column.filterOperators[0].value;\n  }\n  return cleanItem;\n};\nconst filterModelDisableMultiColumnsFilteringWarning = buildWarning(['MUI X: The `filterModel` can only contain a single item when the `disableMultipleColumnsFiltering` prop is set to `true`.', 'If you are using the community version of the `DataGrid`, this prop is always `true`.'], 'error');\nconst filterModelMissingItemIdWarning = buildWarning('MUI X: The `id` field is required on `filterModel.items` when you use multiple filters.', 'error');\nconst filterModelMissingItemOperatorWarning = buildWarning('MUI X: The `operator` field is required on `filterModel.items`, one or more of your filtering item has no `operator` provided.', 'error');\nexport const sanitizeFilterModel = (model, disableMultipleColumnsFiltering, apiRef) => {\n  const hasSeveralItems = model.items.length > 1;\n  let items;\n  if (hasSeveralItems && disableMultipleColumnsFiltering) {\n    filterModelDisableMultiColumnsFilteringWarning();\n    items = [model.items[0]];\n  } else {\n    items = model.items;\n  }\n  const hasItemsWithoutIds = hasSeveralItems && items.some(item => item.id == null);\n  const hasItemWithoutOperator = items.some(item => item.operator == null);\n  if (hasItemsWithoutIds) {\n    filterModelMissingItemIdWarning();\n  }\n  if (hasItemWithoutOperator) {\n    filterModelMissingItemOperatorWarning();\n  }\n  if (hasItemWithoutOperator || hasItemsWithoutIds) {\n    return _extends({}, model, {\n      items: items.map(item => cleanFilterItem(item, apiRef))\n    });\n  }\n  if (model.items !== items) {\n    return _extends({}, model, {\n      items\n    });\n  }\n  return model;\n};\nexport const mergeStateWithFilterModel = (filterModel, disableMultipleColumnsFiltering, apiRef) => filteringState => _extends({}, filteringState, {\n  filterModel: sanitizeFilterModel(filterModel, disableMultipleColumnsFiltering, apiRef)\n});\nexport const removeDiacritics = value => {\n  if (typeof value === 'string') {\n    return value.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '');\n  }\n  return value;\n};\nconst getFilterCallbackFromItem = (filterItem, apiRef) => {\n  if (!filterItem.field || !filterItem.operator) {\n    return null;\n  }\n  const column = apiRef.current.getColumn(filterItem.field);\n  if (!column) {\n    return null;\n  }\n  let parsedValue;\n  if (column.valueParser) {\n    const parser = column.valueParser;\n    parsedValue = Array.isArray(filterItem.value) ? filterItem.value?.map(x => parser(x, undefined, column, apiRef)) : parser(filterItem.value, undefined, column, apiRef);\n  } else {\n    parsedValue = filterItem.value;\n  }\n  const {\n    ignoreDiacritics\n  } = apiRef.current.rootProps;\n  if (ignoreDiacritics) {\n    parsedValue = removeDiacritics(parsedValue);\n  }\n  const newFilterItem = _extends({}, filterItem, {\n    value: parsedValue\n  });\n  const filterOperators = column.filterOperators;\n  if (!filterOperators?.length) {\n    throw new Error(`MUI X: No filter operators found for column '${column.field}'.`);\n  }\n  const filterOperator = filterOperators.find(operator => operator.value === newFilterItem.operator);\n  if (!filterOperator) {\n    throw new Error(`MUI X: No filter operator found for column '${column.field}' and operator value '${newFilterItem.operator}'.`);\n  }\n  const publicApiRef = getPublicApiRef(apiRef);\n  const applyFilterOnRow = filterOperator.getApplyFilterFn(newFilterItem, column);\n  if (typeof applyFilterOnRow !== 'function') {\n    return null;\n  }\n  return {\n    item: newFilterItem,\n    fn: row => {\n      let value = apiRef.current.getRowValue(row, column);\n      if (ignoreDiacritics) {\n        value = removeDiacritics(value);\n      }\n      return applyFilterOnRow(value, row, column, publicApiRef);\n    }\n  };\n};\nlet filterItemsApplierId = 1;\n\n/**\n * Generates a method to easily check if a row is matching the current filter model.\n * @param {GridFilterModel} filterModel The model with which we want to filter the rows.\n * @param {React.MutableRefObject<GridPrivateApiCommunity>} apiRef The API of the grid.\n * @returns {GridAggregatedFilterItemApplier | null} A method that checks if a row is matching the current filter model. If `null`, we consider that all the rows are matching the filters.\n */\nconst buildAggregatedFilterItemsApplier = (filterModel, apiRef, disableEval) => {\n  const {\n    items\n  } = filterModel;\n  const appliers = items.map(item => getFilterCallbackFromItem(item, apiRef)).filter(callback => !!callback);\n  if (appliers.length === 0) {\n    return null;\n  }\n  if (disableEval || !getHasEval()) {\n    // This is the original logic, which is used if `eval()` is not supported (aka prevented by CSP).\n    return (row, shouldApplyFilter) => {\n      const resultPerItemId = {};\n      for (let i = 0; i < appliers.length; i += 1) {\n        const applier = appliers[i];\n        if (!shouldApplyFilter || shouldApplyFilter(applier.item.field)) {\n          resultPerItemId[applier.item.id] = applier.fn(row);\n        }\n      }\n      return resultPerItemId;\n    };\n  }\n\n  // We generate a new function with `new Function()` to avoid expensive patterns for JS engines\n  // such as a dynamic object assignment, for example `{ [dynamicKey]: value }`.\n  const filterItemCore = new Function('appliers', 'row', 'shouldApplyFilter', `\"use strict\";\n${appliers.map((applier, i) => `const shouldApply${i} = !shouldApplyFilter || shouldApplyFilter(${JSON.stringify(applier.item.field)});`).join('\\n')}\n\nconst result$$ = {\n${appliers.map((applier, i) => `  ${JSON.stringify(String(applier.item.id))}: !shouldApply${i} ? false : appliers[${i}].fn(row),`).join('\\n')}\n};\n\nreturn result$$;`.replaceAll('$$', String(filterItemsApplierId)));\n  filterItemsApplierId += 1;\n\n  // Assign to the arrow function a name to help debugging\n  const filterItem = (row, shouldApplyItem) => filterItemCore(appliers, row, shouldApplyItem);\n  return filterItem;\n};\nexport const shouldQuickFilterExcludeHiddenColumns = filterModel => {\n  return filterModel.quickFilterExcludeHiddenColumns ?? true;\n};\n\n/**\n * Generates a method to easily check if a row is matching the current quick filter.\n * @param {any[]} filterModel The model with which we want to filter the rows.\n * @param {React.MutableRefObject<GridPrivateApiCommunity>} apiRef The API of the grid.\n * @returns {GridAggregatedFilterItemApplier | null} A method that checks if a row is matching the current filter model. If `null`, we consider that all the rows are matching the filters.\n */\nconst buildAggregatedQuickFilterApplier = (filterModel, apiRef) => {\n  const quickFilterValues = filterModel.quickFilterValues?.filter(Boolean) ?? [];\n  if (quickFilterValues.length === 0) {\n    return null;\n  }\n  const columnFields = shouldQuickFilterExcludeHiddenColumns(filterModel) ? gridVisibleColumnFieldsSelector(apiRef) : gridColumnFieldsSelector(apiRef);\n  const appliersPerField = [];\n  const {\n    ignoreDiacritics\n  } = apiRef.current.rootProps;\n  const publicApiRef = getPublicApiRef(apiRef);\n  columnFields.forEach(field => {\n    const column = apiRef.current.getColumn(field);\n    const getApplyQuickFilterFn = column?.getApplyQuickFilterFn;\n    if (getApplyQuickFilterFn) {\n      appliersPerField.push({\n        column,\n        appliers: quickFilterValues.map(quickFilterValue => {\n          const value = ignoreDiacritics ? removeDiacritics(quickFilterValue) : quickFilterValue;\n          return {\n            fn: getApplyQuickFilterFn(value, column, publicApiRef)\n          };\n        })\n      });\n    }\n  });\n  return function isRowMatchingQuickFilter(row, shouldApplyFilter) {\n    const result = {};\n\n    /* eslint-disable no-labels */\n    outer: for (let v = 0; v < quickFilterValues.length; v += 1) {\n      const filterValue = quickFilterValues[v];\n      for (let i = 0; i < appliersPerField.length; i += 1) {\n        const {\n          column,\n          appliers\n        } = appliersPerField[i];\n        const {\n          field\n        } = column;\n        if (shouldApplyFilter && !shouldApplyFilter(field)) {\n          continue;\n        }\n        const applier = appliers[v];\n        let value = apiRef.current.getRowValue(row, column);\n        if (applier.fn === null) {\n          continue;\n        }\n        if (ignoreDiacritics) {\n          value = removeDiacritics(value);\n        }\n        const isMatching = applier.fn(value, row, column, publicApiRef);\n        if (isMatching) {\n          result[filterValue] = true;\n          continue outer;\n        }\n      }\n      result[filterValue] = false;\n    }\n    return result;\n  };\n};\nexport const buildAggregatedFilterApplier = (filterModel, apiRef, disableEval) => {\n  const isRowMatchingFilterItems = buildAggregatedFilterItemsApplier(filterModel, apiRef, disableEval);\n  const isRowMatchingQuickFilter = buildAggregatedQuickFilterApplier(filterModel, apiRef);\n  return function isRowMatchingFilters(row, shouldApplyFilter, result) {\n    result.passingFilterItems = isRowMatchingFilterItems?.(row, shouldApplyFilter) ?? null;\n    result.passingQuickFilterValues = isRowMatchingQuickFilter?.(row, shouldApplyFilter) ?? null;\n  };\n};\nconst isNotNull = result => result != null;\nconst filterModelItems = (cache, apiRef, items) => {\n  if (!cache.cleanedFilterItems) {\n    cache.cleanedFilterItems = items.filter(item => getFilterCallbackFromItem(item, apiRef) !== null);\n  }\n  return cache.cleanedFilterItems;\n};\nexport const passFilterLogic = (allFilterItemResults, allQuickFilterResults, filterModel, apiRef, cache) => {\n  const cleanedFilterItems = filterModelItems(cache, apiRef, filterModel.items);\n  const cleanedFilterItemResults = allFilterItemResults.filter(isNotNull);\n  const cleanedQuickFilterResults = allQuickFilterResults.filter(isNotNull);\n\n  // get result for filter items model\n  if (cleanedFilterItemResults.length > 0) {\n    // Return true if the item pass with one of the rows\n    const filterItemPredicate = item => {\n      return cleanedFilterItemResults.some(filterItemResult => filterItemResult[item.id]);\n    };\n    const logicOperator = filterModel.logicOperator ?? getDefaultGridFilterModel().logicOperator;\n    if (logicOperator === GridLogicOperator.And) {\n      const passesAllFilters = cleanedFilterItems.every(filterItemPredicate);\n      if (!passesAllFilters) {\n        return false;\n      }\n    } else {\n      const passesSomeFilters = cleanedFilterItems.some(filterItemPredicate);\n      if (!passesSomeFilters) {\n        return false;\n      }\n    }\n  }\n\n  // get result for quick filter model\n  if (cleanedQuickFilterResults.length > 0 && filterModel.quickFilterValues != null) {\n    // Return true if the item pass with one of the rows\n    const quickFilterValuePredicate = value => {\n      return cleanedQuickFilterResults.some(quickFilterValueResult => quickFilterValueResult[value]);\n    };\n    const quickFilterLogicOperator = filterModel.quickFilterLogicOperator ?? getDefaultGridFilterModel().quickFilterLogicOperator;\n    if (quickFilterLogicOperator === GridLogicOperator.And) {\n      const passesAllQuickFilterValues = filterModel.quickFilterValues.every(quickFilterValuePredicate);\n      if (!passesAllQuickFilterValues) {\n        return false;\n      }\n    } else {\n      const passesSomeQuickFilterValues = filterModel.quickFilterValues.some(quickFilterValuePredicate);\n      if (!passesSomeQuickFilterValues) {\n        return false;\n      }\n    }\n  }\n  return true;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}