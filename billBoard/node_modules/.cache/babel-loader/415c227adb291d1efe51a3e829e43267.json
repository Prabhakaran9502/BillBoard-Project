{"ast":null,"code":"import { GRID_CHECKBOX_SELECTION_COL_DEF } from '../../../../colDef';\nimport { buildWarning } from '../../../../utils/warning';\n\nfunction sanitizeCellValue(value, csvOptions) {\n  const valueStr = typeof value === 'string' ? value : `${value}`;\n\n  if (csvOptions.shouldAppendQuotes || csvOptions.escapeFormulas) {\n    const escapedValue = valueStr.replace(/\"/g, '\"\"'); // Make sure value containing delimiter or line break won't be split into multiple cells\n\n    if ([csvOptions.delimiter, '\\n', '\\r', '\"'].some(delimiter => valueStr.includes(delimiter))) {\n      return `\"${escapedValue}\"`;\n    }\n\n    if (csvOptions.escapeFormulas) {\n      // See https://owasp.org/www-community/attacks/CSV_Injection\n      if (['=', '+', '-', '@', '\\t', '\\r'].includes(escapedValue[0])) {\n        return `'${escapedValue}`;\n      }\n    }\n\n    return escapedValue;\n  }\n\n  return valueStr;\n}\n\nexport const serializeCellValue = (cellParams, options) => {\n  const {\n    csvOptions,\n    ignoreValueFormatter\n  } = options;\n  let value;\n\n  if (ignoreValueFormatter) {\n    const columnType = cellParams.colDef.type;\n\n    if (columnType === 'number') {\n      value = String(cellParams.value);\n    } else if (columnType === 'date' || columnType === 'dateTime') {\n      value = cellParams.value?.toISOString();\n    } else if (typeof cellParams.value?.toString === 'function') {\n      value = cellParams.value.toString();\n    } else {\n      value = cellParams.value;\n    }\n  } else {\n    value = cellParams.formattedValue;\n  }\n\n  return sanitizeCellValue(value, csvOptions);\n};\nconst objectFormattedValueWarning = buildWarning(['MUI X: When the value of a field is an object or a `renderCell` is provided, the CSV export might not display the value correctly.', 'You can provide a `valueFormatter` with a string representation to be used.']);\n\nclass CSVRow {\n  constructor(options) {\n    this.options = void 0;\n    this.rowString = '';\n    this.isEmpty = true;\n    this.options = options;\n  }\n\n  addValue(value) {\n    if (!this.isEmpty) {\n      this.rowString += this.options.csvOptions.delimiter;\n    }\n\n    if (value === null || value === undefined) {\n      this.rowString += '';\n    } else if (typeof this.options.sanitizeCellValue === 'function') {\n      this.rowString += this.options.sanitizeCellValue(value, this.options.csvOptions);\n    } else {\n      this.rowString += value;\n    }\n\n    this.isEmpty = false;\n  }\n\n  getRowString() {\n    return this.rowString;\n  }\n\n}\n\nconst serializeRow = _ref => {\n  let {\n    id,\n    columns,\n    getCellParams,\n    csvOptions,\n    ignoreValueFormatter\n  } = _ref;\n  const row = new CSVRow({\n    csvOptions\n  });\n  columns.forEach(column => {\n    const cellParams = getCellParams(id, column.field);\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (String(cellParams.formattedValue) === '[object Object]') {\n        objectFormattedValueWarning();\n      }\n    }\n\n    row.addValue(serializeCellValue(cellParams, {\n      ignoreValueFormatter,\n      csvOptions\n    }));\n  });\n  return row.getRowString();\n};\n\nexport function buildCSV(options) {\n  const {\n    columns,\n    rowIds,\n    csvOptions,\n    ignoreValueFormatter,\n    apiRef\n  } = options;\n  const CSVBody = rowIds.reduce((acc, id) => `${acc}${serializeRow({\n    id,\n    columns,\n    getCellParams: apiRef.current.getCellParams,\n    ignoreValueFormatter,\n    csvOptions\n  })}\\r\\n`, '').trim();\n\n  if (!csvOptions.includeHeaders) {\n    return CSVBody;\n  }\n\n  const filteredColumns = columns.filter(column => column.field !== GRID_CHECKBOX_SELECTION_COL_DEF.field);\n  const headerRows = [];\n\n  if (csvOptions.includeColumnGroupsHeaders) {\n    const columnGroupLookup = apiRef.current.getAllGroupDetails();\n    let maxColumnGroupsDepth = 0;\n    const columnGroupPathsLookup = filteredColumns.reduce((acc, column) => {\n      const columnGroupPath = apiRef.current.getColumnGroupPath(column.field);\n      acc[column.field] = columnGroupPath;\n      maxColumnGroupsDepth = Math.max(maxColumnGroupsDepth, columnGroupPath.length);\n      return acc;\n    }, {});\n\n    for (let i = 0; i < maxColumnGroupsDepth; i += 1) {\n      const headerGroupRow = new CSVRow({\n        csvOptions,\n        sanitizeCellValue\n      });\n      headerRows.push(headerGroupRow);\n      filteredColumns.forEach(column => {\n        const columnGroupId = (columnGroupPathsLookup[column.field] || [])[i];\n        const columnGroup = columnGroupLookup[columnGroupId];\n        headerGroupRow.addValue(columnGroup ? columnGroup.headerName || columnGroup.groupId : '');\n      });\n    }\n  }\n\n  const mainHeaderRow = new CSVRow({\n    csvOptions,\n    sanitizeCellValue\n  });\n  filteredColumns.forEach(column => {\n    mainHeaderRow.addValue(column.headerName || column.field);\n  });\n  headerRows.push(mainHeaderRow);\n  const CSVHead = `${headerRows.map(row => row.getRowString()).join('\\r\\n')}\\r\\n`;\n  return `${CSVHead}${CSVBody}`.trim();\n}","map":{"version":3,"names":["GRID_CHECKBOX_SELECTION_COL_DEF","buildWarning","sanitizeCellValue","value","csvOptions","valueStr","shouldAppendQuotes","escapeFormulas","escapedValue","replace","delimiter","some","includes","serializeCellValue","cellParams","options","ignoreValueFormatter","columnType","colDef","type","String","toISOString","toString","formattedValue","objectFormattedValueWarning","CSVRow","constructor","rowString","isEmpty","addValue","undefined","getRowString","serializeRow","id","columns","getCellParams","row","forEach","column","field","process","env","NODE_ENV","buildCSV","rowIds","apiRef","CSVBody","reduce","acc","current","trim","includeHeaders","filteredColumns","filter","headerRows","includeColumnGroupsHeaders","columnGroupLookup","getAllGroupDetails","maxColumnGroupsDepth","columnGroupPathsLookup","columnGroupPath","getColumnGroupPath","Math","max","length","i","headerGroupRow","push","columnGroupId","columnGroup","headerName","groupId","mainHeaderRow","CSVHead","map","join"],"sources":["C:/Users/kb/node_modules/@mui/x-data-grid/hooks/features/export/serializers/csvSerializer.js"],"sourcesContent":["import { GRID_CHECKBOX_SELECTION_COL_DEF } from '../../../../colDef';\nimport { buildWarning } from '../../../../utils/warning';\nfunction sanitizeCellValue(value, csvOptions) {\n  const valueStr = typeof value === 'string' ? value : `${value}`;\n  if (csvOptions.shouldAppendQuotes || csvOptions.escapeFormulas) {\n    const escapedValue = valueStr.replace(/\"/g, '\"\"');\n    // Make sure value containing delimiter or line break won't be split into multiple cells\n    if ([csvOptions.delimiter, '\\n', '\\r', '\"'].some(delimiter => valueStr.includes(delimiter))) {\n      return `\"${escapedValue}\"`;\n    }\n    if (csvOptions.escapeFormulas) {\n      // See https://owasp.org/www-community/attacks/CSV_Injection\n      if (['=', '+', '-', '@', '\\t', '\\r'].includes(escapedValue[0])) {\n        return `'${escapedValue}`;\n      }\n    }\n    return escapedValue;\n  }\n  return valueStr;\n}\nexport const serializeCellValue = (cellParams, options) => {\n  const {\n    csvOptions,\n    ignoreValueFormatter\n  } = options;\n  let value;\n  if (ignoreValueFormatter) {\n    const columnType = cellParams.colDef.type;\n    if (columnType === 'number') {\n      value = String(cellParams.value);\n    } else if (columnType === 'date' || columnType === 'dateTime') {\n      value = cellParams.value?.toISOString();\n    } else if (typeof cellParams.value?.toString === 'function') {\n      value = cellParams.value.toString();\n    } else {\n      value = cellParams.value;\n    }\n  } else {\n    value = cellParams.formattedValue;\n  }\n  return sanitizeCellValue(value, csvOptions);\n};\nconst objectFormattedValueWarning = buildWarning(['MUI X: When the value of a field is an object or a `renderCell` is provided, the CSV export might not display the value correctly.', 'You can provide a `valueFormatter` with a string representation to be used.']);\nclass CSVRow {\n  constructor(options) {\n    this.options = void 0;\n    this.rowString = '';\n    this.isEmpty = true;\n    this.options = options;\n  }\n  addValue(value) {\n    if (!this.isEmpty) {\n      this.rowString += this.options.csvOptions.delimiter;\n    }\n    if (value === null || value === undefined) {\n      this.rowString += '';\n    } else if (typeof this.options.sanitizeCellValue === 'function') {\n      this.rowString += this.options.sanitizeCellValue(value, this.options.csvOptions);\n    } else {\n      this.rowString += value;\n    }\n    this.isEmpty = false;\n  }\n  getRowString() {\n    return this.rowString;\n  }\n}\nconst serializeRow = ({\n  id,\n  columns,\n  getCellParams,\n  csvOptions,\n  ignoreValueFormatter\n}) => {\n  const row = new CSVRow({\n    csvOptions\n  });\n  columns.forEach(column => {\n    const cellParams = getCellParams(id, column.field);\n    if (process.env.NODE_ENV !== 'production') {\n      if (String(cellParams.formattedValue) === '[object Object]') {\n        objectFormattedValueWarning();\n      }\n    }\n    row.addValue(serializeCellValue(cellParams, {\n      ignoreValueFormatter,\n      csvOptions\n    }));\n  });\n  return row.getRowString();\n};\nexport function buildCSV(options) {\n  const {\n    columns,\n    rowIds,\n    csvOptions,\n    ignoreValueFormatter,\n    apiRef\n  } = options;\n  const CSVBody = rowIds.reduce((acc, id) => `${acc}${serializeRow({\n    id,\n    columns,\n    getCellParams: apiRef.current.getCellParams,\n    ignoreValueFormatter,\n    csvOptions\n  })}\\r\\n`, '').trim();\n  if (!csvOptions.includeHeaders) {\n    return CSVBody;\n  }\n  const filteredColumns = columns.filter(column => column.field !== GRID_CHECKBOX_SELECTION_COL_DEF.field);\n  const headerRows = [];\n  if (csvOptions.includeColumnGroupsHeaders) {\n    const columnGroupLookup = apiRef.current.getAllGroupDetails();\n    let maxColumnGroupsDepth = 0;\n    const columnGroupPathsLookup = filteredColumns.reduce((acc, column) => {\n      const columnGroupPath = apiRef.current.getColumnGroupPath(column.field);\n      acc[column.field] = columnGroupPath;\n      maxColumnGroupsDepth = Math.max(maxColumnGroupsDepth, columnGroupPath.length);\n      return acc;\n    }, {});\n    for (let i = 0; i < maxColumnGroupsDepth; i += 1) {\n      const headerGroupRow = new CSVRow({\n        csvOptions,\n        sanitizeCellValue\n      });\n      headerRows.push(headerGroupRow);\n      filteredColumns.forEach(column => {\n        const columnGroupId = (columnGroupPathsLookup[column.field] || [])[i];\n        const columnGroup = columnGroupLookup[columnGroupId];\n        headerGroupRow.addValue(columnGroup ? columnGroup.headerName || columnGroup.groupId : '');\n      });\n    }\n  }\n  const mainHeaderRow = new CSVRow({\n    csvOptions,\n    sanitizeCellValue\n  });\n  filteredColumns.forEach(column => {\n    mainHeaderRow.addValue(column.headerName || column.field);\n  });\n  headerRows.push(mainHeaderRow);\n  const CSVHead = `${headerRows.map(row => row.getRowString()).join('\\r\\n')}\\r\\n`;\n  return `${CSVHead}${CSVBody}`.trim();\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}