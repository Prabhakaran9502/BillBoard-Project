{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.insertDataRowInTree = void 0;\n\nvar _xDataGrid = require(\"@mui/x-data-grid\");\n\nvar _utils = require(\"./utils\");\n/**\n * Inserts a data row in a tree.\n * For each steps of its path:\n * - if a node exists with the same partial path, it will register this node as the ancestor of the data row.\n * - if not, it will create an auto-generated node and register it as ancestor of the data row.\n */\n\n\nconst insertDataRowInTree = _ref => {\n  let {\n    id,\n    path,\n    updatedGroupsManager,\n    previousTree,\n    tree,\n    treeDepths,\n    onDuplicatePath,\n    isGroupExpandedByDefault,\n    defaultGroupingExpansionDepth\n  } = _ref;\n  let parentNodeId = _xDataGrid.GRID_ROOT_GROUP_ID;\n\n  for (let depth = 0; depth < path.length; depth += 1) {\n    const {\n      key,\n      field\n    } = path[depth];\n    const fieldWithDefaultValue = field ?? '__no_field__';\n    const keyWithDefaultValue = key ?? '__no_key__';\n    const existingNodeIdWithPartialPath = tree[parentNodeId].childrenFromPath?.[fieldWithDefaultValue]?.[keyWithDefaultValue.toString()]; // When we reach the last step of the path,\n    // We need to create a node for the row passed to `insertNodeInTree`\n\n    if (depth === path.length - 1) {\n      // If no node matches the full path,\n      // We create a leaf node for the data row.\n      if (existingNodeIdWithPartialPath == null) {\n        const leafNode = {\n          type: 'leaf',\n          id,\n          depth,\n          parent: parentNodeId,\n          groupingKey: key\n        };\n        updatedGroupsManager?.addAction(parentNodeId, 'insertChildren');\n        (0, _utils.insertNodeInTree)(leafNode, tree, treeDepths, previousTree);\n      } else {\n        const existingNodeWithPartialPath = tree[existingNodeIdWithPartialPath]; // If we already have an auto-generated group matching the partial path,\n        // We replace it with the node from of data row passed to `insertNodeInTree`\n\n        if (existingNodeWithPartialPath.type === 'group' && existingNodeWithPartialPath.isAutoGenerated) {\n          updatedGroupsManager?.addAction(parentNodeId, 'removeChildren');\n          updatedGroupsManager?.addAction(parentNodeId, 'insertChildren');\n          (0, _utils.updateGroupNodeIdAndAutoGenerated)({\n            tree,\n            previousTree,\n            treeDepths,\n            node: existingNodeWithPartialPath,\n            updatedNode: {\n              id,\n              isAutoGenerated: false\n            }\n          });\n        } else {\n          // If we have another row matching the partial path, then there is a duplicate in the dataset.\n          // We warn the user and skip the current row.\n          onDuplicatePath?.(existingNodeIdWithPartialPath, id, path);\n        }\n      }\n    } // For the intermediary steps of the path,\n    // We need to make sure that there is a node matching the partial path.\n    //\n    // If no node matches the partial path,\n    // We create an auto-generated group node.\n    else if (existingNodeIdWithPartialPath == null) {\n      const nodeId = (0, _utils.getGroupRowIdFromPath)(path.slice(0, depth + 1));\n      const autoGeneratedGroupNode = {\n        type: 'group',\n        id: nodeId,\n        parent: parentNodeId,\n        depth,\n        isAutoGenerated: true,\n        groupingKey: key,\n        groupingField: field,\n        children: [],\n        childrenFromPath: {},\n        childrenExpanded: false\n      };\n      updatedGroupsManager?.addAction(parentNodeId, 'insertChildren');\n      (0, _utils.insertNodeInTree)((0, _utils.updateGroupDefaultExpansion)(autoGeneratedGroupNode, defaultGroupingExpansionDepth, isGroupExpandedByDefault), tree, treeDepths, previousTree);\n      parentNodeId = nodeId;\n    } // For the intermediary steps of the path\n    // If a node matches the partial path, we use it as parent for the next step\n    else {\n      const currentGroupNode = tree[existingNodeIdWithPartialPath]; // If the node matching the partial path is not a group, we turn it into a group\n\n      if (currentGroupNode.type !== 'group') {\n        const groupNode = {\n          type: 'group',\n          id: currentGroupNode.id,\n          parent: currentGroupNode.parent,\n          depth: currentGroupNode.depth,\n          isAutoGenerated: false,\n          groupingKey: key,\n          groupingField: field,\n          children: [],\n          childrenFromPath: {},\n          childrenExpanded: false\n        };\n        tree[existingNodeIdWithPartialPath] = (0, _utils.updateGroupDefaultExpansion)(groupNode, defaultGroupingExpansionDepth, isGroupExpandedByDefault);\n      }\n\n      parentNodeId = currentGroupNode.id;\n    }\n  }\n};\n\nexports.insertDataRowInTree = insertDataRowInTree;","map":{"version":3,"names":["Object","defineProperty","exports","value","insertDataRowInTree","_xDataGrid","require","_utils","id","path","updatedGroupsManager","previousTree","tree","treeDepths","onDuplicatePath","isGroupExpandedByDefault","defaultGroupingExpansionDepth","parentNodeId","GRID_ROOT_GROUP_ID","depth","length","key","field","fieldWithDefaultValue","keyWithDefaultValue","existingNodeIdWithPartialPath","childrenFromPath","toString","leafNode","type","parent","groupingKey","addAction","insertNodeInTree","existingNodeWithPartialPath","isAutoGenerated","updateGroupNodeIdAndAutoGenerated","node","updatedNode","nodeId","getGroupRowIdFromPath","slice","autoGeneratedGroupNode","groupingField","children","childrenExpanded","updateGroupDefaultExpansion","currentGroupNode","groupNode"],"sources":["C:/Users/kb/node_modules/@mui/x-data-grid-pro/utils/tree/insertDataRowInTree.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.insertDataRowInTree = void 0;\nvar _xDataGrid = require(\"@mui/x-data-grid\");\nvar _utils = require(\"./utils\");\n/**\n * Inserts a data row in a tree.\n * For each steps of its path:\n * - if a node exists with the same partial path, it will register this node as the ancestor of the data row.\n * - if not, it will create an auto-generated node and register it as ancestor of the data row.\n */\nconst insertDataRowInTree = ({\n  id,\n  path,\n  updatedGroupsManager,\n  previousTree,\n  tree,\n  treeDepths,\n  onDuplicatePath,\n  isGroupExpandedByDefault,\n  defaultGroupingExpansionDepth\n}) => {\n  let parentNodeId = _xDataGrid.GRID_ROOT_GROUP_ID;\n  for (let depth = 0; depth < path.length; depth += 1) {\n    const {\n      key,\n      field\n    } = path[depth];\n    const fieldWithDefaultValue = field ?? '__no_field__';\n    const keyWithDefaultValue = key ?? '__no_key__';\n    const existingNodeIdWithPartialPath = tree[parentNodeId].childrenFromPath?.[fieldWithDefaultValue]?.[keyWithDefaultValue.toString()];\n\n    // When we reach the last step of the path,\n    // We need to create a node for the row passed to `insertNodeInTree`\n    if (depth === path.length - 1) {\n      // If no node matches the full path,\n      // We create a leaf node for the data row.\n      if (existingNodeIdWithPartialPath == null) {\n        const leafNode = {\n          type: 'leaf',\n          id,\n          depth,\n          parent: parentNodeId,\n          groupingKey: key\n        };\n        updatedGroupsManager?.addAction(parentNodeId, 'insertChildren');\n        (0, _utils.insertNodeInTree)(leafNode, tree, treeDepths, previousTree);\n      } else {\n        const existingNodeWithPartialPath = tree[existingNodeIdWithPartialPath];\n\n        // If we already have an auto-generated group matching the partial path,\n        // We replace it with the node from of data row passed to `insertNodeInTree`\n        if (existingNodeWithPartialPath.type === 'group' && existingNodeWithPartialPath.isAutoGenerated) {\n          updatedGroupsManager?.addAction(parentNodeId, 'removeChildren');\n          updatedGroupsManager?.addAction(parentNodeId, 'insertChildren');\n          (0, _utils.updateGroupNodeIdAndAutoGenerated)({\n            tree,\n            previousTree,\n            treeDepths,\n            node: existingNodeWithPartialPath,\n            updatedNode: {\n              id,\n              isAutoGenerated: false\n            }\n          });\n        } else {\n          // If we have another row matching the partial path, then there is a duplicate in the dataset.\n          // We warn the user and skip the current row.\n          onDuplicatePath?.(existingNodeIdWithPartialPath, id, path);\n        }\n      }\n    }\n    // For the intermediary steps of the path,\n    // We need to make sure that there is a node matching the partial path.\n    //\n    // If no node matches the partial path,\n    // We create an auto-generated group node.\n    else if (existingNodeIdWithPartialPath == null) {\n      const nodeId = (0, _utils.getGroupRowIdFromPath)(path.slice(0, depth + 1));\n      const autoGeneratedGroupNode = {\n        type: 'group',\n        id: nodeId,\n        parent: parentNodeId,\n        depth,\n        isAutoGenerated: true,\n        groupingKey: key,\n        groupingField: field,\n        children: [],\n        childrenFromPath: {},\n        childrenExpanded: false\n      };\n      updatedGroupsManager?.addAction(parentNodeId, 'insertChildren');\n      (0, _utils.insertNodeInTree)((0, _utils.updateGroupDefaultExpansion)(autoGeneratedGroupNode, defaultGroupingExpansionDepth, isGroupExpandedByDefault), tree, treeDepths, previousTree);\n      parentNodeId = nodeId;\n    }\n    // For the intermediary steps of the path\n    // If a node matches the partial path, we use it as parent for the next step\n    else {\n      const currentGroupNode = tree[existingNodeIdWithPartialPath];\n\n      // If the node matching the partial path is not a group, we turn it into a group\n      if (currentGroupNode.type !== 'group') {\n        const groupNode = {\n          type: 'group',\n          id: currentGroupNode.id,\n          parent: currentGroupNode.parent,\n          depth: currentGroupNode.depth,\n          isAutoGenerated: false,\n          groupingKey: key,\n          groupingField: field,\n          children: [],\n          childrenFromPath: {},\n          childrenExpanded: false\n        };\n        tree[existingNodeIdWithPartialPath] = (0, _utils.updateGroupDefaultExpansion)(groupNode, defaultGroupingExpansionDepth, isGroupExpandedByDefault);\n      }\n      parentNodeId = currentGroupNode.id;\n    }\n  }\n};\nexports.insertDataRowInTree = insertDataRowInTree;"],"mappings":"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"},"metadata":{},"sourceType":"script"}