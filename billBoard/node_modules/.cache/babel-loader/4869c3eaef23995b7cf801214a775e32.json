{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { randomArrayItem } from './random-generator';\nexport const addTreeDataOptionsToDemoData = function (data) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    averageChildren = 2,\n    maxDepth = 1,\n    groupingField\n  } = options;\n  const hasTreeData = maxDepth > 1 && groupingField != null;\n\n  if (!hasTreeData) {\n    return data;\n  }\n\n  if (data.rows.length > 1000) {\n    throw new Error('MUI X: useDemoData tree data mode only works up to 1000 rows.');\n  }\n\n  const rowsByTreeDepth = {};\n  const rowsCount = data.rows.length;\n  const groupingCol = data.columns.find(col => col.field === options.groupingField);\n\n  if (!groupingCol) {\n    throw new Error('MUI X: The tree data grouping field does not exist.');\n  }\n\n  data.initialState.columns.columnVisibilityModel[groupingField] = false;\n\n  for (let i = 0; i < rowsCount; i += 1) {\n    const row = data.rows[i];\n    const currentChunk = Math.floor(i * (averageChildren ** maxDepth - 1) / rowsCount) + 1;\n    const currentDepth = Math.floor(Math.log(currentChunk) / Math.log(averageChildren));\n\n    if (!rowsByTreeDepth[currentDepth]) {\n      rowsByTreeDepth[currentDepth] = {\n        rows: {},\n        rowIndexes: []\n      };\n    }\n\n    rowsByTreeDepth[currentDepth].rows[i] = {\n      value: row,\n      parentIndex: null\n    };\n    rowsByTreeDepth[currentDepth].rowIndexes.push(i);\n  }\n\n  Object.entries(rowsByTreeDepth).forEach(_ref => {\n    let [depthStr, {\n      rows\n    }] = _ref;\n    const depth = Number(depthStr);\n    Object.values(rows).forEach(row => {\n      const path = [];\n      let previousRow = null;\n\n      for (let k = depth; k >= 0; k -= 1) {\n        let rowTemp;\n\n        if (k === depth) {\n          if (depth > 0) {\n            row.parentIndex = Number(randomArrayItem(rowsByTreeDepth[depth - 1].rowIndexes));\n          }\n\n          rowTemp = row;\n        } else {\n          rowTemp = rowsByTreeDepth[k].rows[previousRow.parentIndex];\n        }\n\n        path.unshift(rowTemp.value[groupingField]);\n        previousRow = rowTemp;\n      }\n\n      row.value.path = path;\n    });\n  });\n  return _extends({}, data, {\n    groupingColDef: {\n      headerName: groupingCol.headerName ?? groupingCol.field,\n      width: 250\n    },\n    getTreeDataPath: row => row.path,\n    treeData: true\n  });\n};","map":{"version":3,"names":["_extends","randomArrayItem","addTreeDataOptionsToDemoData","data","options","averageChildren","maxDepth","groupingField","hasTreeData","rows","length","Error","rowsByTreeDepth","rowsCount","groupingCol","columns","find","col","field","initialState","columnVisibilityModel","i","row","currentChunk","Math","floor","currentDepth","log","rowIndexes","value","parentIndex","push","Object","entries","forEach","depthStr","depth","Number","values","path","previousRow","k","rowTemp","unshift","groupingColDef","headerName","width","getTreeDataPath","treeData"],"sources":["C:/Users/kb/node_modules/@mui/x-data-grid-generator/services/tree-data-generator.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { randomArrayItem } from './random-generator';\nexport const addTreeDataOptionsToDemoData = (data, options = {}) => {\n  const {\n    averageChildren = 2,\n    maxDepth = 1,\n    groupingField\n  } = options;\n  const hasTreeData = maxDepth > 1 && groupingField != null;\n  if (!hasTreeData) {\n    return data;\n  }\n  if (data.rows.length > 1000) {\n    throw new Error('MUI X: useDemoData tree data mode only works up to 1000 rows.');\n  }\n  const rowsByTreeDepth = {};\n  const rowsCount = data.rows.length;\n  const groupingCol = data.columns.find(col => col.field === options.groupingField);\n  if (!groupingCol) {\n    throw new Error('MUI X: The tree data grouping field does not exist.');\n  }\n  data.initialState.columns.columnVisibilityModel[groupingField] = false;\n  for (let i = 0; i < rowsCount; i += 1) {\n    const row = data.rows[i];\n    const currentChunk = Math.floor(i * (averageChildren ** maxDepth - 1) / rowsCount) + 1;\n    const currentDepth = Math.floor(Math.log(currentChunk) / Math.log(averageChildren));\n    if (!rowsByTreeDepth[currentDepth]) {\n      rowsByTreeDepth[currentDepth] = {\n        rows: {},\n        rowIndexes: []\n      };\n    }\n    rowsByTreeDepth[currentDepth].rows[i] = {\n      value: row,\n      parentIndex: null\n    };\n    rowsByTreeDepth[currentDepth].rowIndexes.push(i);\n  }\n  Object.entries(rowsByTreeDepth).forEach(([depthStr, {\n    rows\n  }]) => {\n    const depth = Number(depthStr);\n    Object.values(rows).forEach(row => {\n      const path = [];\n      let previousRow = null;\n      for (let k = depth; k >= 0; k -= 1) {\n        let rowTemp;\n        if (k === depth) {\n          if (depth > 0) {\n            row.parentIndex = Number(randomArrayItem(rowsByTreeDepth[depth - 1].rowIndexes));\n          }\n          rowTemp = row;\n        } else {\n          rowTemp = rowsByTreeDepth[k].rows[previousRow.parentIndex];\n        }\n        path.unshift(rowTemp.value[groupingField]);\n        previousRow = rowTemp;\n      }\n      row.value.path = path;\n    });\n  });\n  return _extends({}, data, {\n    groupingColDef: {\n      headerName: groupingCol.headerName ?? groupingCol.field,\n      width: 250\n    },\n    getTreeDataPath: row => row.path,\n    treeData: true\n  });\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}