{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useRtl } from '@mui/system/RtlProvider';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport useForkRef from '@mui/utils/useForkRef';\nimport { getActiveElement } from '../../utils/utils';\nimport { getSectionVisibleValue, isAndroid } from './useField.utils';\n\nconst cleanString = dirtyString => dirtyString.replace(/[\\u2066\\u2067\\u2068\\u2069]/g, '');\n\nexport const addPositionPropertiesToSections = (sections, localizedDigits, isRtl) => {\n  let position = 0;\n  let positionInInput = isRtl ? 1 : 0;\n  const newSections = [];\n\n  for (let i = 0; i < sections.length; i += 1) {\n    const section = sections[i];\n    const renderedValue = getSectionVisibleValue(section, isRtl ? 'input-rtl' : 'input-ltr', localizedDigits);\n    const sectionStr = `${section.startSeparator}${renderedValue}${section.endSeparator}`;\n    const sectionLength = cleanString(sectionStr).length;\n    const sectionLengthInInput = sectionStr.length; // The ...InInput values consider the unicode characters but do include them in their indexes\n\n    const cleanedValue = cleanString(renderedValue);\n    const startInInput = positionInInput + (cleanedValue === '' ? 0 : renderedValue.indexOf(cleanedValue[0])) + section.startSeparator.length;\n    const endInInput = startInInput + cleanedValue.length;\n    newSections.push(_extends({}, section, {\n      start: position,\n      end: position + sectionLength,\n      startInInput,\n      endInInput\n    }));\n    position += sectionLength; // Move position to the end of string associated to the current section\n\n    positionInInput += sectionLengthInInput;\n  }\n\n  return newSections;\n};\nexport const useFieldV6TextField = params => {\n  const isRtl = useRtl();\n  const focusTimeoutRef = React.useRef();\n  const selectionSyncTimeoutRef = React.useRef();\n  const {\n    forwardedProps: {\n      onFocus,\n      onClick,\n      onPaste,\n      onBlur,\n      inputRef: inputRefProp,\n      placeholder: inPlaceholder\n    },\n    internalProps: {\n      readOnly = false\n    },\n    parsedSelectedSections,\n    activeSectionIndex,\n    state,\n    fieldValueManager,\n    valueManager,\n    applyCharacterEditing,\n    resetCharacterQuery,\n    updateSectionValue,\n    updateValueFromValueStr,\n    clearActiveSection,\n    clearValue,\n    setTempAndroidValueStr,\n    setSelectedSections,\n    getSectionsFromValue,\n    areAllSectionsEmpty,\n    localizedDigits\n  } = params;\n  const inputRef = React.useRef(null);\n  const handleRef = useForkRef(inputRefProp, inputRef);\n  const sections = React.useMemo(() => addPositionPropertiesToSections(state.sections, localizedDigits, isRtl), [state.sections, localizedDigits, isRtl]);\n  const interactions = React.useMemo(() => ({\n    syncSelectionToDOM: () => {\n      if (!inputRef.current) {\n        return;\n      }\n\n      if (parsedSelectedSections == null) {\n        if (inputRef.current.scrollLeft) {\n          // Ensure that input content is not marked as selected.\n          // setting selection range to 0 causes issues in Safari.\n          // https://bugs.webkit.org/show_bug.cgi?id=224425\n          inputRef.current.scrollLeft = 0;\n        }\n\n        return;\n      } // On multi input range pickers we want to update selection range only for the active input\n      // This helps to avoid the focus jumping on Safari https://github.com/mui/mui-x/issues/9003\n      // because WebKit implements the `setSelectionRange` based on the spec: https://bugs.webkit.org/show_bug.cgi?id=224425\n\n\n      if (inputRef.current !== getActiveElement(document)) {\n        return;\n      } // Fix scroll jumping on iOS browser: https://github.com/mui/mui-x/issues/8321\n\n\n      const currentScrollTop = inputRef.current.scrollTop;\n\n      if (parsedSelectedSections === 'all') {\n        inputRef.current.select();\n      } else {\n        const selectedSection = sections[parsedSelectedSections];\n        const selectionStart = selectedSection.type === 'empty' ? selectedSection.startInInput - selectedSection.startSeparator.length : selectedSection.startInInput;\n        const selectionEnd = selectedSection.type === 'empty' ? selectedSection.endInInput + selectedSection.endSeparator.length : selectedSection.endInInput;\n\n        if (selectionStart !== inputRef.current.selectionStart || selectionEnd !== inputRef.current.selectionEnd) {\n          if (inputRef.current === getActiveElement(document)) {\n            inputRef.current.setSelectionRange(selectionStart, selectionEnd);\n          }\n        }\n\n        clearTimeout(selectionSyncTimeoutRef.current);\n        selectionSyncTimeoutRef.current = setTimeout(() => {\n          // handle case when the selection is not updated correctly\n          // could happen on Android\n          if (inputRef.current && inputRef.current === getActiveElement(document) && // The section might loose all selection, where `selectionStart === selectionEnd`\n          // https://github.com/mui/mui-x/pull/13652\n          inputRef.current.selectionStart === inputRef.current.selectionEnd && (inputRef.current.selectionStart !== selectionStart || inputRef.current.selectionEnd !== selectionEnd)) {\n            interactions.syncSelectionToDOM();\n          }\n        });\n      } // Even reading this variable seems to do the trick, but also setting it just to make use of it\n\n\n      inputRef.current.scrollTop = currentScrollTop;\n    },\n    getActiveSectionIndexFromDOM: () => {\n      const browserStartIndex = inputRef.current.selectionStart ?? 0;\n      const browserEndIndex = inputRef.current.selectionEnd ?? 0;\n\n      if (browserStartIndex === 0 && browserEndIndex === 0) {\n        return null;\n      }\n\n      const nextSectionIndex = browserStartIndex <= sections[0].startInInput ? 1 // Special case if browser index is in invisible characters at the beginning.\n      : sections.findIndex(section => section.startInInput - section.startSeparator.length > browserStartIndex);\n      return nextSectionIndex === -1 ? sections.length - 1 : nextSectionIndex - 1;\n    },\n    focusField: function () {\n      let newSelectedSection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      inputRef.current?.focus();\n      setSelectedSections(newSelectedSection);\n    },\n    setSelectedSections: newSelectedSections => setSelectedSections(newSelectedSections),\n    isFieldFocused: () => inputRef.current === getActiveElement(document)\n  }), [inputRef, parsedSelectedSections, sections, setSelectedSections]);\n\n  const syncSelectionFromDOM = () => {\n    const browserStartIndex = inputRef.current.selectionStart ?? 0;\n    let nextSectionIndex;\n\n    if (browserStartIndex <= sections[0].startInInput) {\n      // Special case if browser index is in invisible characters at the beginning\n      nextSectionIndex = 1;\n    } else if (browserStartIndex >= sections[sections.length - 1].endInInput) {\n      // If the click is after the last character of the input, then we want to select the 1st section.\n      nextSectionIndex = 1;\n    } else {\n      nextSectionIndex = sections.findIndex(section => section.startInInput - section.startSeparator.length > browserStartIndex);\n    }\n\n    const sectionIndex = nextSectionIndex === -1 ? sections.length - 1 : nextSectionIndex - 1;\n    setSelectedSections(sectionIndex);\n  };\n\n  const handleInputFocus = useEventCallback(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    onFocus?.(...args); // The ref is guaranteed to be resolved at this point.\n\n    const input = inputRef.current;\n    clearTimeout(focusTimeoutRef.current);\n    focusTimeoutRef.current = setTimeout(() => {\n      // The ref changed, the component got remounted, the focus event is no longer relevant.\n      if (!input || input !== inputRef.current) {\n        return;\n      }\n\n      if (activeSectionIndex != null) {\n        return;\n      }\n\n      if ( // avoid selecting all sections when focusing empty field without value\n      input.value.length && Number(input.selectionEnd) - Number(input.selectionStart) === input.value.length) {\n        setSelectedSections('all');\n      } else {\n        syncSelectionFromDOM();\n      }\n    });\n  });\n  const handleInputClick = useEventCallback(function (event) {\n    // The click event on the clear button would propagate to the input, trigger this handler and result in a wrong section selection.\n    // We avoid this by checking if the call of `handleInputClick` is actually intended, or a side effect.\n    if (event.isDefaultPrevented()) {\n      return;\n    }\n\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    onClick?.(event, ...args);\n    syncSelectionFromDOM();\n  });\n  const handleInputPaste = useEventCallback(event => {\n    onPaste?.(event); // prevent default to avoid the input `onChange` handler being called\n\n    event.preventDefault();\n\n    if (readOnly) {\n      return;\n    }\n\n    const pastedValue = event.clipboardData.getData('text');\n\n    if (typeof parsedSelectedSections === 'number') {\n      const activeSection = state.sections[parsedSelectedSections];\n      const lettersOnly = /^[a-zA-Z]+$/.test(pastedValue);\n      const digitsOnly = /^[0-9]+$/.test(pastedValue);\n      const digitsAndLetterOnly = /^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(pastedValue);\n      const isValidPastedValue = activeSection.contentType === 'letter' && lettersOnly || activeSection.contentType === 'digit' && digitsOnly || activeSection.contentType === 'digit-with-letter' && digitsAndLetterOnly;\n\n      if (isValidPastedValue) {\n        resetCharacterQuery();\n        updateSectionValue({\n          activeSection,\n          newSectionValue: pastedValue,\n          shouldGoToNextSection: true\n        });\n        return;\n      }\n\n      if (lettersOnly || digitsOnly) {\n        // The pasted value corresponds to a single section, but not the expected type,\n        // skip the modification\n        return;\n      }\n    }\n\n    resetCharacterQuery();\n    updateValueFromValueStr(pastedValue);\n  });\n  const handleContainerBlur = useEventCallback(function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    onBlur?.(...args);\n    setSelectedSections(null);\n  });\n  const handleInputChange = useEventCallback(event => {\n    if (readOnly) {\n      return;\n    }\n\n    const targetValue = event.target.value;\n\n    if (targetValue === '') {\n      resetCharacterQuery();\n      clearValue();\n      return;\n    }\n\n    const eventData = event.nativeEvent.data; // Calling `.fill(04/11/2022)` in playwright will trigger a change event with the requested content to insert in `event.nativeEvent.data`\n    // usual changes have only the currently typed character in the `event.nativeEvent.data`\n\n    const shouldUseEventData = eventData && eventData.length > 1;\n    const valueStr = shouldUseEventData ? eventData : targetValue;\n    const cleanValueStr = cleanString(valueStr); // If no section is selected or eventData should be used, we just try to parse the new value\n    // This line is mostly triggered by imperative code / application tests.\n\n    if (activeSectionIndex == null || shouldUseEventData) {\n      updateValueFromValueStr(shouldUseEventData ? eventData : cleanValueStr);\n      return;\n    }\n\n    let keyPressed;\n\n    if (parsedSelectedSections === 'all' && cleanValueStr.length === 1) {\n      keyPressed = cleanValueStr;\n    } else {\n      const prevValueStr = cleanString(fieldValueManager.getV6InputValueFromSections(sections, localizedDigits, isRtl));\n      let startOfDiffIndex = -1;\n      let endOfDiffIndex = -1;\n\n      for (let i = 0; i < prevValueStr.length; i += 1) {\n        if (startOfDiffIndex === -1 && prevValueStr[i] !== cleanValueStr[i]) {\n          startOfDiffIndex = i;\n        }\n\n        if (endOfDiffIndex === -1 && prevValueStr[prevValueStr.length - i - 1] !== cleanValueStr[cleanValueStr.length - i - 1]) {\n          endOfDiffIndex = i;\n        }\n      }\n\n      const activeSection = sections[activeSectionIndex];\n      const hasDiffOutsideOfActiveSection = startOfDiffIndex < activeSection.start || prevValueStr.length - endOfDiffIndex - 1 > activeSection.end;\n\n      if (hasDiffOutsideOfActiveSection) {\n        // TODO: Support if the new date is valid\n        return;\n      } // The active section being selected, the browser has replaced its value with the key pressed by the user.\n\n\n      const activeSectionEndRelativeToNewValue = cleanValueStr.length - prevValueStr.length + activeSection.end - cleanString(activeSection.endSeparator || '').length;\n      keyPressed = cleanValueStr.slice(activeSection.start + cleanString(activeSection.startSeparator || '').length, activeSectionEndRelativeToNewValue);\n    }\n\n    if (keyPressed.length === 0) {\n      if (isAndroid()) {\n        setTempAndroidValueStr(valueStr);\n      }\n\n      resetCharacterQuery();\n      clearActiveSection();\n      return;\n    }\n\n    applyCharacterEditing({\n      keyPressed,\n      sectionIndex: activeSectionIndex\n    });\n  });\n  const placeholder = React.useMemo(() => {\n    if (inPlaceholder !== undefined) {\n      return inPlaceholder;\n    }\n\n    return fieldValueManager.getV6InputValueFromSections(getSectionsFromValue(valueManager.emptyValue), localizedDigits, isRtl);\n  }, [inPlaceholder, fieldValueManager, getSectionsFromValue, valueManager.emptyValue, localizedDigits, isRtl]);\n  const valueStr = React.useMemo(() => state.tempValueStrAndroid ?? fieldValueManager.getV6InputValueFromSections(state.sections, localizedDigits, isRtl), [state.sections, fieldValueManager, state.tempValueStrAndroid, localizedDigits, isRtl]);\n  React.useEffect(() => {\n    // Select all the sections when focused on mount (`autoFocus = true` on the input)\n    if (inputRef.current && inputRef.current === getActiveElement(document)) {\n      setSelectedSections('all');\n    }\n\n    return () => {\n      clearTimeout(focusTimeoutRef.current);\n      clearTimeout(selectionSyncTimeoutRef.current);\n    };\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  const inputMode = React.useMemo(() => {\n    if (activeSectionIndex == null) {\n      return 'text';\n    }\n\n    if (state.sections[activeSectionIndex].contentType === 'letter') {\n      return 'text';\n    }\n\n    return 'numeric';\n  }, [activeSectionIndex, state.sections]);\n  const inputHasFocus = inputRef.current && inputRef.current === getActiveElement(document);\n  const shouldShowPlaceholder = !inputHasFocus && areAllSectionsEmpty;\n  return {\n    interactions,\n    returnedValue: {\n      // Forwarded\n      readOnly,\n      onBlur: handleContainerBlur,\n      onClick: handleInputClick,\n      onFocus: handleInputFocus,\n      onPaste: handleInputPaste,\n      inputRef: handleRef,\n      // Additional\n      enableAccessibleFieldDOMStructure: false,\n      placeholder,\n      inputMode,\n      autoComplete: 'off',\n      value: shouldShowPlaceholder ? '' : valueStr,\n      onChange: handleInputChange\n    }\n  };\n};","map":{"version":3,"names":["_extends","React","useRtl","useEventCallback","useForkRef","getActiveElement","getSectionVisibleValue","isAndroid","cleanString","dirtyString","replace","addPositionPropertiesToSections","sections","localizedDigits","isRtl","position","positionInInput","newSections","i","length","section","renderedValue","sectionStr","startSeparator","endSeparator","sectionLength","sectionLengthInInput","cleanedValue","startInInput","indexOf","endInInput","push","start","end","useFieldV6TextField","params","focusTimeoutRef","useRef","selectionSyncTimeoutRef","forwardedProps","onFocus","onClick","onPaste","onBlur","inputRef","inputRefProp","placeholder","inPlaceholder","internalProps","readOnly","parsedSelectedSections","activeSectionIndex","state","fieldValueManager","valueManager","applyCharacterEditing","resetCharacterQuery","updateSectionValue","updateValueFromValueStr","clearActiveSection","clearValue","setTempAndroidValueStr","setSelectedSections","getSectionsFromValue","areAllSectionsEmpty","handleRef","useMemo","interactions","syncSelectionToDOM","current","scrollLeft","document","currentScrollTop","scrollTop","select","selectedSection","selectionStart","type","selectionEnd","setSelectionRange","clearTimeout","setTimeout","getActiveSectionIndexFromDOM","browserStartIndex","browserEndIndex","nextSectionIndex","findIndex","focusField","newSelectedSection","focus","newSelectedSections","isFieldFocused","syncSelectionFromDOM","sectionIndex","handleInputFocus","args","input","value","Number","handleInputClick","event","isDefaultPrevented","handleInputPaste","preventDefault","pastedValue","clipboardData","getData","activeSection","lettersOnly","test","digitsOnly","digitsAndLetterOnly","isValidPastedValue","contentType","newSectionValue","shouldGoToNextSection","handleContainerBlur","handleInputChange","targetValue","target","eventData","nativeEvent","data","shouldUseEventData","valueStr","cleanValueStr","keyPressed","prevValueStr","getV6InputValueFromSections","startOfDiffIndex","endOfDiffIndex","hasDiffOutsideOfActiveSection","activeSectionEndRelativeToNewValue","slice","undefined","emptyValue","tempValueStrAndroid","useEffect","inputMode","inputHasFocus","shouldShowPlaceholder","returnedValue","enableAccessibleFieldDOMStructure","autoComplete","onChange"],"sources":["C:/Users/kb/Downloads/billBoard/billboard/node_modules/@mui/x-date-pickers/internals/hooks/useField/useFieldV6TextField.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useRtl } from '@mui/system/RtlProvider';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport useForkRef from '@mui/utils/useForkRef';\nimport { getActiveElement } from '../../utils/utils';\nimport { getSectionVisibleValue, isAndroid } from './useField.utils';\nconst cleanString = dirtyString => dirtyString.replace(/[\\u2066\\u2067\\u2068\\u2069]/g, '');\nexport const addPositionPropertiesToSections = (sections, localizedDigits, isRtl) => {\n  let position = 0;\n  let positionInInput = isRtl ? 1 : 0;\n  const newSections = [];\n  for (let i = 0; i < sections.length; i += 1) {\n    const section = sections[i];\n    const renderedValue = getSectionVisibleValue(section, isRtl ? 'input-rtl' : 'input-ltr', localizedDigits);\n    const sectionStr = `${section.startSeparator}${renderedValue}${section.endSeparator}`;\n    const sectionLength = cleanString(sectionStr).length;\n    const sectionLengthInInput = sectionStr.length;\n\n    // The ...InInput values consider the unicode characters but do include them in their indexes\n    const cleanedValue = cleanString(renderedValue);\n    const startInInput = positionInInput + (cleanedValue === '' ? 0 : renderedValue.indexOf(cleanedValue[0])) + section.startSeparator.length;\n    const endInInput = startInInput + cleanedValue.length;\n    newSections.push(_extends({}, section, {\n      start: position,\n      end: position + sectionLength,\n      startInInput,\n      endInInput\n    }));\n    position += sectionLength;\n    // Move position to the end of string associated to the current section\n    positionInInput += sectionLengthInInput;\n  }\n  return newSections;\n};\nexport const useFieldV6TextField = params => {\n  const isRtl = useRtl();\n  const focusTimeoutRef = React.useRef();\n  const selectionSyncTimeoutRef = React.useRef();\n  const {\n    forwardedProps: {\n      onFocus,\n      onClick,\n      onPaste,\n      onBlur,\n      inputRef: inputRefProp,\n      placeholder: inPlaceholder\n    },\n    internalProps: {\n      readOnly = false\n    },\n    parsedSelectedSections,\n    activeSectionIndex,\n    state,\n    fieldValueManager,\n    valueManager,\n    applyCharacterEditing,\n    resetCharacterQuery,\n    updateSectionValue,\n    updateValueFromValueStr,\n    clearActiveSection,\n    clearValue,\n    setTempAndroidValueStr,\n    setSelectedSections,\n    getSectionsFromValue,\n    areAllSectionsEmpty,\n    localizedDigits\n  } = params;\n  const inputRef = React.useRef(null);\n  const handleRef = useForkRef(inputRefProp, inputRef);\n  const sections = React.useMemo(() => addPositionPropertiesToSections(state.sections, localizedDigits, isRtl), [state.sections, localizedDigits, isRtl]);\n  const interactions = React.useMemo(() => ({\n    syncSelectionToDOM: () => {\n      if (!inputRef.current) {\n        return;\n      }\n      if (parsedSelectedSections == null) {\n        if (inputRef.current.scrollLeft) {\n          // Ensure that input content is not marked as selected.\n          // setting selection range to 0 causes issues in Safari.\n          // https://bugs.webkit.org/show_bug.cgi?id=224425\n          inputRef.current.scrollLeft = 0;\n        }\n        return;\n      }\n\n      // On multi input range pickers we want to update selection range only for the active input\n      // This helps to avoid the focus jumping on Safari https://github.com/mui/mui-x/issues/9003\n      // because WebKit implements the `setSelectionRange` based on the spec: https://bugs.webkit.org/show_bug.cgi?id=224425\n      if (inputRef.current !== getActiveElement(document)) {\n        return;\n      }\n\n      // Fix scroll jumping on iOS browser: https://github.com/mui/mui-x/issues/8321\n      const currentScrollTop = inputRef.current.scrollTop;\n      if (parsedSelectedSections === 'all') {\n        inputRef.current.select();\n      } else {\n        const selectedSection = sections[parsedSelectedSections];\n        const selectionStart = selectedSection.type === 'empty' ? selectedSection.startInInput - selectedSection.startSeparator.length : selectedSection.startInInput;\n        const selectionEnd = selectedSection.type === 'empty' ? selectedSection.endInInput + selectedSection.endSeparator.length : selectedSection.endInInput;\n        if (selectionStart !== inputRef.current.selectionStart || selectionEnd !== inputRef.current.selectionEnd) {\n          if (inputRef.current === getActiveElement(document)) {\n            inputRef.current.setSelectionRange(selectionStart, selectionEnd);\n          }\n        }\n        clearTimeout(selectionSyncTimeoutRef.current);\n        selectionSyncTimeoutRef.current = setTimeout(() => {\n          // handle case when the selection is not updated correctly\n          // could happen on Android\n          if (inputRef.current && inputRef.current === getActiveElement(document) &&\n          // The section might loose all selection, where `selectionStart === selectionEnd`\n          // https://github.com/mui/mui-x/pull/13652\n          inputRef.current.selectionStart === inputRef.current.selectionEnd && (inputRef.current.selectionStart !== selectionStart || inputRef.current.selectionEnd !== selectionEnd)) {\n            interactions.syncSelectionToDOM();\n          }\n        });\n      }\n\n      // Even reading this variable seems to do the trick, but also setting it just to make use of it\n      inputRef.current.scrollTop = currentScrollTop;\n    },\n    getActiveSectionIndexFromDOM: () => {\n      const browserStartIndex = inputRef.current.selectionStart ?? 0;\n      const browserEndIndex = inputRef.current.selectionEnd ?? 0;\n      if (browserStartIndex === 0 && browserEndIndex === 0) {\n        return null;\n      }\n      const nextSectionIndex = browserStartIndex <= sections[0].startInInput ? 1 // Special case if browser index is in invisible characters at the beginning.\n      : sections.findIndex(section => section.startInInput - section.startSeparator.length > browserStartIndex);\n      return nextSectionIndex === -1 ? sections.length - 1 : nextSectionIndex - 1;\n    },\n    focusField: (newSelectedSection = 0) => {\n      inputRef.current?.focus();\n      setSelectedSections(newSelectedSection);\n    },\n    setSelectedSections: newSelectedSections => setSelectedSections(newSelectedSections),\n    isFieldFocused: () => inputRef.current === getActiveElement(document)\n  }), [inputRef, parsedSelectedSections, sections, setSelectedSections]);\n  const syncSelectionFromDOM = () => {\n    const browserStartIndex = inputRef.current.selectionStart ?? 0;\n    let nextSectionIndex;\n    if (browserStartIndex <= sections[0].startInInput) {\n      // Special case if browser index is in invisible characters at the beginning\n      nextSectionIndex = 1;\n    } else if (browserStartIndex >= sections[sections.length - 1].endInInput) {\n      // If the click is after the last character of the input, then we want to select the 1st section.\n      nextSectionIndex = 1;\n    } else {\n      nextSectionIndex = sections.findIndex(section => section.startInInput - section.startSeparator.length > browserStartIndex);\n    }\n    const sectionIndex = nextSectionIndex === -1 ? sections.length - 1 : nextSectionIndex - 1;\n    setSelectedSections(sectionIndex);\n  };\n  const handleInputFocus = useEventCallback((...args) => {\n    onFocus?.(...args);\n    // The ref is guaranteed to be resolved at this point.\n    const input = inputRef.current;\n    clearTimeout(focusTimeoutRef.current);\n    focusTimeoutRef.current = setTimeout(() => {\n      // The ref changed, the component got remounted, the focus event is no longer relevant.\n      if (!input || input !== inputRef.current) {\n        return;\n      }\n      if (activeSectionIndex != null) {\n        return;\n      }\n      if (\n      // avoid selecting all sections when focusing empty field without value\n      input.value.length && Number(input.selectionEnd) - Number(input.selectionStart) === input.value.length) {\n        setSelectedSections('all');\n      } else {\n        syncSelectionFromDOM();\n      }\n    });\n  });\n  const handleInputClick = useEventCallback((event, ...args) => {\n    // The click event on the clear button would propagate to the input, trigger this handler and result in a wrong section selection.\n    // We avoid this by checking if the call of `handleInputClick` is actually intended, or a side effect.\n    if (event.isDefaultPrevented()) {\n      return;\n    }\n    onClick?.(event, ...args);\n    syncSelectionFromDOM();\n  });\n  const handleInputPaste = useEventCallback(event => {\n    onPaste?.(event);\n\n    // prevent default to avoid the input `onChange` handler being called\n    event.preventDefault();\n    if (readOnly) {\n      return;\n    }\n    const pastedValue = event.clipboardData.getData('text');\n    if (typeof parsedSelectedSections === 'number') {\n      const activeSection = state.sections[parsedSelectedSections];\n      const lettersOnly = /^[a-zA-Z]+$/.test(pastedValue);\n      const digitsOnly = /^[0-9]+$/.test(pastedValue);\n      const digitsAndLetterOnly = /^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(pastedValue);\n      const isValidPastedValue = activeSection.contentType === 'letter' && lettersOnly || activeSection.contentType === 'digit' && digitsOnly || activeSection.contentType === 'digit-with-letter' && digitsAndLetterOnly;\n      if (isValidPastedValue) {\n        resetCharacterQuery();\n        updateSectionValue({\n          activeSection,\n          newSectionValue: pastedValue,\n          shouldGoToNextSection: true\n        });\n        return;\n      }\n      if (lettersOnly || digitsOnly) {\n        // The pasted value corresponds to a single section, but not the expected type,\n        // skip the modification\n        return;\n      }\n    }\n    resetCharacterQuery();\n    updateValueFromValueStr(pastedValue);\n  });\n  const handleContainerBlur = useEventCallback((...args) => {\n    onBlur?.(...args);\n    setSelectedSections(null);\n  });\n  const handleInputChange = useEventCallback(event => {\n    if (readOnly) {\n      return;\n    }\n    const targetValue = event.target.value;\n    if (targetValue === '') {\n      resetCharacterQuery();\n      clearValue();\n      return;\n    }\n    const eventData = event.nativeEvent.data;\n    // Calling `.fill(04/11/2022)` in playwright will trigger a change event with the requested content to insert in `event.nativeEvent.data`\n    // usual changes have only the currently typed character in the `event.nativeEvent.data`\n    const shouldUseEventData = eventData && eventData.length > 1;\n    const valueStr = shouldUseEventData ? eventData : targetValue;\n    const cleanValueStr = cleanString(valueStr);\n\n    // If no section is selected or eventData should be used, we just try to parse the new value\n    // This line is mostly triggered by imperative code / application tests.\n    if (activeSectionIndex == null || shouldUseEventData) {\n      updateValueFromValueStr(shouldUseEventData ? eventData : cleanValueStr);\n      return;\n    }\n    let keyPressed;\n    if (parsedSelectedSections === 'all' && cleanValueStr.length === 1) {\n      keyPressed = cleanValueStr;\n    } else {\n      const prevValueStr = cleanString(fieldValueManager.getV6InputValueFromSections(sections, localizedDigits, isRtl));\n      let startOfDiffIndex = -1;\n      let endOfDiffIndex = -1;\n      for (let i = 0; i < prevValueStr.length; i += 1) {\n        if (startOfDiffIndex === -1 && prevValueStr[i] !== cleanValueStr[i]) {\n          startOfDiffIndex = i;\n        }\n        if (endOfDiffIndex === -1 && prevValueStr[prevValueStr.length - i - 1] !== cleanValueStr[cleanValueStr.length - i - 1]) {\n          endOfDiffIndex = i;\n        }\n      }\n      const activeSection = sections[activeSectionIndex];\n      const hasDiffOutsideOfActiveSection = startOfDiffIndex < activeSection.start || prevValueStr.length - endOfDiffIndex - 1 > activeSection.end;\n      if (hasDiffOutsideOfActiveSection) {\n        // TODO: Support if the new date is valid\n        return;\n      }\n\n      // The active section being selected, the browser has replaced its value with the key pressed by the user.\n      const activeSectionEndRelativeToNewValue = cleanValueStr.length - prevValueStr.length + activeSection.end - cleanString(activeSection.endSeparator || '').length;\n      keyPressed = cleanValueStr.slice(activeSection.start + cleanString(activeSection.startSeparator || '').length, activeSectionEndRelativeToNewValue);\n    }\n    if (keyPressed.length === 0) {\n      if (isAndroid()) {\n        setTempAndroidValueStr(valueStr);\n      }\n      resetCharacterQuery();\n      clearActiveSection();\n      return;\n    }\n    applyCharacterEditing({\n      keyPressed,\n      sectionIndex: activeSectionIndex\n    });\n  });\n  const placeholder = React.useMemo(() => {\n    if (inPlaceholder !== undefined) {\n      return inPlaceholder;\n    }\n    return fieldValueManager.getV6InputValueFromSections(getSectionsFromValue(valueManager.emptyValue), localizedDigits, isRtl);\n  }, [inPlaceholder, fieldValueManager, getSectionsFromValue, valueManager.emptyValue, localizedDigits, isRtl]);\n  const valueStr = React.useMemo(() => state.tempValueStrAndroid ?? fieldValueManager.getV6InputValueFromSections(state.sections, localizedDigits, isRtl), [state.sections, fieldValueManager, state.tempValueStrAndroid, localizedDigits, isRtl]);\n  React.useEffect(() => {\n    // Select all the sections when focused on mount (`autoFocus = true` on the input)\n    if (inputRef.current && inputRef.current === getActiveElement(document)) {\n      setSelectedSections('all');\n    }\n    return () => {\n      clearTimeout(focusTimeoutRef.current);\n      clearTimeout(selectionSyncTimeoutRef.current);\n    };\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  const inputMode = React.useMemo(() => {\n    if (activeSectionIndex == null) {\n      return 'text';\n    }\n    if (state.sections[activeSectionIndex].contentType === 'letter') {\n      return 'text';\n    }\n    return 'numeric';\n  }, [activeSectionIndex, state.sections]);\n  const inputHasFocus = inputRef.current && inputRef.current === getActiveElement(document);\n  const shouldShowPlaceholder = !inputHasFocus && areAllSectionsEmpty;\n  return {\n    interactions,\n    returnedValue: {\n      // Forwarded\n      readOnly,\n      onBlur: handleContainerBlur,\n      onClick: handleInputClick,\n      onFocus: handleInputFocus,\n      onPaste: handleInputPaste,\n      inputRef: handleRef,\n      // Additional\n      enableAccessibleFieldDOMStructure: false,\n      placeholder,\n      inputMode,\n      autoComplete: 'off',\n      value: shouldShowPlaceholder ? '' : valueStr,\n      onChange: handleInputChange\n    }\n  };\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}