{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { GRID_CHECKBOX_SELECTION_FIELD, gridFocusCellSelector, gridVisibleColumnFieldsSelector, useGridApiOptionHandler, useGridApiEventHandler, gridPaginatedVisibleSortedGridRowIdsSelector, gridExpandedSortedRowIdsSelector } from '@mui/x-data-grid';\nimport { buildWarning, getRowIdFromRowModel, getActiveElement, useGridRegisterPipeProcessor, getPublicApiRef, isPasteShortcut, useGridLogger } from '@mui/x-data-grid/internals';\nimport { GRID_DETAIL_PANEL_TOGGLE_FIELD, GRID_REORDER_COL_DEF } from '@mui/x-data-grid-pro';\nimport { unstable_debounce as debounce } from '@mui/utils';\nconst missingOnProcessRowUpdateErrorWarning = buildWarning(['MUI X: A call to `processRowUpdate` threw an error which was not handled because `onProcessRowUpdateError` is missing.', 'To handle the error pass a callback to the `onProcessRowUpdateError` prop, for example `<DataGrid onProcessRowUpdateError={(error) => ...} />`.', 'For more detail, see https://mui.com/x/react-data-grid/editing/#server-side-persistence.'], 'error');\nconst columnFieldsToExcludeFromPaste = [GRID_CHECKBOX_SELECTION_FIELD, GRID_REORDER_COL_DEF.field, GRID_DETAIL_PANEL_TOGGLE_FIELD]; // Batches rows that are updated during clipboard paste to reduce `updateRows` calls\n\nfunction batchRowUpdates(func, wait) {\n  let rows = [];\n  const debounced = debounce(() => {\n    func(rows);\n    rows = [];\n  }, wait);\n  return row => {\n    rows.push(row);\n    debounced();\n  };\n}\n\nasync function getTextFromClipboard(rootEl) {\n  return new Promise(resolve => {\n    const focusedCell = getActiveElement(document);\n    const el = document.createElement('input');\n    el.style.width = '0px';\n    el.style.height = '0px';\n    el.style.border = 'none';\n    el.style.margin = '0';\n    el.style.padding = '0';\n    el.style.outline = 'none';\n    el.style.position = 'absolute';\n    el.style.top = '0';\n    el.style.left = '0';\n\n    const handlePasteEvent = event => {\n      el.removeEventListener('paste', handlePasteEvent);\n      const text = event.clipboardData?.getData('text/plain');\n\n      if (focusedCell instanceof HTMLElement) {\n        focusedCell.focus({\n          preventScroll: true\n        });\n      }\n\n      el.remove();\n      resolve(text || '');\n    };\n\n    el.addEventListener('paste', handlePasteEvent);\n    rootEl.appendChild(el);\n    el.focus({\n      preventScroll: true\n    });\n  });\n} // Keeps track of updated rows during clipboard paste\n\n\nclass CellValueUpdater {\n  constructor(options) {\n    this.rowsToUpdate = {};\n    this.updateRow = void 0;\n    this.options = void 0;\n    this.options = options;\n    this.updateRow = batchRowUpdates(options.apiRef.current.updateRows, 50);\n  }\n\n  updateCell(_ref) {\n    let {\n      rowId,\n      field,\n      pastedCellValue\n    } = _ref;\n\n    if (pastedCellValue === undefined) {\n      return;\n    }\n\n    const {\n      apiRef,\n      getRowId\n    } = this.options;\n    const colDef = apiRef.current.getColumn(field);\n\n    if (!colDef || !colDef.editable) {\n      return;\n    }\n\n    const row = this.rowsToUpdate[rowId] || _extends({}, apiRef.current.getRow(rowId));\n\n    if (!row) {\n      return;\n    }\n\n    let parsedValue = pastedCellValue;\n\n    if (colDef.pastedValueParser) {\n      parsedValue = colDef.pastedValueParser(pastedCellValue, row, colDef, apiRef);\n    } else if (colDef.valueParser) {\n      parsedValue = colDef.valueParser(parsedValue, row, colDef, apiRef);\n    }\n\n    if (parsedValue === undefined) {\n      return;\n    }\n\n    let rowCopy = _extends({}, row);\n\n    if (typeof colDef.valueSetter === 'function') {\n      rowCopy = colDef.valueSetter(parsedValue, rowCopy, colDef, apiRef);\n    } else {\n      rowCopy[field] = parsedValue;\n    }\n\n    const newRowId = getRowIdFromRowModel(rowCopy, getRowId);\n\n    if (String(newRowId) !== String(rowId)) {\n      // We cannot update row id, so this cell value update should be ignored\n      return;\n    }\n\n    this.rowsToUpdate[rowId] = rowCopy;\n  }\n\n  applyUpdates() {\n    const {\n      apiRef,\n      processRowUpdate,\n      onProcessRowUpdateError\n    } = this.options;\n    const rowsToUpdate = this.rowsToUpdate;\n    const rowIdsToUpdate = Object.keys(rowsToUpdate);\n\n    if (rowIdsToUpdate.length === 0) {\n      apiRef.current.publishEvent('clipboardPasteEnd');\n      return;\n    }\n\n    const handleRowUpdate = async rowId => {\n      const newRow = rowsToUpdate[rowId];\n\n      if (typeof processRowUpdate === 'function') {\n        const handleError = errorThrown => {\n          if (onProcessRowUpdateError) {\n            onProcessRowUpdateError(errorThrown);\n          } else if (process.env.NODE_ENV !== 'production') {\n            missingOnProcessRowUpdateErrorWarning();\n          }\n        };\n\n        try {\n          const oldRow = apiRef.current.getRow(rowId);\n          const finalRowUpdate = await processRowUpdate(newRow, oldRow);\n          this.updateRow(finalRowUpdate);\n        } catch (error) {\n          handleError(error);\n        }\n      } else {\n        this.updateRow(newRow);\n      }\n    };\n\n    const promises = rowIdsToUpdate.map(rowId => {\n      // Wrap in promise that always resolves to avoid Promise.all from stopping on first error.\n      // This is to avoid using `Promise.allSettled` that has worse browser support.\n      return new Promise(resolve => {\n        handleRowUpdate(rowId).then(resolve).catch(resolve);\n      });\n    });\n    Promise.all(promises).then(() => {\n      this.rowsToUpdate = {};\n      apiRef.current.publishEvent('clipboardPasteEnd');\n    });\n  }\n\n}\n\nfunction defaultPasteResolver(_ref2) {\n  let {\n    pastedData,\n    apiRef,\n    updateCell,\n    pagination\n  } = _ref2;\n  const isSingleValuePasted = pastedData.length === 1 && pastedData[0].length === 1;\n  const cellSelectionModel = apiRef.current.getCellSelectionModel();\n  const selectedCellsArray = apiRef.current.getSelectedCellsAsArray();\n\n  if (cellSelectionModel && selectedCellsArray.length > 1) {\n    Object.keys(cellSelectionModel).forEach((rowId, rowIndex) => {\n      const rowDataArr = pastedData[isSingleValuePasted ? 0 : rowIndex];\n      const hasRowData = isSingleValuePasted ? true : rowDataArr !== undefined;\n\n      if (!hasRowData) {\n        return;\n      }\n\n      Object.keys(cellSelectionModel[rowId]).forEach((field, colIndex) => {\n        const cellValue = isSingleValuePasted ? rowDataArr[0] : rowDataArr[colIndex];\n        updateCell({\n          rowId,\n          field,\n          pastedCellValue: cellValue\n        });\n      });\n    });\n    return;\n  }\n\n  const visibleColumnFields = gridVisibleColumnFieldsSelector(apiRef).filter(field => {\n    if (columnFieldsToExcludeFromPaste.includes(field)) {\n      return false;\n    }\n\n    return true;\n  });\n  const selectedRows = apiRef.current.getSelectedRows();\n\n  if (selectedRows.size > 0 && !isSingleValuePasted) {\n    // Multiple values are pasted starting from the first and top-most cell\n    const pastedRowsDataCount = pastedData.length; // There's no guarantee that the selected rows are in the same order as the pasted rows\n\n    selectedRows.forEach((row, rowId) => {\n      let rowData;\n\n      if (pastedRowsDataCount === 1) {\n        // If only one row is pasted - paste it to all selected rows\n        rowData = pastedData[0];\n      } else {\n        rowData = pastedData.shift();\n      }\n\n      if (rowData === undefined) {\n        return;\n      }\n\n      rowData.forEach((newCellValue, cellIndex) => {\n        updateCell({\n          rowId,\n          field: visibleColumnFields[cellIndex],\n          pastedCellValue: newCellValue\n        });\n      });\n    });\n    return;\n  }\n\n  let selectedCell = gridFocusCellSelector(apiRef);\n\n  if (!selectedCell && selectedCellsArray.length === 1) {\n    selectedCell = selectedCellsArray[0];\n  }\n\n  if (!selectedCell) {\n    return;\n  }\n\n  if (columnFieldsToExcludeFromPaste.includes(selectedCell.field)) {\n    return;\n  }\n\n  const selectedRowId = selectedCell.id;\n  const selectedRowIndex = apiRef.current.getRowIndexRelativeToVisibleRows(selectedRowId);\n  const visibleRowIds = pagination ? gridPaginatedVisibleSortedGridRowIdsSelector(apiRef) : gridExpandedSortedRowIdsSelector(apiRef);\n  const selectedFieldIndex = visibleColumnFields.indexOf(selectedCell.field);\n  pastedData.forEach((rowData, index) => {\n    const rowId = visibleRowIds[selectedRowIndex + index];\n\n    if (typeof rowId === 'undefined') {\n      return;\n    }\n\n    for (let i = selectedFieldIndex; i < visibleColumnFields.length; i += 1) {\n      const field = visibleColumnFields[i];\n      const stringValue = rowData[i - selectedFieldIndex];\n      updateCell({\n        rowId,\n        field,\n        pastedCellValue: stringValue\n      });\n    }\n  });\n}\n\nexport const useGridClipboardImport = (apiRef, props) => {\n  const processRowUpdate = props.processRowUpdate;\n  const onProcessRowUpdateError = props.onProcessRowUpdateError;\n  const getRowId = props.getRowId;\n  const enableClipboardPaste = !props.disableClipboardPaste;\n  const rootEl = apiRef.current.rootElementRef?.current;\n  const logger = useGridLogger(apiRef, 'useGridClipboardImport');\n  const splitClipboardPastedText = props.splitClipboardPastedText;\n  const {\n    pagination,\n    onBeforeClipboardPasteStart\n  } = props;\n  const handlePaste = React.useCallback(async (params, event) => {\n    if (!enableClipboardPaste) {\n      return;\n    }\n\n    if (!isPasteShortcut(event)) {\n      return;\n    }\n\n    const focusedCell = gridFocusCellSelector(apiRef);\n\n    if (focusedCell !== null) {\n      const cellMode = apiRef.current.getCellMode(focusedCell.id, focusedCell.field);\n\n      if (cellMode === 'edit') {\n        // Do not paste data when the cell is in edit mode\n        return;\n      }\n    }\n\n    if (!rootEl) {\n      return;\n    }\n\n    const text = await getTextFromClipboard(rootEl);\n\n    if (!text) {\n      return;\n    }\n\n    const pastedData = splitClipboardPastedText(text);\n\n    if (!pastedData) {\n      return;\n    }\n\n    if (onBeforeClipboardPasteStart) {\n      try {\n        await onBeforeClipboardPasteStart({\n          data: pastedData\n        });\n      } catch (error) {\n        logger.debug('Clipboard paste operation cancelled');\n        return;\n      }\n    }\n\n    const cellUpdater = new CellValueUpdater({\n      apiRef,\n      processRowUpdate,\n      onProcessRowUpdateError,\n      getRowId\n    });\n    apiRef.current.publishEvent('clipboardPasteStart', {\n      data: pastedData\n    });\n    defaultPasteResolver({\n      pastedData,\n      apiRef: getPublicApiRef(apiRef),\n      updateCell: function () {\n        cellUpdater.updateCell(...arguments);\n      },\n      pagination\n    });\n    cellUpdater.applyUpdates();\n  }, [apiRef, processRowUpdate, onProcessRowUpdateError, getRowId, enableClipboardPaste, rootEl, splitClipboardPastedText, pagination, onBeforeClipboardPasteStart, logger]);\n  const checkIfCanStartEditing = React.useCallback((initialValue, _ref3) => {\n    let {\n      event\n    } = _ref3;\n\n    if (isPasteShortcut(event) && enableClipboardPaste) {\n      // Do not enter cell edit mode on paste\n      return false;\n    }\n\n    return initialValue;\n  }, [enableClipboardPaste]);\n  useGridApiEventHandler(apiRef, 'cellKeyDown', handlePaste);\n  useGridApiOptionHandler(apiRef, 'clipboardPasteStart', props.onClipboardPasteStart);\n  useGridApiOptionHandler(apiRef, 'clipboardPasteEnd', props.onClipboardPasteEnd);\n  useGridRegisterPipeProcessor(apiRef, 'canStartEditing', checkIfCanStartEditing);\n};","map":{"version":3,"names":["_extends","React","GRID_CHECKBOX_SELECTION_FIELD","gridFocusCellSelector","gridVisibleColumnFieldsSelector","useGridApiOptionHandler","useGridApiEventHandler","gridPaginatedVisibleSortedGridRowIdsSelector","gridExpandedSortedRowIdsSelector","buildWarning","getRowIdFromRowModel","getActiveElement","useGridRegisterPipeProcessor","getPublicApiRef","isPasteShortcut","useGridLogger","GRID_DETAIL_PANEL_TOGGLE_FIELD","GRID_REORDER_COL_DEF","unstable_debounce","debounce","missingOnProcessRowUpdateErrorWarning","columnFieldsToExcludeFromPaste","field","batchRowUpdates","func","wait","rows","debounced","row","push","getTextFromClipboard","rootEl","Promise","resolve","focusedCell","document","el","createElement","style","width","height","border","margin","padding","outline","position","top","left","handlePasteEvent","event","removeEventListener","text","clipboardData","getData","HTMLElement","focus","preventScroll","remove","addEventListener","appendChild","CellValueUpdater","constructor","options","rowsToUpdate","updateRow","apiRef","current","updateRows","updateCell","rowId","pastedCellValue","undefined","getRowId","colDef","getColumn","editable","getRow","parsedValue","pastedValueParser","valueParser","rowCopy","valueSetter","newRowId","String","applyUpdates","processRowUpdate","onProcessRowUpdateError","rowIdsToUpdate","Object","keys","length","publishEvent","handleRowUpdate","newRow","handleError","errorThrown","process","env","NODE_ENV","oldRow","finalRowUpdate","error","promises","map","then","catch","all","defaultPasteResolver","pastedData","pagination","isSingleValuePasted","cellSelectionModel","getCellSelectionModel","selectedCellsArray","getSelectedCellsAsArray","forEach","rowIndex","rowDataArr","hasRowData","colIndex","cellValue","visibleColumnFields","filter","includes","selectedRows","getSelectedRows","size","pastedRowsDataCount","rowData","shift","newCellValue","cellIndex","selectedCell","selectedRowId","id","selectedRowIndex","getRowIndexRelativeToVisibleRows","visibleRowIds","selectedFieldIndex","indexOf","index","i","stringValue","useGridClipboardImport","props","enableClipboardPaste","disableClipboardPaste","rootElementRef","logger","splitClipboardPastedText","onBeforeClipboardPasteStart","handlePaste","useCallback","params","cellMode","getCellMode","data","debug","cellUpdater","checkIfCanStartEditing","initialValue","onClipboardPasteStart","onClipboardPasteEnd"],"sources":["C:/Users/kb/Downloads/billBoard/billboard/node_modules/@mui/x-data-grid-premium/esm/hooks/features/clipboard/useGridClipboardImport.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { GRID_CHECKBOX_SELECTION_FIELD, gridFocusCellSelector, gridVisibleColumnFieldsSelector, useGridApiOptionHandler, useGridApiEventHandler, gridPaginatedVisibleSortedGridRowIdsSelector, gridExpandedSortedRowIdsSelector } from '@mui/x-data-grid';\nimport { buildWarning, getRowIdFromRowModel, getActiveElement, useGridRegisterPipeProcessor, getPublicApiRef, isPasteShortcut, useGridLogger } from '@mui/x-data-grid/internals';\nimport { GRID_DETAIL_PANEL_TOGGLE_FIELD, GRID_REORDER_COL_DEF } from '@mui/x-data-grid-pro';\nimport { unstable_debounce as debounce } from '@mui/utils';\nconst missingOnProcessRowUpdateErrorWarning = buildWarning(['MUI X: A call to `processRowUpdate` threw an error which was not handled because `onProcessRowUpdateError` is missing.', 'To handle the error pass a callback to the `onProcessRowUpdateError` prop, for example `<DataGrid onProcessRowUpdateError={(error) => ...} />`.', 'For more detail, see https://mui.com/x/react-data-grid/editing/#server-side-persistence.'], 'error');\nconst columnFieldsToExcludeFromPaste = [GRID_CHECKBOX_SELECTION_FIELD, GRID_REORDER_COL_DEF.field, GRID_DETAIL_PANEL_TOGGLE_FIELD];\n\n// Batches rows that are updated during clipboard paste to reduce `updateRows` calls\nfunction batchRowUpdates(func, wait) {\n  let rows = [];\n  const debounced = debounce(() => {\n    func(rows);\n    rows = [];\n  }, wait);\n  return row => {\n    rows.push(row);\n    debounced();\n  };\n}\nasync function getTextFromClipboard(rootEl) {\n  return new Promise(resolve => {\n    const focusedCell = getActiveElement(document);\n    const el = document.createElement('input');\n    el.style.width = '0px';\n    el.style.height = '0px';\n    el.style.border = 'none';\n    el.style.margin = '0';\n    el.style.padding = '0';\n    el.style.outline = 'none';\n    el.style.position = 'absolute';\n    el.style.top = '0';\n    el.style.left = '0';\n    const handlePasteEvent = event => {\n      el.removeEventListener('paste', handlePasteEvent);\n      const text = event.clipboardData?.getData('text/plain');\n      if (focusedCell instanceof HTMLElement) {\n        focusedCell.focus({\n          preventScroll: true\n        });\n      }\n      el.remove();\n      resolve(text || '');\n    };\n    el.addEventListener('paste', handlePasteEvent);\n    rootEl.appendChild(el);\n    el.focus({\n      preventScroll: true\n    });\n  });\n}\n\n// Keeps track of updated rows during clipboard paste\nclass CellValueUpdater {\n  constructor(options) {\n    this.rowsToUpdate = {};\n    this.updateRow = void 0;\n    this.options = void 0;\n    this.options = options;\n    this.updateRow = batchRowUpdates(options.apiRef.current.updateRows, 50);\n  }\n  updateCell({\n    rowId,\n    field,\n    pastedCellValue\n  }) {\n    if (pastedCellValue === undefined) {\n      return;\n    }\n    const {\n      apiRef,\n      getRowId\n    } = this.options;\n    const colDef = apiRef.current.getColumn(field);\n    if (!colDef || !colDef.editable) {\n      return;\n    }\n    const row = this.rowsToUpdate[rowId] || _extends({}, apiRef.current.getRow(rowId));\n    if (!row) {\n      return;\n    }\n    let parsedValue = pastedCellValue;\n    if (colDef.pastedValueParser) {\n      parsedValue = colDef.pastedValueParser(pastedCellValue, row, colDef, apiRef);\n    } else if (colDef.valueParser) {\n      parsedValue = colDef.valueParser(parsedValue, row, colDef, apiRef);\n    }\n    if (parsedValue === undefined) {\n      return;\n    }\n    let rowCopy = _extends({}, row);\n    if (typeof colDef.valueSetter === 'function') {\n      rowCopy = colDef.valueSetter(parsedValue, rowCopy, colDef, apiRef);\n    } else {\n      rowCopy[field] = parsedValue;\n    }\n    const newRowId = getRowIdFromRowModel(rowCopy, getRowId);\n    if (String(newRowId) !== String(rowId)) {\n      // We cannot update row id, so this cell value update should be ignored\n      return;\n    }\n    this.rowsToUpdate[rowId] = rowCopy;\n  }\n  applyUpdates() {\n    const {\n      apiRef,\n      processRowUpdate,\n      onProcessRowUpdateError\n    } = this.options;\n    const rowsToUpdate = this.rowsToUpdate;\n    const rowIdsToUpdate = Object.keys(rowsToUpdate);\n    if (rowIdsToUpdate.length === 0) {\n      apiRef.current.publishEvent('clipboardPasteEnd');\n      return;\n    }\n    const handleRowUpdate = async rowId => {\n      const newRow = rowsToUpdate[rowId];\n      if (typeof processRowUpdate === 'function') {\n        const handleError = errorThrown => {\n          if (onProcessRowUpdateError) {\n            onProcessRowUpdateError(errorThrown);\n          } else if (process.env.NODE_ENV !== 'production') {\n            missingOnProcessRowUpdateErrorWarning();\n          }\n        };\n        try {\n          const oldRow = apiRef.current.getRow(rowId);\n          const finalRowUpdate = await processRowUpdate(newRow, oldRow);\n          this.updateRow(finalRowUpdate);\n        } catch (error) {\n          handleError(error);\n        }\n      } else {\n        this.updateRow(newRow);\n      }\n    };\n    const promises = rowIdsToUpdate.map(rowId => {\n      // Wrap in promise that always resolves to avoid Promise.all from stopping on first error.\n      // This is to avoid using `Promise.allSettled` that has worse browser support.\n      return new Promise(resolve => {\n        handleRowUpdate(rowId).then(resolve).catch(resolve);\n      });\n    });\n    Promise.all(promises).then(() => {\n      this.rowsToUpdate = {};\n      apiRef.current.publishEvent('clipboardPasteEnd');\n    });\n  }\n}\nfunction defaultPasteResolver({\n  pastedData,\n  apiRef,\n  updateCell,\n  pagination\n}) {\n  const isSingleValuePasted = pastedData.length === 1 && pastedData[0].length === 1;\n  const cellSelectionModel = apiRef.current.getCellSelectionModel();\n  const selectedCellsArray = apiRef.current.getSelectedCellsAsArray();\n  if (cellSelectionModel && selectedCellsArray.length > 1) {\n    Object.keys(cellSelectionModel).forEach((rowId, rowIndex) => {\n      const rowDataArr = pastedData[isSingleValuePasted ? 0 : rowIndex];\n      const hasRowData = isSingleValuePasted ? true : rowDataArr !== undefined;\n      if (!hasRowData) {\n        return;\n      }\n      Object.keys(cellSelectionModel[rowId]).forEach((field, colIndex) => {\n        const cellValue = isSingleValuePasted ? rowDataArr[0] : rowDataArr[colIndex];\n        updateCell({\n          rowId,\n          field,\n          pastedCellValue: cellValue\n        });\n      });\n    });\n    return;\n  }\n  const visibleColumnFields = gridVisibleColumnFieldsSelector(apiRef).filter(field => {\n    if (columnFieldsToExcludeFromPaste.includes(field)) {\n      return false;\n    }\n    return true;\n  });\n  const selectedRows = apiRef.current.getSelectedRows();\n  if (selectedRows.size > 0 && !isSingleValuePasted) {\n    // Multiple values are pasted starting from the first and top-most cell\n    const pastedRowsDataCount = pastedData.length;\n\n    // There's no guarantee that the selected rows are in the same order as the pasted rows\n    selectedRows.forEach((row, rowId) => {\n      let rowData;\n      if (pastedRowsDataCount === 1) {\n        // If only one row is pasted - paste it to all selected rows\n        rowData = pastedData[0];\n      } else {\n        rowData = pastedData.shift();\n      }\n      if (rowData === undefined) {\n        return;\n      }\n      rowData.forEach((newCellValue, cellIndex) => {\n        updateCell({\n          rowId,\n          field: visibleColumnFields[cellIndex],\n          pastedCellValue: newCellValue\n        });\n      });\n    });\n    return;\n  }\n  let selectedCell = gridFocusCellSelector(apiRef);\n  if (!selectedCell && selectedCellsArray.length === 1) {\n    selectedCell = selectedCellsArray[0];\n  }\n  if (!selectedCell) {\n    return;\n  }\n  if (columnFieldsToExcludeFromPaste.includes(selectedCell.field)) {\n    return;\n  }\n  const selectedRowId = selectedCell.id;\n  const selectedRowIndex = apiRef.current.getRowIndexRelativeToVisibleRows(selectedRowId);\n  const visibleRowIds = pagination ? gridPaginatedVisibleSortedGridRowIdsSelector(apiRef) : gridExpandedSortedRowIdsSelector(apiRef);\n  const selectedFieldIndex = visibleColumnFields.indexOf(selectedCell.field);\n  pastedData.forEach((rowData, index) => {\n    const rowId = visibleRowIds[selectedRowIndex + index];\n    if (typeof rowId === 'undefined') {\n      return;\n    }\n    for (let i = selectedFieldIndex; i < visibleColumnFields.length; i += 1) {\n      const field = visibleColumnFields[i];\n      const stringValue = rowData[i - selectedFieldIndex];\n      updateCell({\n        rowId,\n        field,\n        pastedCellValue: stringValue\n      });\n    }\n  });\n}\nexport const useGridClipboardImport = (apiRef, props) => {\n  const processRowUpdate = props.processRowUpdate;\n  const onProcessRowUpdateError = props.onProcessRowUpdateError;\n  const getRowId = props.getRowId;\n  const enableClipboardPaste = !props.disableClipboardPaste;\n  const rootEl = apiRef.current.rootElementRef?.current;\n  const logger = useGridLogger(apiRef, 'useGridClipboardImport');\n  const splitClipboardPastedText = props.splitClipboardPastedText;\n  const {\n    pagination,\n    onBeforeClipboardPasteStart\n  } = props;\n  const handlePaste = React.useCallback(async (params, event) => {\n    if (!enableClipboardPaste) {\n      return;\n    }\n    if (!isPasteShortcut(event)) {\n      return;\n    }\n    const focusedCell = gridFocusCellSelector(apiRef);\n    if (focusedCell !== null) {\n      const cellMode = apiRef.current.getCellMode(focusedCell.id, focusedCell.field);\n      if (cellMode === 'edit') {\n        // Do not paste data when the cell is in edit mode\n        return;\n      }\n    }\n    if (!rootEl) {\n      return;\n    }\n    const text = await getTextFromClipboard(rootEl);\n    if (!text) {\n      return;\n    }\n    const pastedData = splitClipboardPastedText(text);\n    if (!pastedData) {\n      return;\n    }\n    if (onBeforeClipboardPasteStart) {\n      try {\n        await onBeforeClipboardPasteStart({\n          data: pastedData\n        });\n      } catch (error) {\n        logger.debug('Clipboard paste operation cancelled');\n        return;\n      }\n    }\n    const cellUpdater = new CellValueUpdater({\n      apiRef,\n      processRowUpdate,\n      onProcessRowUpdateError,\n      getRowId\n    });\n    apiRef.current.publishEvent('clipboardPasteStart', {\n      data: pastedData\n    });\n    defaultPasteResolver({\n      pastedData,\n      apiRef: getPublicApiRef(apiRef),\n      updateCell: (...args) => {\n        cellUpdater.updateCell(...args);\n      },\n      pagination\n    });\n    cellUpdater.applyUpdates();\n  }, [apiRef, processRowUpdate, onProcessRowUpdateError, getRowId, enableClipboardPaste, rootEl, splitClipboardPastedText, pagination, onBeforeClipboardPasteStart, logger]);\n  const checkIfCanStartEditing = React.useCallback((initialValue, {\n    event\n  }) => {\n    if (isPasteShortcut(event) && enableClipboardPaste) {\n      // Do not enter cell edit mode on paste\n      return false;\n    }\n    return initialValue;\n  }, [enableClipboardPaste]);\n  useGridApiEventHandler(apiRef, 'cellKeyDown', handlePaste);\n  useGridApiOptionHandler(apiRef, 'clipboardPasteStart', props.onClipboardPasteStart);\n  useGridApiOptionHandler(apiRef, 'clipboardPasteEnd', props.onClipboardPasteEnd);\n  useGridRegisterPipeProcessor(apiRef, 'canStartEditing', checkIfCanStartEditing);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}