{"ast":null,"code":"import { gridColumnLookupSelector, gridFilteredRowsLookupSelector, gridRowTreeSelector, GRID_ROOT_GROUP_ID } from '@mui/x-data-grid-pro';\nimport { getAggregationRules } from './gridAggregationUtils';\nimport { gridAggregationModelSelector } from './gridAggregationSelectors';\n\nconst getAggregationCellValue = _ref => {\n  let {\n    apiRef,\n    groupId,\n    field,\n    aggregationFunction,\n    aggregationRowsScope\n  } = _ref;\n  const filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef);\n  const rowIds = apiRef.current.getRowGroupChildren({\n    groupId\n  });\n  const values = [];\n  rowIds.forEach(rowId => {\n    if (aggregationRowsScope === 'filtered' && filteredRowsLookup[rowId] === false) {\n      return;\n    } // If the row is a group, we want to aggregate based on its children\n    // For instance in the following tree, we want the aggregated values of A to be based on A.A, A.B.A and A.B.B but not A.B\n    // A\n    //   A.A\n    //   A.B\n    //     A.B.A\n    //     A.B.B\n\n\n    const rowNode = apiRef.current.getRowNode(rowId);\n\n    if (rowNode.type === 'group') {\n      return;\n    }\n\n    if (typeof aggregationFunction.getCellValue === 'function') {\n      const row = apiRef.current.getRow(rowId);\n      values.push(aggregationFunction.getCellValue({\n        row\n      }));\n    } else {\n      values.push(apiRef.current.getCellValue(rowId, field));\n    }\n  });\n  return aggregationFunction.apply({\n    values,\n    groupId,\n    field // Added per user request in https://github.com/mui/mui-x/issues/6995#issuecomment-1327423455\n\n  });\n};\n\nconst getGroupAggregatedValue = _ref2 => {\n  let {\n    groupId,\n    apiRef,\n    aggregationRowsScope,\n    aggregatedFields,\n    aggregationRules,\n    position\n  } = _ref2;\n  const groupAggregationLookup = {};\n\n  for (let j = 0; j < aggregatedFields.length; j += 1) {\n    const aggregatedField = aggregatedFields[j];\n    const columnAggregationRules = aggregationRules[aggregatedField];\n    groupAggregationLookup[aggregatedField] = {\n      position,\n      value: getAggregationCellValue({\n        apiRef,\n        groupId,\n        field: aggregatedField,\n        aggregationFunction: columnAggregationRules.aggregationFunction,\n        aggregationRowsScope\n      })\n    };\n  }\n\n  return groupAggregationLookup;\n};\n\nexport const createAggregationLookup = _ref3 => {\n  let {\n    apiRef,\n    aggregationFunctions,\n    aggregationRowsScope,\n    getAggregationPosition\n  } = _ref3;\n  const aggregationRules = getAggregationRules({\n    columnsLookup: gridColumnLookupSelector(apiRef),\n    aggregationModel: gridAggregationModelSelector(apiRef),\n    aggregationFunctions\n  });\n  const aggregatedFields = Object.keys(aggregationRules);\n\n  if (aggregatedFields.length === 0) {\n    return {};\n  }\n\n  const aggregationLookup = {};\n  const rowTree = gridRowTreeSelector(apiRef);\n\n  const createGroupAggregationLookup = groupNode => {\n    for (let i = 0; i < groupNode.children.length; i += 1) {\n      const childId = groupNode.children[i];\n      const childNode = rowTree[childId];\n\n      if (childNode.type === 'group') {\n        createGroupAggregationLookup(childNode);\n      }\n    }\n\n    const hasAggregableChildren = groupNode.children.length;\n\n    if (hasAggregableChildren) {\n      const position = getAggregationPosition(groupNode);\n\n      if (position != null) {\n        aggregationLookup[groupNode.id] = getGroupAggregatedValue({\n          groupId: groupNode.id,\n          apiRef,\n          aggregatedFields,\n          aggregationRowsScope,\n          aggregationRules,\n          position\n        });\n      }\n    }\n  };\n\n  createGroupAggregationLookup(rowTree[GRID_ROOT_GROUP_ID]);\n  return aggregationLookup;\n};","map":{"version":3,"names":["gridColumnLookupSelector","gridFilteredRowsLookupSelector","gridRowTreeSelector","GRID_ROOT_GROUP_ID","getAggregationRules","gridAggregationModelSelector","getAggregationCellValue","apiRef","groupId","field","aggregationFunction","aggregationRowsScope","filteredRowsLookup","rowIds","current","getRowGroupChildren","values","forEach","rowId","rowNode","getRowNode","type","getCellValue","row","getRow","push","apply","getGroupAggregatedValue","aggregatedFields","aggregationRules","position","groupAggregationLookup","j","length","aggregatedField","columnAggregationRules","value","createAggregationLookup","aggregationFunctions","getAggregationPosition","columnsLookup","aggregationModel","Object","keys","aggregationLookup","rowTree","createGroupAggregationLookup","groupNode","i","children","childId","childNode","hasAggregableChildren","id"],"sources":["C:/Users/kb/Downloads/billBoard/billboard/node_modules/@mui/x-data-grid-premium/esm/hooks/features/aggregation/createAggregationLookup.js"],"sourcesContent":["import { gridColumnLookupSelector, gridFilteredRowsLookupSelector, gridRowTreeSelector, GRID_ROOT_GROUP_ID } from '@mui/x-data-grid-pro';\nimport { getAggregationRules } from './gridAggregationUtils';\nimport { gridAggregationModelSelector } from './gridAggregationSelectors';\nconst getAggregationCellValue = ({\n  apiRef,\n  groupId,\n  field,\n  aggregationFunction,\n  aggregationRowsScope\n}) => {\n  const filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef);\n  const rowIds = apiRef.current.getRowGroupChildren({\n    groupId\n  });\n  const values = [];\n  rowIds.forEach(rowId => {\n    if (aggregationRowsScope === 'filtered' && filteredRowsLookup[rowId] === false) {\n      return;\n    }\n\n    // If the row is a group, we want to aggregate based on its children\n    // For instance in the following tree, we want the aggregated values of A to be based on A.A, A.B.A and A.B.B but not A.B\n    // A\n    //   A.A\n    //   A.B\n    //     A.B.A\n    //     A.B.B\n    const rowNode = apiRef.current.getRowNode(rowId);\n    if (rowNode.type === 'group') {\n      return;\n    }\n    if (typeof aggregationFunction.getCellValue === 'function') {\n      const row = apiRef.current.getRow(rowId);\n      values.push(aggregationFunction.getCellValue({\n        row\n      }));\n    } else {\n      values.push(apiRef.current.getCellValue(rowId, field));\n    }\n  });\n  return aggregationFunction.apply({\n    values,\n    groupId,\n    field // Added per user request in https://github.com/mui/mui-x/issues/6995#issuecomment-1327423455\n  });\n};\nconst getGroupAggregatedValue = ({\n  groupId,\n  apiRef,\n  aggregationRowsScope,\n  aggregatedFields,\n  aggregationRules,\n  position\n}) => {\n  const groupAggregationLookup = {};\n  for (let j = 0; j < aggregatedFields.length; j += 1) {\n    const aggregatedField = aggregatedFields[j];\n    const columnAggregationRules = aggregationRules[aggregatedField];\n    groupAggregationLookup[aggregatedField] = {\n      position,\n      value: getAggregationCellValue({\n        apiRef,\n        groupId,\n        field: aggregatedField,\n        aggregationFunction: columnAggregationRules.aggregationFunction,\n        aggregationRowsScope\n      })\n    };\n  }\n  return groupAggregationLookup;\n};\nexport const createAggregationLookup = ({\n  apiRef,\n  aggregationFunctions,\n  aggregationRowsScope,\n  getAggregationPosition\n}) => {\n  const aggregationRules = getAggregationRules({\n    columnsLookup: gridColumnLookupSelector(apiRef),\n    aggregationModel: gridAggregationModelSelector(apiRef),\n    aggregationFunctions\n  });\n  const aggregatedFields = Object.keys(aggregationRules);\n  if (aggregatedFields.length === 0) {\n    return {};\n  }\n  const aggregationLookup = {};\n  const rowTree = gridRowTreeSelector(apiRef);\n  const createGroupAggregationLookup = groupNode => {\n    for (let i = 0; i < groupNode.children.length; i += 1) {\n      const childId = groupNode.children[i];\n      const childNode = rowTree[childId];\n      if (childNode.type === 'group') {\n        createGroupAggregationLookup(childNode);\n      }\n    }\n    const hasAggregableChildren = groupNode.children.length;\n    if (hasAggregableChildren) {\n      const position = getAggregationPosition(groupNode);\n      if (position != null) {\n        aggregationLookup[groupNode.id] = getGroupAggregatedValue({\n          groupId: groupNode.id,\n          apiRef,\n          aggregatedFields,\n          aggregationRowsScope,\n          aggregationRules,\n          position\n        });\n      }\n    }\n  };\n  createGroupAggregationLookup(rowTree[GRID_ROOT_GROUP_ID]);\n  return aggregationLookup;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}